// @generated by protoc-gen-es v1.3.3 with parameter "target=js+dts"
// @generated from file api/v0alpha/lms.proto (package api.v0alpha, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Timestamp as Timestamp$1 } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { AbsentPolicyType, ChainOperator, CompareOperator, ComplianceListType, ConsentActionType, ConstructedFilename, DateTimePrecision, DeDupActions, DedupKeyPolicy, DialOrderType, DuplicatePolicyType, EnrichmentType, EventState, ExportType, FieldType, FileFormat, FilePattern, HttpVerb, PaginationTerminator, PipelineElementStatusType, PrimarySource, RecordType, RunType, SortOrder } from "../commons/lms_pb.js";
import type { CommType } from "../commons/communication_pb.js";
import type { Channel, ContentType } from "../commons/compliance_pb.js";
import type { StringArraySql } from "../commons/types_pb.js";

/**
 * @generated from enum api.v0alpha.TimeUnit
 */
export declare enum TimeUnit {
  /**
   * DEFAULT is decided by SURL (no quantity needed)
   *
   * @generated from enum value: DEFAULT = 0;
   */
  DEFAULT = 0,

  /**
   * @generated from enum value: TIME_WEEKS = 1;
   */
  TIME_WEEKS = 1,

  /**
   * @generated from enum value: TIME_DAYS = 2;
   */
  TIME_DAYS = 2,

  /**
   * @generated from enum value: TIME_HOURS = 3;
   */
  TIME_HOURS = 3,
}

/**
 * The types of entities that can be returned from Epic's bulk data api.
 *
 * @generated from enum api.v0alpha.EpicEntityType
 */
export declare enum EpicEntityType {
  /**
   * @generated from enum value: EPIC_UNKNOWN_TYPE = 0;
   */
  EPIC_UNKNOWN_TYPE = 0,

  /**
   * @generated from enum value: EPIC_ENTITY_TYPE_PATIENT = 1;
   */
  EPIC_ENTITY_TYPE_PATIENT = 1,

  /**
   * @generated from enum value: EPIC_ENTITY_TYPE_APPOINTMENT = 2;
   */
  EPIC_ENTITY_TYPE_APPOINTMENT = 2,

  /**
   * @generated from enum value: EPIC_ENTITY_TYPE_MEDICATION = 3;
   */
  EPIC_ENTITY_TYPE_MEDICATION = 3,

  /**
   * @generated from enum value: EPIC_ENTITY_TYPE_MEDICATION_REQUEST = 4;
   */
  EPIC_ENTITY_TYPE_MEDICATION_REQUEST = 4,

  /**
   * @generated from enum value: EPIC_ENTITY_TYPE_ACCOUNT = 5;
   */
  EPIC_ENTITY_TYPE_ACCOUNT = 5,
}

/**
 * @generated from message api.v0alpha.GetPublicKeyReq
 */
export declare class GetPublicKeyReq extends Message<GetPublicKeyReq> {
  constructor(data?: PartialMessage<GetPublicKeyReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.GetPublicKeyReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPublicKeyReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPublicKeyReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPublicKeyReq;

  static equals(a: GetPublicKeyReq | PlainMessage<GetPublicKeyReq> | undefined, b: GetPublicKeyReq | PlainMessage<GetPublicKeyReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.PublicKey
 */
export declare class PublicKey extends Message<PublicKey> {
  /**
   * @generated from field: string key = 1;
   */
  key: string;

  constructor(data?: PartialMessage<PublicKey>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.PublicKey";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublicKey;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublicKey;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublicKey;

  static equals(a: PublicKey | PlainMessage<PublicKey> | undefined, b: PublicKey | PlainMessage<PublicKey> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.FindFieldUsagesReq
 */
export declare class FindFieldUsagesReq extends Message<FindFieldUsagesReq> {
  /**
   * @generated from field: string field_name = 3;
   */
  fieldName: string;

  constructor(data?: PartialMessage<FindFieldUsagesReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.FindFieldUsagesReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindFieldUsagesReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindFieldUsagesReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FindFieldUsagesReq;

  static equals(a: FindFieldUsagesReq | PlainMessage<FindFieldUsagesReq> | undefined, b: FindFieldUsagesReq | PlainMessage<FindFieldUsagesReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.NameAndId
 */
export declare class NameAndId extends Message<NameAndId> {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * @generated from field: string name = 2;
   */
  name: string;

  constructor(data?: PartialMessage<NameAndId>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.NameAndId";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NameAndId;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NameAndId;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NameAndId;

  static equals(a: NameAndId | PlainMessage<NameAndId> | undefined, b: NameAndId | PlainMessage<NameAndId> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.FindFieldUsagesRes
 */
export declare class FindFieldUsagesRes extends Message<FindFieldUsagesRes> {
  /**
   * @generated from field: string field_name = 1;
   */
  fieldName: string;

  /**
   * contains the name, and id of all the file templates that use field_name.
   *
   * @generated from field: repeated api.v0alpha.NameAndId file_templates = 2;
   */
  fileTemplates: NameAndId[];

  /**
   * contains the name, and id of all the elements that use field_name
   *
   * @generated from field: repeated api.v0alpha.NameAndId elements = 3;
   */
  elements: NameAndId[];

  constructor(data?: PartialMessage<FindFieldUsagesRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.FindFieldUsagesRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindFieldUsagesRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindFieldUsagesRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FindFieldUsagesRes;

  static equals(a: FindFieldUsagesRes | PlainMessage<FindFieldUsagesRes> | undefined, b: FindFieldUsagesRes | PlainMessage<FindFieldUsagesRes> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ElementError
 */
export declare class ElementError extends Message<ElementError> {
  /**
   * an ElementError contains a "reason" the element is invalid that is one of the above types
   *
   * @generated from oneof api.v0alpha.ElementError.reason
   */
  reason: {
    /**
     * @generated from field: api.v0alpha.ElementError.InvalidExpression invalid_expression = 4;
     */
    value: ElementError_InvalidExpression;
    case: "invalidExpression";
  } | {
    /**
     * @generated from field: api.v0alpha.ElementError.MissingField missing_field = 5;
     */
    value: ElementError_MissingField;
    case: "missingField";
  } | {
    /**
     * @generated from field: api.v0alpha.ElementError.BadFieldType bad_field_type = 6;
     */
    value: ElementError_BadFieldType;
    case: "badFieldType";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<ElementError>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ElementError";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ElementError;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ElementError;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ElementError;

  static equals(a: ElementError | PlainMessage<ElementError> | undefined, b: ElementError | PlainMessage<ElementError> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ElementError.InvalidExpression
 */
export declare class ElementError_InvalidExpression extends Message<ElementError_InvalidExpression> {
  /**
   * @generated from field: string expression = 1;
   */
  expression: string;

  constructor(data?: PartialMessage<ElementError_InvalidExpression>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ElementError.InvalidExpression";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ElementError_InvalidExpression;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ElementError_InvalidExpression;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ElementError_InvalidExpression;

  static equals(a: ElementError_InvalidExpression | PlainMessage<ElementError_InvalidExpression> | undefined, b: ElementError_InvalidExpression | PlainMessage<ElementError_InvalidExpression> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ElementError.MissingField
 */
export declare class ElementError_MissingField extends Message<ElementError_MissingField> {
  /**
   * @generated from field: string field_name = 2;
   */
  fieldName: string;

  constructor(data?: PartialMessage<ElementError_MissingField>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ElementError.MissingField";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ElementError_MissingField;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ElementError_MissingField;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ElementError_MissingField;

  static equals(a: ElementError_MissingField | PlainMessage<ElementError_MissingField> | undefined, b: ElementError_MissingField | PlainMessage<ElementError_MissingField> | undefined): boolean;
}

/**
 * this element is doing an operation that will always fail.
 * Examples:
 *   - Enrichment with fields that are not phone or zip type
 *   - reshape Add/Subtract functions on non number types
 *   - Filter using datetime math with non datetime fields
 * this will be possible to determine all cases after https://git.tcncloud.net/m/neo/-/issues/6924
 *
 * @generated from message api.v0alpha.ElementError.BadFieldType
 */
export declare class ElementError_BadFieldType extends Message<ElementError_BadFieldType> {
  /**
   * @generated from field: string field_name = 3;
   */
  fieldName: string;

  constructor(data?: PartialMessage<ElementError_BadFieldType>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ElementError.BadFieldType";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ElementError_BadFieldType;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ElementError_BadFieldType;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ElementError_BadFieldType;

  static equals(a: ElementError_BadFieldType | PlainMessage<ElementError_BadFieldType> | undefined, b: ElementError_BadFieldType | PlainMessage<ElementError_BadFieldType> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ElementSummary
 */
export declare class ElementSummary extends Message<ElementSummary> {
  /**
   * @generated from field: string element_id = 1;
   */
  elementId: string;

  /**
   * @generated from field: string element_name = 2;
   */
  elementName: string;

  /**
   * @generated from field: api.v0alpha.ElementError error = 3;
   */
  error?: ElementError;

  constructor(data?: PartialMessage<ElementSummary>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ElementSummary";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ElementSummary;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ElementSummary;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ElementSummary;

  static equals(a: ElementSummary | PlainMessage<ElementSummary> | undefined, b: ElementSummary | PlainMessage<ElementSummary> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.FindInvalidElementsReq
 */
export declare class FindInvalidElementsReq extends Message<FindInvalidElementsReq> {
  /**
   * @generated from field: string org_id = 1;
   */
  orgId: string;

  /**
   * @generated from field: string region_id = 2;
   */
  regionId: string;

  constructor(data?: PartialMessage<FindInvalidElementsReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.FindInvalidElementsReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindInvalidElementsReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindInvalidElementsReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FindInvalidElementsReq;

  static equals(a: FindInvalidElementsReq | PlainMessage<FindInvalidElementsReq> | undefined, b: FindInvalidElementsReq | PlainMessage<FindInvalidElementsReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.FindInvalidElementsRes
 */
export declare class FindInvalidElementsRes extends Message<FindInvalidElementsRes> {
  /**
   * @generated from field: repeated api.v0alpha.ElementSummary invalid_elements = 1;
   */
  invalidElements: ElementSummary[];

  constructor(data?: PartialMessage<FindInvalidElementsRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.FindInvalidElementsRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindInvalidElementsRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindInvalidElementsRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FindInvalidElementsRes;

  static equals(a: FindInvalidElementsRes | PlainMessage<FindInvalidElementsRes> | undefined, b: FindInvalidElementsRes | PlainMessage<FindInvalidElementsRes> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.GetComplianceScrubListsReq
 */
export declare class GetComplianceScrubListsReq extends Message<GetComplianceScrubListsReq> {
  constructor(data?: PartialMessage<GetComplianceScrubListsReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.GetComplianceScrubListsReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetComplianceScrubListsReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetComplianceScrubListsReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetComplianceScrubListsReq;

  static equals(a: GetComplianceScrubListsReq | PlainMessage<GetComplianceScrubListsReq> | undefined, b: GetComplianceScrubListsReq | PlainMessage<GetComplianceScrubListsReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.GetComplianceScrubListsRes
 */
export declare class GetComplianceScrubListsRes extends Message<GetComplianceScrubListsRes> {
  /**
   * @generated from field: repeated string scrub_lists = 1;
   */
  scrubLists: string[];

  constructor(data?: PartialMessage<GetComplianceScrubListsRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.GetComplianceScrubListsRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetComplianceScrubListsRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetComplianceScrubListsRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetComplianceScrubListsRes;

  static equals(a: GetComplianceScrubListsRes | PlainMessage<GetComplianceScrubListsRes> | undefined, b: GetComplianceScrubListsRes | PlainMessage<GetComplianceScrubListsRes> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ProcessElementReq
 */
export declare class ProcessElementReq extends Message<ProcessElementReq> {
  /**
   * @generated from field: string element_id = 1;
   */
  elementId: string;

  /**
   * says if it was triggered by a cron or manually
   *
   * @generated from field: string process_message = 2;
   */
  processMessage: string;

  constructor(data?: PartialMessage<ProcessElementReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ProcessElementReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProcessElementReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProcessElementReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProcessElementReq;

  static equals(a: ProcessElementReq | PlainMessage<ProcessElementReq> | undefined, b: ProcessElementReq | PlainMessage<ProcessElementReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ListAvailableFieldsByElementIdReq
 */
export declare class ListAvailableFieldsByElementIdReq extends Message<ListAvailableFieldsByElementIdReq> {
  /**
   * @generated from field: string element_id = 1;
   */
  elementId: string;

  constructor(data?: PartialMessage<ListAvailableFieldsByElementIdReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ListAvailableFieldsByElementIdReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAvailableFieldsByElementIdReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAvailableFieldsByElementIdReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAvailableFieldsByElementIdReq;

  static equals(a: ListAvailableFieldsByElementIdReq | PlainMessage<ListAvailableFieldsByElementIdReq> | undefined, b: ListAvailableFieldsByElementIdReq | PlainMessage<ListAvailableFieldsByElementIdReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ListFieldsForElementReq
 */
export declare class ListFieldsForElementReq extends Message<ListFieldsForElementReq> {
  /**
   * @generated from field: string element_id = 1;
   */
  elementId: string;

  constructor(data?: PartialMessage<ListFieldsForElementReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ListFieldsForElementReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListFieldsForElementReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListFieldsForElementReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListFieldsForElementReq;

  static equals(a: ListFieldsForElementReq | PlainMessage<ListFieldsForElementReq> | undefined, b: ListFieldsForElementReq | PlainMessage<ListFieldsForElementReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ListFieldsForElementRes
 */
export declare class ListFieldsForElementRes extends Message<ListFieldsForElementRes> {
  /**
   * @generated from field: repeated api.v0alpha.Field fields = 1;
   */
  fields: Field[];

  constructor(data?: PartialMessage<ListFieldsForElementRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ListFieldsForElementRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListFieldsForElementRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListFieldsForElementRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListFieldsForElementRes;

  static equals(a: ListFieldsForElementRes | PlainMessage<ListFieldsForElementRes> | undefined, b: ListFieldsForElementRes | PlainMessage<ListFieldsForElementRes> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ListAutocompleteFieldsReq
 */
export declare class ListAutocompleteFieldsReq extends Message<ListAutocompleteFieldsReq> {
  constructor(data?: PartialMessage<ListAutocompleteFieldsReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ListAutocompleteFieldsReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAutocompleteFieldsReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAutocompleteFieldsReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAutocompleteFieldsReq;

  static equals(a: ListAutocompleteFieldsReq | PlainMessage<ListAutocompleteFieldsReq> | undefined, b: ListAutocompleteFieldsReq | PlainMessage<ListAutocompleteFieldsReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ListAutocompleteFieldsRes
 */
export declare class ListAutocompleteFieldsRes extends Message<ListAutocompleteFieldsRes> {
  /**
   * @generated from field: repeated api.v0alpha.Field fields = 1;
   */
  fields: Field[];

  constructor(data?: PartialMessage<ListAutocompleteFieldsRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ListAutocompleteFieldsRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAutocompleteFieldsRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAutocompleteFieldsRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAutocompleteFieldsRes;

  static equals(a: ListAutocompleteFieldsRes | PlainMessage<ListAutocompleteFieldsRes> | undefined, b: ListAutocompleteFieldsRes | PlainMessage<ListAutocompleteFieldsRes> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ElementPK
 */
export declare class ElementPK extends Message<ElementPK> {
  /**
   * @generated from field: string element_id = 1;
   */
  elementId: string;

  constructor(data?: PartialMessage<ElementPK>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ElementPK";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ElementPK;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ElementPK;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ElementPK;

  static equals(a: ElementPK | PlainMessage<ElementPK> | undefined, b: ElementPK | PlainMessage<ElementPK> | undefined): boolean;
}

/**
 * REPLACES PipelineElement and List
 *
 * @generated from message api.v0alpha.Element
 */
export declare class Element extends Message<Element> {
  /**
   * @generated from field: string element_id = 3;
   */
  elementId: string;

  /**
   * @generated from field: string name = 10;
   */
  name: string;

  /**
   * @generated from field: repeated string inputs = 11;
   */
  inputs: string[];

  /**
   * @generated from field: repeated bool input_is_discard = 20;
   */
  inputIsDiscard: boolean[];

  /**
   * @generated from field: api.v0alpha.Process transform = 13;
   */
  transform?: Process;

  /**
   * @generated from field: api.commons.PipelineElementStatusType last_status = 14;
   */
  lastStatus: PipelineElementStatusType;

  /**
   * @generated from field: repeated string labels = 16;
   */
  labels: string[];

  /**
   * @generated from field: google.protobuf.Timestamp created_date = 17;
   */
  createdDate?: Timestamp$1;

  /**
   * @generated from field: google.protobuf.Timestamp last_edited = 18;
   */
  lastEdited?: Timestamp$1;

  /**
   * @generated from field: string description = 19;
   */
  description: string;

  constructor(data?: PartialMessage<Element>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.Element";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Element;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Element;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Element;

  static equals(a: Element | PlainMessage<Element> | undefined, b: Element | PlainMessage<Element> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.PeekListReq
 */
export declare class PeekListReq extends Message<PeekListReq> {
  /**
   * @generated from field: string element_id = 3;
   */
  elementId: string;

  /**
   * @generated from field: int64 version = 4;
   */
  version: bigint;

  /**
   * @generated from field: int32 page_size = 10;
   */
  pageSize: number;

  /**
   * @generated from field: int32 page = 12;
   */
  page: number;

  /**
   * process to run before we return the records back
   * currently only expecting this to be a simple filter process
   *
   * @generated from field: api.v0alpha.Process process = 13;
   */
  process?: Process;

  /**
   * if true, we will fetch the discards chunk to look at instead of the data chunk
   *
   * @generated from field: bool peek_at_discards = 14;
   */
  peekAtDiscards: boolean;

  constructor(data?: PartialMessage<PeekListReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.PeekListReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PeekListReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PeekListReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PeekListReq;

  static equals(a: PeekListReq | PlainMessage<PeekListReq> | undefined, b: PeekListReq | PlainMessage<PeekListReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.PeekListRes
 */
export declare class PeekListRes extends Message<PeekListRes> {
  /**
   * @generated from field: repeated api.v0alpha.RecordProto records = 1;
   */
  records: RecordProto[];

  /**
   * @generated from field: api.v0alpha.ListMetrics metrics = 2;
   */
  metrics?: ListMetrics;

  constructor(data?: PartialMessage<PeekListRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.PeekListRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PeekListRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PeekListRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PeekListRes;

  static equals(a: PeekListRes | PlainMessage<PeekListRes> | undefined, b: PeekListRes | PlainMessage<PeekListRes> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.GetHistoryReq
 */
export declare class GetHistoryReq extends Message<GetHistoryReq> {
  /**
   * @generated from field: string element_id = 3;
   */
  elementId: string;

  /**
   * @generated from field: int32 count = 10;
   */
  count: number;

  /**
   * @generated from field: int64 starting_id = 11;
   */
  startingId: bigint;

  constructor(data?: PartialMessage<GetHistoryReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.GetHistoryReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetHistoryReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetHistoryReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetHistoryReq;

  static equals(a: GetHistoryReq | PlainMessage<GetHistoryReq> | undefined, b: GetHistoryReq | PlainMessage<GetHistoryReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.GetHistoryRes
 */
export declare class GetHistoryRes extends Message<GetHistoryRes> {
  /**
   * @generated from field: string element_id = 3;
   */
  elementId: string;

  /**
   * @generated from field: repeated api.v0alpha.HistoryAndCount commits = 11;
   */
  commits: HistoryAndCount[];

  constructor(data?: PartialMessage<GetHistoryRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.GetHistoryRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetHistoryRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetHistoryRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetHistoryRes;

  static equals(a: GetHistoryRes | PlainMessage<GetHistoryRes> | undefined, b: GetHistoryRes | PlainMessage<GetHistoryRes> | undefined): boolean;
}

/**
 * the history table stores history for pipeline_elements
 *
 * @generated from message api.v0alpha.History
 */
export declare class History extends Message<History> {
  /**
   * @generated from field: string element_id = 3;
   */
  elementId: string;

  /**
   * @generated from field: int64 history_id = 4;
   */
  historyId: bigint;

  /**
   * @generated from field: api.v0alpha.Process process = 7;
   */
  process?: Process;

  /**
   * whether the pipeline process was successful, or a failure.  Success = false
   *
   * @generated from field: bool failed = 10;
   */
  failed: boolean;

  /**
   * @generated from field: int32 attempt_number = 12;
   */
  attemptNumber: number;

  /**
   * @generated from field: google.protobuf.StringValue reason = 13;
   */
  reason?: string;

  /**
   * @generated from field: google.protobuf.Timestamp upload_ts = 14;
   */
  uploadTs?: Timestamp$1;

  /**
   * @generated from field: google.protobuf.Timestamp started_ts = 15;
   */
  startedTs?: Timestamp$1;

  /**
   * @generated from field: google.protobuf.Timestamp finished_ts = 16;
   */
  finishedTs?: Timestamp$1;

  /**
   * will only match a valid event in the event queue as long as it isn't
   * emptied
   *
   * @generated from field: int64 event_id = 18;
   */
  eventId: bigint;

  /**
   * @generated from field: string parent_element_id = 22;
   */
  parentElementId: string;

  /**
   * @generated from field: api.v0alpha.ListMetrics metrics = 23;
   */
  metrics?: ListMetrics;

  /**
   * @generated from field: api.v0alpha.ListMetrics discard_metrics = 24;
   */
  discardMetrics?: ListMetrics;

  constructor(data?: PartialMessage<History>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.History";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): History;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): History;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): History;

  static equals(a: History | PlainMessage<History> | undefined, b: History | PlainMessage<History> | undefined): boolean;
}

/**
 * since its possible to get a load of history events that all look the same
 * this keeps track of the range. history_id and ending_history_id
 * are the range of data where 'failed', and 'reason' were the same.
 * The rest of the fields point to the history_id's record
 * 'count' is the field that keeps track of how many messages in a row were
 * similar
 *
 * @generated from message api.v0alpha.HistoryAndCount
 */
export declare class HistoryAndCount extends Message<HistoryAndCount> {
  /**
   * @generated from field: string element_id = 3;
   */
  elementId: string;

  /**
   * history_id of the element that started getting the duplicate error message
   *
   * @generated from field: int64 history_id = 4;
   */
  historyId: bigint;

  /**
   * history_id of where we stopped getting the duplicate error message
   *
   * @generated from field: int64 ending_history_id = 5;
   */
  endingHistoryId: bigint;

  /**
   * @generated from field: api.v0alpha.Process process = 7;
   */
  process?: Process;

  /**
   * whether the pipeline process was successful, or a failure.  Success = false
   *
   * @generated from field: bool failed = 10;
   */
  failed: boolean;

  /**
   * @generated from field: int32 attempt_number = 12;
   */
  attemptNumber: number;

  /**
   * @generated from field: google.protobuf.StringValue reason = 13;
   */
  reason?: string;

  /**
   * @generated from field: google.protobuf.Timestamp upload_ts = 14;
   */
  uploadTs?: Timestamp$1;

  /**
   * @generated from field: google.protobuf.Timestamp started_ts = 15;
   */
  startedTs?: Timestamp$1;

  /**
   * @generated from field: google.protobuf.Timestamp finished_ts = 16;
   */
  finishedTs?: Timestamp$1;

  /**
   * will only match a valid event in the event queue as long as it isn't
   * emptied
   *
   * @generated from field: int64 event_id = 18;
   */
  eventId: bigint;

  /**
   * @generated from field: string parent_element_id = 22;
   */
  parentElementId: string;

  /**
   * @generated from field: api.v0alpha.ListMetrics metrics = 23;
   */
  metrics?: ListMetrics;

  /**
   * @generated from field: api.v0alpha.ListMetrics discard_metrics = 25;
   */
  discardMetrics?: ListMetrics;

  /**
   * how many messages encountered a similar 'reason' field
   *
   * @generated from field: int64 count = 24;
   */
  count: bigint;

  constructor(data?: PartialMessage<HistoryAndCount>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.HistoryAndCount";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HistoryAndCount;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HistoryAndCount;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HistoryAndCount;

  static equals(a: HistoryAndCount | PlainMessage<HistoryAndCount> | undefined, b: HistoryAndCount | PlainMessage<HistoryAndCount> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.RecordProto
 */
export declare class RecordProto extends Message<RecordProto> {
  /**
   * @generated from field: repeated api.v0alpha.RecordFieldProto fields = 1;
   */
  fields: RecordFieldProto[];

  constructor(data?: PartialMessage<RecordProto>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.RecordProto";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordProto;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordProto;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordProto;

  static equals(a: RecordProto | PlainMessage<RecordProto> | undefined, b: RecordProto | PlainMessage<RecordProto> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.RecordProtoPair
 */
export declare class RecordProtoPair extends Message<RecordProtoPair> {
  /**
   * @generated from field: api.v0alpha.RecordProto old = 1;
   */
  old?: RecordProto;

  /**
   * @generated from field: api.v0alpha.RecordProto new = 2;
   */
  new?: RecordProto;

  constructor(data?: PartialMessage<RecordProtoPair>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.RecordProtoPair";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordProtoPair;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordProtoPair;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordProtoPair;

  static equals(a: RecordProtoPair | PlainMessage<RecordProtoPair> | undefined, b: RecordProtoPair | PlainMessage<RecordProtoPair> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ProcessFields
 */
export declare class ProcessFields extends Message<ProcessFields> {
  /**
   * @generated from field: repeated api.v0alpha.ProcessFields.Field fields = 8;
   */
  fields: ProcessFields_Field[];

  constructor(data?: PartialMessage<ProcessFields>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ProcessFields";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProcessFields;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProcessFields;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProcessFields;

  static equals(a: ProcessFields | PlainMessage<ProcessFields> | undefined, b: ProcessFields | PlainMessage<ProcessFields> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ProcessFields.NestedField
 */
export declare class ProcessFields_NestedField extends Message<ProcessFields_NestedField> {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: api.commons.RecordType field_type = 2;
   */
  fieldType: RecordType;

  constructor(data?: PartialMessage<ProcessFields_NestedField>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ProcessFields.NestedField";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProcessFields_NestedField;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProcessFields_NestedField;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProcessFields_NestedField;

  static equals(a: ProcessFields_NestedField | PlainMessage<ProcessFields_NestedField> | undefined, b: ProcessFields_NestedField | PlainMessage<ProcessFields_NestedField> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ProcessFields.Field
 */
export declare class ProcessFields_Field extends Message<ProcessFields_Field> {
  /**
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * @generated from field: api.commons.RecordType field_type = 4;
   */
  fieldType: RecordType;

  /**
   * any nested fields, could be empty
   *
   * @generated from field: repeated api.v0alpha.ProcessFields.NestedField nested = 5;
   */
  nested: ProcessFields_NestedField[];

  /**
   * @generated from field: string format = 9;
   */
  format: string;

  constructor(data?: PartialMessage<ProcessFields_Field>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ProcessFields.Field";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProcessFields_Field;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProcessFields_Field;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProcessFields_Field;

  static equals(a: ProcessFields_Field | PlainMessage<ProcessFields_Field> | undefined, b: ProcessFields_Field | PlainMessage<ProcessFields_Field> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.FieldPK
 */
export declare class FieldPK extends Message<FieldPK> {
  /**
   * @generated from field: string name = 3;
   */
  name: string;

  constructor(data?: PartialMessage<FieldPK>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.FieldPK";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldPK;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldPK;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldPK;

  static equals(a: FieldPK | PlainMessage<FieldPK> | undefined, b: FieldPK | PlainMessage<FieldPK> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.Field
 */
export declare class Field extends Message<Field> {
  /**
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * @generated from field: api.commons.FieldType type = 4;
   */
  type: FieldType;

  /**
   * @generated from field: google.protobuf.Timestamp date_modified = 5;
   */
  dateModified?: Timestamp$1;

  /**
   * @generated from field: api.v0alpha.FieldMetadata metadata = 10;
   */
  metadata?: FieldMetadata;

  /**
   * @generated from field: string description = 11;
   */
  description: string;

  constructor(data?: PartialMessage<Field>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.Field";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Field;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Field;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Field;

  static equals(a: Field | PlainMessage<Field> | undefined, b: Field | PlainMessage<Field> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.UpdateFieldReq
 */
export declare class UpdateFieldReq extends Message<UpdateFieldReq> {
  /**
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * @generated from field: api.commons.FieldType type = 4;
   */
  type: FieldType;

  /**
   * @generated from field: google.protobuf.Timestamp date_modified = 5;
   */
  dateModified?: Timestamp$1;

  /**
   * @generated from field: string new_name = 6;
   */
  newName: string;

  /**
   * @generated from field: api.v0alpha.FieldMetadata metadata = 10;
   */
  metadata?: FieldMetadata;

  /**
   * @generated from field: string description = 11;
   */
  description: string;

  constructor(data?: PartialMessage<UpdateFieldReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.UpdateFieldReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateFieldReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateFieldReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateFieldReq;

  static equals(a: UpdateFieldReq | PlainMessage<UpdateFieldReq> | undefined, b: UpdateFieldReq | PlainMessage<UpdateFieldReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.FieldMetadata
 */
export declare class FieldMetadata extends Message<FieldMetadata> {
  /**
   * @generated from field: string time_format = 1;
   */
  timeFormat: string;

  /**
   * @generated from field: api.commons.DateTimePrecision precision = 2;
   */
  precision: DateTimePrecision;

  /**
   * 3-10 are Parsing Options
   * Remove any characters that are in this string
   * `remove_characters` will override leave_characters
   *
   * @generated from field: string remove_characters = 3;
   */
  removeCharacters: string;

  /**
   * If the parsed value is empty
   * it will be replaced with this value
   *
   * @generated from field: string replace_empty = 4;
   */
  replaceEmpty: string;

  /**
   * If an error is encountered with parsing
   * then the field will be replaced with this value
   *
   * @generated from field: string replace_error = 5;
   */
  replaceError: string;

  /**
   * Remove any letters (a-zA-Z) from the field
   *
   * @generated from field: bool remove_letters = 6;
   */
  removeLetters: boolean;

  /**
   * Remove any numbers (digits 0-9) from the field
   *
   * @generated from field: bool remove_numbers = 7;
   */
  removeNumbers: boolean;

  /**
   * Removes any symbols or punctuation from the field
   *
   * @generated from field: bool remove_symbols = 8;
   */
  removeSymbols: boolean;

  /**
   * Any characters in this string will not be remove
   * can be overridden by remove_characters
   *
   * @generated from field: string leave_characters = 9;
   */
  leaveCharacters: string;

  /**
   * Remove any matches of this entire string
   *
   * following fields are for json file format types:
   * represents a field that can be fetched from a json payload
   * the type will match whatever is at the end of the 'json_dot_path' field
   * when we use the 'json_dot_path' to retrieve from a json payload.
   * so to get a primitive type (string, number, bool), you must have that value at the end of the dot_path
   * null is treated as empty string.
   * In the case of complex types, we are expecting
   * a json object with names and types that match one of our payloads
   * ie: postal code would be {postalCode: "84790"}
   * 'json_force_type_match' can be set to force the results to be a type, or error.
   * In this case, the result value needs to either be the matching type, or a string, where it will be parsed.
   *
   * @generated from field: string remove_string = 10;
   */
  removeString: string;

  /**
   * 'json_dot_path' holds the json path that will fetch the  value for this field by walking path
   * over a json object via:
   * https://github.com/tidwall/gjson
   * ex: dot_path = a.b.0.firstName
   * Values must resolve to one thing, not a range of things. If a range is retrieved, the first value is taken
   * the rest are ignored.
   * If string is empty, we just use the field name for the path
   *
   * @generated from field: string json_dot_path = 11;
   */
  jsonDotPath: string;

  /**
   * If true value retrieved from json *must* match the field definition, or error.
   * If true, the value if a string, will be 'parsed' into the correct type.
   * If false, the value will be used as is, meaning time_strings, number_strings and the like will remain as strings.
   *
   * @generated from field: bool json_force_type_match = 12;
   */
  jsonForceTypeMatch: boolean;

  /**
   * for fixed width files indicates the starting position of the data.
   * if it is -1, starting position is one character after the previous fields starting position + length.
   * if this is the first field and it is -1, starting position is 0
   *
   * @generated from field: int32 starting_position = 13;
   */
  startingPosition: number;

  /**
   * for fixed width files indicates how many characters to the right of starting position we will read.
   * this field is required to be greater than 0.
   *
   * @generated from field: int32 field_length = 14;
   */
  fieldLength: number;

  constructor(data?: PartialMessage<FieldMetadata>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.FieldMetadata";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldMetadata;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldMetadata;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldMetadata;

  static equals(a: FieldMetadata | PlainMessage<FieldMetadata> | undefined, b: FieldMetadata | PlainMessage<FieldMetadata> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.Fields
 */
export declare class Fields extends Message<Fields> {
  /**
   * @generated from field: repeated api.v0alpha.Field fields = 1;
   */
  fields: Field[];

  constructor(data?: PartialMessage<Fields>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.Fields";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fields;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fields;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fields;

  static equals(a: Fields | PlainMessage<Fields> | undefined, b: Fields | PlainMessage<Fields> | undefined): boolean;
}

/**
 * first value is the field_name in the record.
 * additional values are nested fields on record field looked up from index[0]
 *
 * @generated from message api.v0alpha.FieldIndex
 */
export declare class FieldIndex extends Message<FieldIndex> {
  /**
   * @generated from field: repeated string index = 1;
   */
  index: string[];

  /**
   * modify the fetched field, if the fetched field's type
   * can support the modifier
   *
   * @generated from oneof api.v0alpha.FieldIndex.modifier
   */
  modifier: {
    /**
     * modifies the fetched field if it is a datetime field
     *
     * @generated from field: api.v0alpha.DateTimeModifier datetime = 2;
     */
    value: DateTimeModifier;
    case: "datetime";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<FieldIndex>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.FieldIndex";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldIndex;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldIndex;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldIndex;

  static equals(a: FieldIndex | PlainMessage<FieldIndex> | undefined, b: FieldIndex | PlainMessage<FieldIndex> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ListFieldsReq
 */
export declare class ListFieldsReq extends Message<ListFieldsReq> {
  constructor(data?: PartialMessage<ListFieldsReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ListFieldsReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListFieldsReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListFieldsReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListFieldsReq;

  static equals(a: ListFieldsReq | PlainMessage<ListFieldsReq> | undefined, b: ListFieldsReq | PlainMessage<ListFieldsReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.RecordFieldProto
 */
export declare class RecordFieldProto extends Message<RecordFieldProto> {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from oneof api.v0alpha.RecordFieldProto.payload
   */
  payload: {
    /**
     * @generated from field: string string_value = 2;
     */
    value: string;
    case: "stringValue";
  } | {
    /**
     * @generated from field: double number_value = 3;
     */
    value: number;
    case: "numberValue";
  } | {
    /**
     * @generated from field: bool bool_value = 4;
     */
    value: boolean;
    case: "boolValue";
  } | {
    /**
     * @generated from field: api.v0alpha.Phone phone = 5;
     */
    value: Phone;
    case: "phone";
  } | {
    /**
     * @generated from field: api.v0alpha.Currency currency = 6;
     */
    value: Currency;
    case: "currency";
  } | {
    /**
     * @generated from field: api.v0alpha.PostalCode postal_code = 8;
     */
    value: PostalCode;
    case: "postalCode";
  } | {
    /**
     * @generated from field: api.v0alpha.Email email = 9;
     */
    value: Email;
    case: "email";
  } | {
    /**
     * @generated from field: api.v0alpha.DateTime date_time = 10;
     */
    value: DateTime;
    case: "dateTime";
  } | {
    /**
     * @generated from field: api.v0alpha.RepeatedRecords repeated_records = 13;
     */
    value: RepeatedRecords;
    case: "repeatedRecords";
  } | {
    /**
     * @generated from field: api.v0alpha.RecordFieldMap record_field_map = 14;
     */
    value: RecordFieldMap;
    case: "recordFieldMap";
  } | {
    /**
     * @generated from field: api.v0alpha.Error err = 15;
     */
    value: Error;
    case: "err";
  } | {
    /**
     * @generated from field: api.v0alpha.EnrichedPhone enriched_phone = 16;
     */
    value: EnrichedPhone;
    case: "enrichedPhone";
  } | {
    /**
     * @generated from field: api.v0alpha.EnrichedZip enriched_zip = 17;
     */
    value: EnrichedZip;
    case: "enrichedZip";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<RecordFieldProto>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.RecordFieldProto";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordFieldProto;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordFieldProto;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordFieldProto;

  static equals(a: RecordFieldProto | PlainMessage<RecordFieldProto> | undefined, b: RecordFieldProto | PlainMessage<RecordFieldProto> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.RepeatedRecords
 */
export declare class RepeatedRecords extends Message<RepeatedRecords> {
  /**
   * @generated from field: repeated api.v0alpha.RecordProto records = 1;
   */
  records: RecordProto[];

  constructor(data?: PartialMessage<RepeatedRecords>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.RepeatedRecords";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedRecords;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedRecords;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedRecords;

  static equals(a: RepeatedRecords | PlainMessage<RepeatedRecords> | undefined, b: RepeatedRecords | PlainMessage<RepeatedRecords> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ListElementsReq
 */
export declare class ListElementsReq extends Message<ListElementsReq> {
  /**
   * @generated from field: repeated string labels = 1;
   */
  labels: string[];

  constructor(data?: PartialMessage<ListElementsReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ListElementsReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListElementsReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListElementsReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListElementsReq;

  static equals(a: ListElementsReq | PlainMessage<ListElementsReq> | undefined, b: ListElementsReq | PlainMessage<ListElementsReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.GetFileTemplatesReq
 */
export declare class GetFileTemplatesReq extends Message<GetFileTemplatesReq> {
  constructor(data?: PartialMessage<GetFileTemplatesReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.GetFileTemplatesReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetFileTemplatesReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetFileTemplatesReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetFileTemplatesReq;

  static equals(a: GetFileTemplatesReq | PlainMessage<GetFileTemplatesReq> | undefined, b: GetFileTemplatesReq | PlainMessage<GetFileTemplatesReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.FileTemplateField
 */
export declare class FileTemplateField extends Message<FileTemplateField> {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: api.commons.FieldType type = 2;
   */
  type: FieldType;

  constructor(data?: PartialMessage<FileTemplateField>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.FileTemplateField";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FileTemplateField;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FileTemplateField;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FileTemplateField;

  static equals(a: FileTemplateField | PlainMessage<FileTemplateField> | undefined, b: FileTemplateField | PlainMessage<FileTemplateField> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.FileTemplateFields
 */
export declare class FileTemplateFields extends Message<FileTemplateFields> {
  /**
   * @generated from field: repeated api.v0alpha.FileTemplateField fields = 1;
   */
  fields: FileTemplateField[];

  constructor(data?: PartialMessage<FileTemplateFields>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.FileTemplateFields";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FileTemplateFields;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FileTemplateFields;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FileTemplateFields;

  static equals(a: FileTemplateFields | PlainMessage<FileTemplateFields> | undefined, b: FileTemplateFields | PlainMessage<FileTemplateFields> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.FieldTypes
 */
export declare class FieldTypes extends Message<FieldTypes> {
  /**
   * @generated from field: repeated api.commons.FieldType values = 1;
   */
  values: FieldType[];

  constructor(data?: PartialMessage<FieldTypes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.FieldTypes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldTypes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldTypes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldTypes;

  static equals(a: FieldTypes | PlainMessage<FieldTypes> | undefined, b: FieldTypes | PlainMessage<FieldTypes> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.FileTemplate
 */
export declare class FileTemplate extends Message<FileTemplate> {
  /**
   * @generated from field: string file_template_id = 3;
   */
  fileTemplateId: string;

  /**
   * @generated from field: string name = 10;
   */
  name: string;

  /**
   * @generated from field: string description = 11;
   */
  description: string;

  /**
   * @generated from field: repeated string field_names = 12;
   */
  fieldNames: string[];

  /**
   * @generated from field: api.v0alpha.FileFormatParams file_format_params = 14;
   */
  fileFormatParams?: FileFormatParams;

  /**
   * @generated from field: api.commons.FileFormat file_format = 15;
   */
  fileFormat: FileFormat;

  /**
   * @generated from field: repeated api.v0alpha.Field fields = 16;
   */
  fields: Field[];

  constructor(data?: PartialMessage<FileTemplate>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.FileTemplate";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FileTemplate;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FileTemplate;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FileTemplate;

  static equals(a: FileTemplate | PlainMessage<FileTemplate> | undefined, b: FileTemplate | PlainMessage<FileTemplate> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.LMSUploadReq
 */
export declare class LMSUploadReq extends Message<LMSUploadReq> {
  /**
   * @generated from field: string element_id = 3;
   */
  elementId: string;

  /**
   * if left empty, will use the list_id's default file template
   *
   * @generated from field: string file_id = 12;
   */
  fileId: string;

  constructor(data?: PartialMessage<LMSUploadReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.LMSUploadReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LMSUploadReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LMSUploadReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LMSUploadReq;

  static equals(a: LMSUploadReq | PlainMessage<LMSUploadReq> | undefined, b: LMSUploadReq | PlainMessage<LMSUploadReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.LMSUploadRes
 */
export declare class LMSUploadRes extends Message<LMSUploadRes> {
  constructor(data?: PartialMessage<LMSUploadRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.LMSUploadRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LMSUploadRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LMSUploadRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LMSUploadRes;

  static equals(a: LMSUploadRes | PlainMessage<LMSUploadRes> | undefined, b: LMSUploadRes | PlainMessage<LMSUploadRes> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ReRunReq
 */
export declare class ReRunReq extends Message<ReRunReq> {
  /**
   * @generated from field: string list_id = 3;
   */
  listId: string;

  /**
   * @generated from field: string rerun_url = 4;
   */
  rerunUrl: string;

  constructor(data?: PartialMessage<ReRunReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReRunReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReRunReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReRunReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReRunReq;

  static equals(a: ReRunReq | PlainMessage<ReRunReq> | undefined, b: ReRunReq | PlainMessage<ReRunReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ReRunRes
 */
export declare class ReRunRes extends Message<ReRunRes> {
  constructor(data?: PartialMessage<ReRunRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReRunRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReRunRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReRunRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReRunRes;

  static equals(a: ReRunRes | PlainMessage<ReRunRes> | undefined, b: ReRunRes | PlainMessage<ReRunRes> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.Process
 */
export declare class Process extends Message<Process> {
  /**
   * @generated from field: string expression = 55;
   */
  expression: string;

  /**
   * @generated from oneof api.v0alpha.Process.proc
   */
  proc: {
    /**
     * @generated from field: api.v0alpha.AppendProcess append = 30;
     */
    value: AppendProcess;
    case: "append";
  } | {
    /**
     * @generated from field: api.v0alpha.SortCriteria sort = 31;
     */
    value: SortCriteria;
    case: "sort";
  } | {
    /**
     * @generated from field: api.v0alpha.FilterProcess filter = 32;
     */
    value: FilterProcess;
    case: "filter";
  } | {
    /**
     * @generated from field: api.v0alpha.GSExportProcess gs_export = 42;
     */
    value: GSExportProcess;
    case: "gsExport";
  } | {
    /**
     * @generated from field: api.v0alpha.P3ExportProcess p3_export = 44;
     */
    value: P3ExportProcess;
    case: "p3Export";
  } | {
    /**
     * USE LookupProcess
     *
     * @generated from field: api.v0alpha.ComplProcess compl = 45 [deprecated = true];
     * @deprecated
     */
    value: ComplProcess;
    case: "compl";
  } | {
    /**
     * @generated from field: api.v0alpha.DeDupCriteria dedup = 46;
     */
    value: DeDupCriteria;
    case: "dedup";
  } | {
    /**
     * @generated from field: api.v0alpha.CFSExportProcess cfs_export = 47;
     */
    value: CFSExportProcess;
    case: "cfsExport";
  } | {
    /**
     * @generated from field: api.v0alpha.SftpExportProcess sftp_export = 48;
     */
    value: SftpExportProcess;
    case: "sftpExport";
  } | {
    /**
     * @generated from field: api.v0alpha.ReshapeProcess reshape = 49;
     */
    value: ReshapeProcess;
    case: "reshape";
  } | {
    /**
     * @generated from field: api.v0alpha.LookupProcess lookup = 50;
     */
    value: LookupProcess;
    case: "lookup";
  } | {
    /**
     * split into ApiEntrypoint and SftpImport
     *
     * @generated from field: api.v0alpha.EntrypointProcess entrypoint = 51 [deprecated = true];
     * @deprecated
     */
    value: EntrypointProcess;
    case: "entrypoint";
  } | {
    /**
     * @generated from field: api.v0alpha.ComplianceExportProcess compliance_export = 52;
     */
    value: ComplianceExportProcess;
    case: "complianceExport";
  } | {
    /**
     * @generated from field: api.v0alpha.ApiEntrypoint api_entrypoint = 53;
     */
    value: ApiEntrypoint;
    case: "apiEntrypoint";
  } | {
    /**
     * @generated from field: api.v0alpha.SftpImport sftp_import = 54;
     */
    value: SftpImport;
    case: "sftpImport";
  } | {
    /**
     * @generated from field: api.v0alpha.ScrubProcess scrub = 56;
     */
    value: ScrubProcess;
    case: "scrub";
  } | {
    /**
     * @generated from field: api.v0alpha.FrequencyProcess frequency = 57;
     */
    value: FrequencyProcess;
    case: "frequency";
  } | {
    /**
     * Will import a list from Durable Data Service(CJS)
     * The templates for CJS and LMS will need to match
     *
     * @generated from field: api.v0alpha.CjsImportProcess cjs_import = 58;
     */
    value: CjsImportProcess;
    case: "cjsImport";
  } | {
    /**
     * Exports a list to Durable Data Service (CJS)
     * The exported fields will need to match the
     * CJS template if exporting to an existing list.
     *
     * @generated from field: api.v0alpha.CjsExportProcess cjs_export = 59;
     */
    value: CjsExportProcess;
    case: "cjsExport";
  } | {
    /**
     * Enriches an LMS list with
     * data from a CJS list
     *
     * @generated from field: api.v0alpha.CjsEnrichmentProcess cjs_enrich = 60;
     */
    value: CjsEnrichmentProcess;
    case: "cjsEnrich";
  } | {
    /**
     * @generated from field: api.v0alpha.WebEntrypointProcess web_entrypoint = 61;
     */
    value: WebEntrypointProcess;
    case: "webEntrypoint";
  } | {
    /**
     * @generated from field: api.v0alpha.DeleteScrubEntriesProcess delete_scrub_entries = 62;
     */
    value: DeleteScrubEntriesProcess;
    case: "deleteScrubEntries";
  } | {
    /**
     * @generated from field: api.v0alpha.WfmExportProcess wfm_export = 63;
     */
    value: WfmExportProcess;
    case: "wfmExport";
  } | {
    /**
     * @generated from field: api.v0alpha.PaymentLinkEnrichment link_enrich = 64 [deprecated = true];
     * @deprecated
     */
    value: PaymentLinkEnrichment;
    case: "linkEnrich";
  } | {
    /**
     * @generated from field: api.v0alpha.RndEnrichmentProcess rnd = 65;
     */
    value: RndEnrichmentProcess;
    case: "rnd";
  } | {
    /**
     * Enriches an LMS list with consent data
     *
     * @generated from field: api.v0alpha.ConsentEnrichmentProcess consent_enrich = 66;
     */
    value: ConsentEnrichmentProcess;
    case: "consentEnrich";
  } | {
    /**
     * Exchanges with compliance consent to add or delete consents
     *
     * @generated from field: api.v0alpha.ConsentExportProcess consent_export = 67;
     */
    value: ConsentExportProcess;
    case: "consentExport";
  } | {
    /**
     * Processes a list through compliance and enriching
     * whether a coule would have been permitted or not
     *
     * @generated from field: api.v0alpha.ComplianceProcessor compliance_processor = 69;
     */
    value: ComplianceProcessor;
    case: "complianceProcessor";
  } | {
    /**
     * @generated from field: api.v0alpha.ConsentEntrypointProcess consent_entrypoint = 70;
     */
    value: ConsentEntrypointProcess;
    case: "consentEntrypoint";
  } | {
    /**
     * @generated from field: api.v0alpha.PortalLinkEnrichment portal_link_enrich = 71;
     */
    value: PortalLinkEnrichment;
    case: "portalLinkEnrich";
  } | {
    /**
     * @generated from field: api.v0alpha.BulkWebEntrypointProcess bulk_web_entrypoint = 72;
     */
    value: BulkWebEntrypointProcess;
    case: "bulkWebEntrypoint";
  } | {
    /**
     * OmniExchangeProcess allows omni to import contacts using LMS file upload
     *
     * @generated from field: api.v0alpha.OmniExchangeProcess omni_exchange_process = 73;
     */
    value: OmniExchangeProcess;
    case: "omniExchangeProcess";
  } | {
    /**
     * WebExchangeProcess allows a user to setup a process to send data to an external api
     *
     * @generated from field: api.v0alpha.WebExchangeProcess web_exchange_process = 74;
     */
    value: WebExchangeProcess;
    case: "webExchangeProcess";
  } | {
    /**
     * @generated from field: api.v0alpha.SplitCriteria split = 75;
     */
    value: SplitCriteria;
    case: "split";
  } | {
    /**
     * @generated from field: api.v0alpha.EpicEntrypoint epic_entry_point = 76;
     */
    value: EpicEntrypoint;
    case: "epicEntryPoint";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Process>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.Process";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Process;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Process;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Process;

  static equals(a: Process | PlainMessage<Process> | undefined, b: Process | PlainMessage<Process> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ComplianceProcessor
 */
export declare class ComplianceProcessor extends Message<ComplianceProcessor> {
  /**
   * ID for the rulset to run against
   *
   * @generated from field: string rule_set_id = 1;
   */
  ruleSetId: string;

  /**
   * Comm type we are using (phone, email, sms)
   *
   * @generated from field: api.commons.CommType comm_type = 5;
   */
  commType?: CommType;

  /**
   * call type we are checking (inbound, outbound, preview, mac)
   * or field containing the call type
   *
   * @generated from field: string call_type = 6;
   */
  callType: string;

  /**
   * Field containing the phone number (optional)
   *
   * @generated from field: string phone_number_field = 7;
   */
  phoneNumberField: string;

  /**
   * Field containing the email (optional)
   *
   * @generated from field: string email_field = 8;
   */
  emailField: string;

  /**
   * Field containing the zip code
   *
   * @generated from field: string zip_code_field = 9;
   */
  zipCodeField: string;

  /**
   * The Key is the metadata field name
   * The value is the record field that
   * contains the value
   *
   * @generated from field: map<string, string> call_metadata = 10;
   */
  callMetadata: { [key: string]: string };

  /**
   * Country code, or field containing
   * the country code
   *
   * @generated from field: string country_code = 11;
   */
  countryCode: string;

  constructor(data?: PartialMessage<ComplianceProcessor>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ComplianceProcessor";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComplianceProcessor;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComplianceProcessor;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComplianceProcessor;

  static equals(a: ComplianceProcessor | PlainMessage<ComplianceProcessor> | undefined, b: ComplianceProcessor | PlainMessage<ComplianceProcessor> | undefined): boolean;
}

/**
 * sources the LMS list with consent records
 *
 * @generated from message api.v0alpha.ConsentEntrypointProcess
 */
export declare class ConsentEntrypointProcess extends Message<ConsentEntrypointProcess> {
  /**
   * Profile Id to get consent records from
   *
   * @generated from field: string consent_profile_id = 1;
   */
  consentProfileId: string;

  constructor(data?: PartialMessage<ConsentEntrypointProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ConsentEntrypointProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConsentEntrypointProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConsentEntrypointProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConsentEntrypointProcess;

  static equals(a: ConsentEntrypointProcess | PlainMessage<ConsentEntrypointProcess> | undefined, b: ConsentEntrypointProcess | PlainMessage<ConsentEntrypointProcess> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ConsentEnrichmentProcess
 */
export declare class ConsentEnrichmentProcess extends Message<ConsentEnrichmentProcess> {
  /**
   * Specifies which record field contains the content
   *
   * @generated from field: string content_field = 3;
   */
  contentField: string;

  /**
   * Profile to use
   *
   * @generated from field: string consent_profile = 4;
   */
  consentProfile: string;

  /**
   * Profile Id
   *
   * @generated from field: string consent_profile_id = 5;
   */
  consentProfileId: string;

  constructor(data?: PartialMessage<ConsentEnrichmentProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ConsentEnrichmentProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConsentEnrichmentProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConsentEnrichmentProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConsentEnrichmentProcess;

  static equals(a: ConsentEnrichmentProcess | PlainMessage<ConsentEnrichmentProcess> | undefined, b: ConsentEnrichmentProcess | PlainMessage<ConsentEnrichmentProcess> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ConsentExportProcess
 */
export declare class ConsentExportProcess extends Message<ConsentExportProcess> {
  /**
   * Specifies which record field is the content
   *
   * @generated from field: string content_field = 3;
   */
  contentField: string;

  /**
   * Profile to use
   *
   * @generated from field: string consent_profile = 4;
   */
  consentProfile: string;

  /**
   * Profile ID of profile to use
   *
   * Optional, only needed with phone/sms
   *
   * @generated from field: string consent_profile_id = 5;
   */
  consentProfileId: string;

  /**
   * Run as test, disabled, or normal
   *
   * @generated from field: api.commons.RunType run_type = 6;
   */
  runType: RunType;

  /**
   * Type of consent action to do: ADD/REVOKE
   *
   * @generated from field: api.commons.ConsentActionType action = 7;
   */
  action: ConsentActionType;

  /**
   * Field name or literal value for referring url when creating consent
   *
   * @generated from field: string referring_url = 8;
   */
  referringUrl: string;

  /**
   * Field name or literal value for topic when creating consent
   *
   * @generated from field: string topic = 9;
   */
  topic: string;

  /**
   * Field name or literal value for revoked reason when creating consent
   *
   * @generated from field: string revoked_reason = 10;
   */
  revokedReason: string;

  /**
   * Field name or literal value for granted reason when creating consent
   *
   * @generated from field: string granted_reason = 11;
   */
  grantedReason: string;

  /**
   * Field name or literal value for proof when creating consent
   *
   * @generated from field: string proof = 12;
   */
  proof: string;

  /**
   * Field name or literal value for "condition time of day from" when creating consent
   *
   * @generated from field: string condition_time_of_day_from = 13;
   */
  conditionTimeOfDayFrom: string;

  /**
   * Field name or literal value for "condition time of day to" when creating consent
   *
   * @generated from field: string condition_time_of_day_to = 14;
   */
  conditionTimeOfDayTo: string;

  /**
   * Field name or literal value for notes when creating consent
   *
   * @generated from field: string notes = 15;
   */
  notes: string;

  /**
   * Field name for expire timestamp when creating consent
   * replaced by expiration
   *
   * @generated from field: string expire = 16 [deprecated = true];
   * @deprecated
   */
  expire: string;

  /**
   * Field name for "condition from" timestamp when creating consent
   *
   * @generated from field: string condition_from = 17;
   */
  conditionFrom: string;

  /**
   * Field name for "condition to" timestamp when creating consent
   *
   * @generated from field: string condition_to = 18;
   */
  conditionTo: string;

  /**
   * Either a field name or content type value for the contennt type of the content
   *
   * @generated from oneof api.v0alpha.ConsentExportProcess.content_type
   */
  contentType: {
    /**
     * @generated from field: api.commons.ContentType content_type_val = 27;
     */
    value: ContentType;
    case: "contentTypeVal";
  } | {
    /**
     * @generated from field: string content_type_field_name = 28;
     */
    value: string;
    case: "contentTypeFieldName";
  } | { case: undefined; value?: undefined };

  /**
   * Either a field name or channel type value for the channel type. Field value should be a string
   *
   * @generated from oneof api.v0alpha.ConsentExportProcess.channel_type
   */
  channelType: {
    /**
     * @generated from field: api.commons.Channel channel_type_val = 29;
     */
    value: Channel;
    case: "channelTypeVal";
  } | {
    /**
     * @generated from field: string channel_type_field_name = 30;
     */
    value: string;
    case: "channelTypeFieldName";
  } | { case: undefined; value?: undefined };

  /**
   * @generated from oneof api.v0alpha.ConsentExportProcess.expiration
   */
  expiration: {
    /**
     * the static time that consent will expire at
     *
     * @generated from field: google.protobuf.Timestamp expiration_date = 31;
     */
    value: Timestamp$1;
    case: "expirationDate";
  } | {
    /**
     * the field name that holds info about the static time consent will expire at
     *
     * @generated from field: string expiration_field_name = 32;
     */
    value: string;
    case: "expirationFieldName";
  } | {
    /**
     * the relative time consent will expire at
     *
     * @generated from field: google.protobuf.Duration expiration_after_duration = 33;
     */
    value: Duration;
    case: "expirationAfterDuration";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<ConsentExportProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ConsentExportProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConsentExportProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConsentExportProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConsentExportProcess;

  static equals(a: ConsentExportProcess | PlainMessage<ConsentExportProcess> | undefined, b: ConsentExportProcess | PlainMessage<ConsentExportProcess> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.PaymentLinkEnrichment
 */
export declare class PaymentLinkEnrichment extends Message<PaymentLinkEnrichment> {
  /**
   * @generated from field: repeated string fields = 1 [deprecated = true];
   * @deprecated
   */
  fields: string[];

  /**
   * @generated from field: string payment_link_config_id = 2 [deprecated = true];
   * @deprecated
   */
  paymentLinkConfigId: string;

  /**
   * if true, we will not generate a link for lms records that to not contain *all* of the fields.
   * instead we will move that record to the discards
   *
   * @generated from field: bool discard_on_missing_fields = 3 [deprecated = true];
   * @deprecated
   */
  discardOnMissingFields: boolean;

  /**
   * lms field names as keys, mapped to what they should be called in the portal
   *
   * @generated from field: map<string, string> key_map = 4;
   */
  keyMap: { [key: string]: string };

  /**
   * the portal that these links will belong to.
   *
   * @generated from field: string portal_id = 5;
   */
  portalId: string;

  constructor(data?: PartialMessage<PaymentLinkEnrichment>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.PaymentLinkEnrichment";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaymentLinkEnrichment;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaymentLinkEnrichment;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaymentLinkEnrichment;

  static equals(a: PaymentLinkEnrichment | PlainMessage<PaymentLinkEnrichment> | undefined, b: PaymentLinkEnrichment | PlainMessage<PaymentLinkEnrichment> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.PortalLinkEnrichment
 */
export declare class PortalLinkEnrichment extends Message<PortalLinkEnrichment> {
  /**
   * lms field names as keys, mapped to what they should be called in the portal
   *
   * @generated from field: map<string, string> key_map = 1;
   */
  keyMap: { [key: string]: string };

  /**
   * the portal that these links will belong to.
   *
   * @generated from field: string portal_id = 2;
   */
  portalId: string;

  /**
   * unit type and quantity of: months, weeks, days, hours
   *
   * @generated from field: api.v0alpha.Expiration expiration = 6;
   */
  expiration?: Expiration;

  /**
   * if the payment will process or not
   *
   * @generated from field: bool demo = 7;
   */
  demo: boolean;

  constructor(data?: PartialMessage<PortalLinkEnrichment>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.PortalLinkEnrichment";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PortalLinkEnrichment;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PortalLinkEnrichment;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PortalLinkEnrichment;

  static equals(a: PortalLinkEnrichment | PlainMessage<PortalLinkEnrichment> | undefined, b: PortalLinkEnrichment | PlainMessage<PortalLinkEnrichment> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.Expiration
 */
export declare class Expiration extends Message<Expiration> {
  /**
   * units can be weeks, days, or hours
   *
   * @generated from field: api.v0alpha.TimeUnit units = 1;
   */
  units: TimeUnit;

  /**
   * max 1 year
   *
   * @generated from field: int64 quantity = 2;
   */
  quantity: bigint;

  constructor(data?: PartialMessage<Expiration>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.Expiration";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Expiration;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Expiration;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Expiration;

  static equals(a: Expiration | PlainMessage<Expiration> | undefined, b: Expiration | PlainMessage<Expiration> | undefined): boolean;
}

/**
 * split into ApiEntrypoint and SftpImport
 *
 * @generated from message api.v0alpha.EntrypointProcess
 */
export declare class EntrypointProcess extends Message<EntrypointProcess> {
  constructor(data?: PartialMessage<EntrypointProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.EntrypointProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EntrypointProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EntrypointProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EntrypointProcess;

  static equals(a: EntrypointProcess | PlainMessage<EntrypointProcess> | undefined, b: EntrypointProcess | PlainMessage<EntrypointProcess> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ApiEntrypoint
 */
export declare class ApiEntrypoint extends Message<ApiEntrypoint> {
  /**
   * @generated from field: string fts_id = 100;
   */
  ftsId: string;

  /**
   * prefered/default template
   *
   * @generated from field: string file_template_id = 16;
   */
  fileTemplateId: string;

  /**
   * @generated from field: bool incremental = 17;
   */
  incremental: boolean;

  /**
   * @generated from field: bool encrypted = 18;
   */
  encrypted: boolean;

  constructor(data?: PartialMessage<ApiEntrypoint>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ApiEntrypoint";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApiEntrypoint;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApiEntrypoint;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApiEntrypoint;

  static equals(a: ApiEntrypoint | PlainMessage<ApiEntrypoint> | undefined, b: ApiEntrypoint | PlainMessage<ApiEntrypoint> | undefined): boolean;
}

/**
 * HttpReq is what we will use to construct a GET or POST request to the server.
 *
 * @generated from message api.v0alpha.HttpReq
 */
export declare class HttpReq extends Message<HttpReq> {
  /**
   * what url to hit. First url in the group Must be able to be used as is, it
   * won't be parsed or messed with. Just passed directly to an http client.
   * every additional url instead of being a simple string can use values
   * retrieved from the previous response body, or headers. Examples: url =
   * "https://{{header.nextUrl}}" url = "{{body.path.toThe.1.nextUrl}}/search?
   * country={{body.country}}" to restate in english the examples: we will
   * replace the contents between {{ }} with the values retrieved from the
   * previous response body or headers the last url must always contain records
   * that can be parsed by the specified file template. templated values must
   * always be:
   * - wrapped in {{ }},
   * - first word be either "header." or "body."
   *   followed by a json dot path to the value to be looked up, or
   * - a named starting with $ ex. {{$token}} referencing a previous saved value.
   * - a special field: <TODAY> <NOW>  <TODAY.UNIX>
   * if one of these template values is found, it is assumed the previous
   * response is json, otherwise the lookups will fail, and the entrypoint will
   * error.
   *
   * @generated from field: string url = 1;
   */
  url: string;

  /**
   * initial headers must have static values for all the key value pairs.
   * every headers field after the first can contain template wrappers to
   * specify looking up the value from the previous response body, or headers
   * example:
   * { "key": "value", "{{header.nextKey}}": "{{body.somePath.to.a.str}}"}
   *
   * @generated from field: map<string, string> headers = 2;
   */
  headers: { [key: string]: string };

  /**
   * same as url, and headers fields, it is possible to use templated values to
   * construct the body often, body is either empty, or a json string
   *
   * @generated from field: string body = 3;
   */
  body: string;

  /**
   * what type of request to make  GET by default
   *
   * @generated from field: api.commons.HttpVerb method = 4;
   */
  method: HttpVerb;

  /**
   * the values to save from this response.
   * saved values can be referenced on *all* future requests.
   * so things like auth tokens need to be declared here so they can be
   * referenced by name later.
   * ex:
   * putting { "token": "body.response.authToken" } in the map
   * will allow us to use {{$token}} in all future http requests
   *
   * @generated from field: map<string, string> named_response_values = 5;
   */
  namedResponseValues: { [key: string]: string };

  constructor(data?: PartialMessage<HttpReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.HttpReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpReq;

  static equals(a: HttpReq | PlainMessage<HttpReq> | undefined, b: HttpReq | PlainMessage<HttpReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.WebEntrypointProcess
 */
export declare class WebEntrypointProcess extends Message<WebEntrypointProcess> {
  /**
   * the requests to make, in order, to get to our records.
   * Last request in the array must always be able to be parsed by the file template, or the template represented by the file_template_id
   * a nil, or 0 length array for http_requests will fail the entrypoint.
   * See comments on the HttpReq message for using templated values in the requests.
   *
   * @generated from field: repeated api.v0alpha.HttpReq http_requests = 1;
   */
  httpRequests: HttpReq[];

  /**
   * @generated from field: string file_template_id = 5;
   */
  fileTemplateId: string;

  /**
   * if set, the process will use this exact template during processing
   *
   * @generated from field: api.v0alpha.FileTemplate file_template = 6;
   */
  fileTemplate?: FileTemplate;

  /**
   * The name of this process. -YYYYMMDD will be attached.
   * If empty, defaults to web-entrypoint-<now>.
   * If scheduled through the lms-api, the element name will be used if left blank
   *
   * @generated from field: string name = 7;
   */
  name: string;

  /**
   * the cron string, just like sftp_import process
   *
   * @generated from field: string cron = 19;
   */
  cron: string;

  /**
   * Specifies the timezone to be used by the cron
   *
   * @generated from field: string timezone = 20;
   */
  timezone: string;

  /**
   * if false, the cron will not put events int he queue when triggered
   *
   * @generated from field: bool enabled = 21;
   */
  enabled: boolean;

  constructor(data?: PartialMessage<WebEntrypointProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.WebEntrypointProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WebEntrypointProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WebEntrypointProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WebEntrypointProcess;

  static equals(a: WebEntrypointProcess | PlainMessage<WebEntrypointProcess> | undefined, b: WebEntrypointProcess | PlainMessage<WebEntrypointProcess> | undefined): boolean;
}

/**
 * BulkWebEntrypointProcess works like a WebEntrypointProcess, but allows
 * user to specify a paginated request that is repeated till there are no
 * more records to import. This should be used when we don't know how much
 * data we are importing, or if we have a long running
 *
 * @generated from message api.v0alpha.BulkWebEntrypointProcess
 */
export declare class BulkWebEntrypointProcess extends Message<BulkWebEntrypointProcess> {
  /**
   * the requests to make, in order, to access priliminary data needed
   * to make the bulk data action part of the entrypoint.
   * the user is expected to specify which values need to be saved
   * in the HttpReq.named_response_values map.
   *
   * @generated from field: repeated api.v0alpha.HttpReq preliminary_requests = 2;
   */
  preliminaryRequests: HttpReq[];

  /**
   * this request is expected to return records that can be parsed by
   * the file template each time it is called.
   * if no termination case is specified, then we terminate after the first run.
   *
   * @generated from field: api.v0alpha.PaginatedHttpRequest paginated_request = 4;
   */
  paginatedRequest?: PaginatedHttpRequest;

  /**
   * the file template that can parse the paginated data
   *
   * @generated from field: string file_template_id = 5;
   */
  fileTemplateId: string;

  /**
   * The name of this process. -YYYYMMDD will be attached.
   * If empty, defaults to web-entrypoint-<now>.
   * If scheduled through the lms-api, the element name will be used if left
   * blank
   *
   * @generated from field: string name = 7;
   */
  name: string;

  /**
   * the cron string, just like sftp_import process
   *
   * @generated from field: string cron = 19;
   */
  cron: string;

  /**
   * Specifies the timezone to be used by the cron
   *
   * @generated from field: string timezone = 20;
   */
  timezone: string;

  /**
   * if false, the cron will not put events in the queue when triggered
   *
   * @generated from field: bool enabled = 21;
   */
  enabled: boolean;

  /**
   * how many pages we should save before aggregating the data and sending downstream
   * default is 100. Max is 10000.
   * If a termination state hasn't been reached, the event will be re-queued and continue
   * where it left off.
   *
   * @generated from field: int64 flush_page_count = 22;
   */
  flushPageCount: bigint;

  /**
   * how much total elapsed time (in minutes) we want to wait before flushing records.
   * if total time spent aggregating the data goes over this many minutes, we will flush
   * the current records downstream.
   * default is 20. Max is 120. Min is 1.
   * If a termination state hasn't been reached, the event will be re-queued and continue
   * where it left off.
   *
   * @generated from field: int64 flush_minute_count = 23;
   */
  flushMinuteCount: bigint;

  /**
   * if true, we will switch to processing mode when we have enough records to flush
   * even if we haven't downloaded all the pages yet.
   * after the current records are flushed, we switch back to downloading the remaining records.
   * If false (default), we download all the pages before we start processing any records.
   *
   * @generated from field: bool flush_during_check = 24;
   */
  flushDuringCheck: boolean;

  constructor(data?: PartialMessage<BulkWebEntrypointProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.BulkWebEntrypointProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BulkWebEntrypointProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BulkWebEntrypointProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BulkWebEntrypointProcess;

  static equals(a: BulkWebEntrypointProcess | PlainMessage<BulkWebEntrypointProcess> | undefined, b: BulkWebEntrypointProcess | PlainMessage<BulkWebEntrypointProcess> | undefined): boolean;
}

/**
 * OmniExchangeProcess allows omni to import contacts using LMS file upload
 *
 * @generated from message api.v0alpha.OmniExchangeProcess
 */
export declare class OmniExchangeProcess extends Message<OmniExchangeProcess> {
  /**
   * project_id is the id for the Omni project
   *
   * @generated from field: int64 project_id = 1;
   */
  projectId: bigint;

  /**
   * campaign_id is the id for the Omni campaign
   *
   * @generated from field: int64 campaign_id = 2;
   */
  campaignId: bigint;

  /**
   * @generated from field: string time_zone = 5;
   */
  timeZone: string;

  /**
   * the number of days into the future, can be 0
   *
   * @generated from field: int64 days = 4;
   */
  days: bigint;

  /**
   * hour of the day, 0-23
   *
   * @generated from field: int64 hour = 6;
   */
  hour: bigint;

  /**
   * minute of the hour, 0-59
   *
   * @generated from field: int64 minute = 7;
   */
  minute: bigint;

  constructor(data?: PartialMessage<OmniExchangeProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.OmniExchangeProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OmniExchangeProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OmniExchangeProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OmniExchangeProcess;

  static equals(a: OmniExchangeProcess | PlainMessage<OmniExchangeProcess> | undefined, b: OmniExchangeProcess | PlainMessage<OmniExchangeProcess> | undefined): boolean;
}

/**
 * WebExchangeProcess is an lms exchange process that lets the user upload data to third part api.
 * right now rest is supported with non bulk uploads.
 *
 * @generated from message api.v0alpha.WebExchangeProcess
 */
export declare class WebExchangeProcess extends Message<WebExchangeProcess> {
  /**
   * @generated from field: repeated api.v0alpha.HttpReq http_requests = 1;
   */
  httpRequests: HttpReq[];

  /**
   * threshold for a failed process. if threshold is exceeded, entire process fails
   *
   * @generated from field: int64 error_threshold = 2;
   */
  errorThreshold: bigint;

  constructor(data?: PartialMessage<WebExchangeProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.WebExchangeProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WebExchangeProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WebExchangeProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WebExchangeProcess;

  static equals(a: WebExchangeProcess | PlainMessage<WebExchangeProcess> | undefined, b: WebExchangeProcess | PlainMessage<WebExchangeProcess> | undefined): boolean;
}

/**
 * this request is expected to return records that can be parsed by
 * the file template each time it is called.
 * if no termination case is specified, (end_for_any, and end_for_all are empty)
 * then we terminate after the first call.
 *
 * @generated from message api.v0alpha.PaginatedHttpRequest
 */
export declare class PaginatedHttpRequest extends Message<PaginatedHttpRequest> {
  /**
   * an http request that must return records.
   * the iteration_request will have access to the special template variable
   * {{$i}} which will increment by 1 every time the request is made.
   *
   * @generated from field: api.v0alpha.HttpReq iteration_request = 1;
   */
  iterationRequest?: HttpReq;

  /**
   * the starting value of i.
   *
   * @generated from field: int64 start_index = 2;
   */
  startIndex: bigint;

  /**
   * terminates if *any* of the terminators return true
   *
   * @generated from field: repeated api.commons.PaginationTerminator end_for_any = 3;
   */
  endForAny: PaginationTerminator[];

  /**
   * terminates if all fo the terminators return true
   *
   * @generated from field: repeated api.commons.PaginationTerminator end_for_all = 4;
   */
  endForAll: PaginationTerminator[];

  /**
   * if set, and if the PaginationTerminator returns true
   * the response is considered not done.
   * No rows are expected to be imported from this response,
   * and the request will retry.
   *
   * @generated from field: api.commons.PaginationTerminator request_not_ready = 5;
   */
  requestNotReady?: PaginationTerminator;

  /**
   * how many seconds we will wait before retrying if request_not_ready returns true
   *
   * @generated from field: int64 not_ready_wait_seconds = 6;
   */
  notReadyWaitSeconds: bigint;

  /**
   * whether to retry the preliminary when we get a not ready state
   *
   * @generated from field: bool not_ready_redo_preliminary = 7;
   */
  notReadyRedoPreliminary: boolean;

  /**
   * if set we do not advance {{$i}} to the next value if request_not_ready returns true
   *
   * @generated from field: bool not_ready_skip_iteration = 8;
   */
  notReadySkipIteration: boolean;

  /**
   * whether the end page has records on it
   *
   * @generated from field: bool process_stop_page = 9;
   */
  processStopPage: boolean;

  constructor(data?: PartialMessage<PaginatedHttpRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.PaginatedHttpRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaginatedHttpRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaginatedHttpRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaginatedHttpRequest;

  static equals(a: PaginatedHttpRequest | PlainMessage<PaginatedHttpRequest> | undefined, b: PaginatedHttpRequest | PlainMessage<PaginatedHttpRequest> | undefined): boolean;
}

/**
 * Takes SFTP credentials and import a file
 *
 * @generated from message api.v0alpha.SftpImport
 */
export declare class SftpImport extends Message<SftpImport> {
  /**
   * SFTP credentials. `password` will
   * be tried first for authentication,
   * if left blank, `private_key` will be tried.
   *
   * @generated from field: string user = 4;
   */
  user: string;

  /**
   * @generated from field: string password = 5;
   */
  password: string;

  /**
   * @generated from field: string private_key = 6;
   */
  privateKey: string;

  /**
   * @generated from field: string address = 7;
   */
  address: string;

  /**
   * @generated from field: string port = 8;
   */
  port: string;

  /**
   * @generated from field: api.commons.FilePattern file_pattern = 13;
   */
  filePattern?: FilePattern;

  /**
   * We will only process if enabled
   *
   * @generated from field: bool enabled = 15;
   */
  enabled: boolean;

  /**
   * prefered/default template
   *
   * @generated from field: string file_template_id = 16;
   */
  fileTemplateId: string;

  /**
   * @generated from field: bool incremental = 17;
   */
  incremental: boolean;

  /**
   * Specifies whether the files to be imported
   * are encrypted with PGP key
   *
   * @generated from field: bool encrypted = 18;
   */
  encrypted: boolean;

  /**
   * Should be a valid Cron expression
   * based on https://en.wikipedia.org/wiki/Cron
   *
   * @generated from field: string cron = 19;
   */
  cron: string;

  /**
   * Timezone to be used with the cron,
   * if left blank it will default to the
   * local time of whatever server it is on.
   * e.g. "America/Denver", "America/New_York"
   * Must exist in TZ database
   * https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
   *
   * @generated from field: string timezone = 20;
   */
  timezone: string;

  /**
   * Name of the transfer_config, used to find sftp configuration
   *
   * @generated from field: string transfer_config_name = 21;
   */
  transferConfigName: string;

  constructor(data?: PartialMessage<SftpImport>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.SftpImport";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SftpImport;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SftpImport;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SftpImport;

  static equals(a: SftpImport | PlainMessage<SftpImport> | undefined, b: SftpImport | PlainMessage<SftpImport> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.RndEnrichmentProcess
 */
export declare class RndEnrichmentProcess extends Message<RndEnrichmentProcess> {
  /**
   * @generated from field: string org_id = 1;
   */
  orgId: string;

  /**
   * @generated from field: string field = 2;
   */
  field: string;

  /**
   * @generated from field: string date_last_contact_field = 3;
   */
  dateLastContactField: string;

  constructor(data?: PartialMessage<RndEnrichmentProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.RndEnrichmentProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RndEnrichmentProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RndEnrichmentProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RndEnrichmentProcess;

  static equals(a: RndEnrichmentProcess | PlainMessage<RndEnrichmentProcess> | undefined, b: RndEnrichmentProcess | PlainMessage<RndEnrichmentProcess> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.CjsImportProcess
 */
export declare class CjsImportProcess extends Message<CjsImportProcess> {
  /**
   * Specifies which CJS List to import from
   *
   * @generated from field: string cjs_collection_id = 3;
   */
  cjsCollectionId: string;

  /**
   * Enable/Disable the process
   *
   * @generated from field: bool enabled = 5;
   */
  enabled: boolean;

  /**
   * Should be a valid Cron expression
   * based on https://en.wikipedia.org/wiki/Cron
   *
   * @generated from field: string cron = 6;
   */
  cron: string;

  /**
   * Timezone to be used with the cron,
   * if left blank it will default to the
   * local time of whatever server it is on.
   * e.g. "America/Denver", "America/New_York"
   * Must exist in TZ database
   * https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
   *
   * @generated from field: string timezone = 7;
   */
  timezone: string;

  /**
   * Specifies if a dedup should be performed when importing
   *
   * @generated from field: bool dedup = 8;
   */
  dedup: boolean;

  constructor(data?: PartialMessage<CjsImportProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.CjsImportProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CjsImportProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CjsImportProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CjsImportProcess;

  static equals(a: CjsImportProcess | PlainMessage<CjsImportProcess> | undefined, b: CjsImportProcess | PlainMessage<CjsImportProcess> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.CjsExportProcess
 */
export declare class CjsExportProcess extends Message<CjsExportProcess> {
  /**
   * If creating a new list, generate
   * a random UUID for `cjs_collection_id`
   *
   * @generated from field: string cjs_collection_id = 3;
   */
  cjsCollectionId: string;

  /**
   * Specifies which fields should be exported
   *
   * @generated from field: api.v0alpha.ExportHeader header = 4;
   */
  header?: ExportHeader;

  /**
   * To Disable, or run as a test
   *
   * `list_name` and `key_field` are only needed
   * when creating a new list, they will
   * be ignored otherwise
   *
   * @generated from field: api.commons.RunType run_type = 5;
   */
  runType: RunType;

  /**
   * Specifies the name of the CJS list
   * to be created
   *
   * @generated from field: string cjs_collection_name = 6;
   */
  cjsCollectionName: string;

  /**
   * If true it will overwrite the current
   * collection instead of appending
   *
   * @generated from field: bool overwrite = 8;
   */
  overwrite: boolean;

  /**
   * If true the collection will update existing
   * entries matched with the key field
   *
   * @generated from field: bool update = 9;
   */
  update: boolean;

  /**
   * Field to use for updating
   *
   * @generated from field: string update_key_field = 10;
   */
  updateKeyField: string;

  constructor(data?: PartialMessage<CjsExportProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.CjsExportProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CjsExportProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CjsExportProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CjsExportProcess;

  static equals(a: CjsExportProcess | PlainMessage<CjsExportProcess> | undefined, b: CjsExportProcess | PlainMessage<CjsExportProcess> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.CjsEnrichmentProcess
 */
export declare class CjsEnrichmentProcess extends Message<CjsEnrichmentProcess> {
  /**
   * Specifies the Journey collection to be used
   * Available options can be obtained
   * from Journey
   *
   * @generated from field: string cjs_collection_id = 3;
   */
  cjsCollectionId: string;

  /**
   * Specifies the LMS list field
   * to be used as the key when
   * doing search in CJS list
   *
   * @generated from field: string key_field = 4;
   */
  keyField: string;

  /**
   * Specifies how to enrich the LMS list
   * OR - Acjs all records, merging any matches
   * XOR - Keep records that are only in one of the lists (exclude those in both)
   * AND - Keep only records that are in both lists, merge the records
   * JOIN - Keep all of the primary source and merge in matches from the
   *        secondary source
   *
   * @generated from field: api.commons.EnrichmentType enrich_type = 5;
   */
  enrichType: EnrichmentType;

  /**
   * Specifies the primary list (LMS or CJS)
   * When merging records, all the fields from the primary
   * source will be used, and only the extra fields (if any)
   * will be added to the record
   *
   * @generated from field: api.commons.PrimarySource primary_source = 6;
   */
  primarySource: PrimarySource;

  /**
   * Specifies the Journey collection field
   * to be matched against.
   * Available options can be obtained
   * from Journey
   *
   * @generated from field: string cjs_key_field_name = 7;
   */
  cjsKeyFieldName: string;

  /**
   * Specifies if the primary list columns
   * should be overwritten by the secondary
   * on matching column names
   *
   * @generated from field: bool column_overwrite = 8;
   */
  columnOverwrite: boolean;

  /**
   * Specifies what to do when there
   * is a duplicate match for the key in the collection
   *
   * @generated from field: api.commons.DedupKeyPolicy dedup_key_policy = 9;
   */
  dedupKeyPolicy: DedupKeyPolicy;

  constructor(data?: PartialMessage<CjsEnrichmentProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.CjsEnrichmentProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CjsEnrichmentProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CjsEnrichmentProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CjsEnrichmentProcess;

  static equals(a: CjsEnrichmentProcess | PlainMessage<CjsEnrichmentProcess> | undefined, b: CjsEnrichmentProcess | PlainMessage<CjsEnrichmentProcess> | undefined): boolean;
}

/**
 * this process downloads the records from the signed_url
 * and writes them to the output
 *
 * @generated from message api.v0alpha.AppendProcess
 */
export declare class AppendProcess extends Message<AppendProcess> {
  /**
   * @generated from field: string fts_id = 5;
   */
  ftsId: string;

  constructor(data?: PartialMessage<AppendProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.AppendProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppendProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppendProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppendProcess;

  static equals(a: AppendProcess | PlainMessage<AppendProcess> | undefined, b: AppendProcess | PlainMessage<AppendProcess> | undefined): boolean;
}

/**
 * USE INSTEAD of ComplProcess
 *
 * @generated from message api.v0alpha.LookupProcess
 */
export declare class LookupProcess extends Message<LookupProcess> {
  /**
   * names of the fields that will be used in the lookup
   *
   * @generated from field: repeated string field_names = 6;
   */
  fieldNames: string[];

  /**
   * @generated from oneof api.v0alpha.LookupProcess.proc
   */
  proc: {
    /**
     * lookup from compliance
     *
     * @generated from field: api.v0alpha.LookupProcess.ComplProcess compl = 7;
     */
    value: LookupProcess_ComplProcess;
    case: "compl";
  } | {
    /**
     * lookup from another version of another list
     *
     * @generated from field: api.v0alpha.LookupProcess.ListLookup list = 8;
     */
    value: LookupProcess_ListLookup;
    case: "list";
  } | {
    /**
     * lookup against the records at the url
     *
     * @generated from field: api.v0alpha.LookupProcess.UrlLookup url = 9;
     */
    value: LookupProcess_UrlLookup;
    case: "url";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<LookupProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.LookupProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LookupProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LookupProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LookupProcess;

  static equals(a: LookupProcess | PlainMessage<LookupProcess> | undefined, b: LookupProcess | PlainMessage<LookupProcess> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.LookupProcess.ComplProcess
 */
export declare class LookupProcess_ComplProcess extends Message<LookupProcess_ComplProcess> {
  /**
   * @generated from field: string country_code = 11;
   */
  countryCode: string;

  constructor(data?: PartialMessage<LookupProcess_ComplProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.LookupProcess.ComplProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LookupProcess_ComplProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LookupProcess_ComplProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LookupProcess_ComplProcess;

  static equals(a: LookupProcess_ComplProcess | PlainMessage<LookupProcess_ComplProcess> | undefined, b: LookupProcess_ComplProcess | PlainMessage<LookupProcess_ComplProcess> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.LookupProcess.ListLookup
 */
export declare class LookupProcess_ListLookup extends Message<LookupProcess_ListLookup> {
  /**
   * @generated from field: string org_id = 1;
   */
  orgId: string;

  /**
   * @generated from field: string region_id = 2;
   */
  regionId: string;

  /**
   * @generated from field: string element_id = 3;
   */
  elementId: string;

  /**
   * latest list will be used by default
   *
   * @generated from field: int64 version = 4;
   */
  version: bigint;

  constructor(data?: PartialMessage<LookupProcess_ListLookup>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.LookupProcess.ListLookup";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LookupProcess_ListLookup;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LookupProcess_ListLookup;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LookupProcess_ListLookup;

  static equals(a: LookupProcess_ListLookup | PlainMessage<LookupProcess_ListLookup> | undefined, b: LookupProcess_ListLookup | PlainMessage<LookupProcess_ListLookup> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.LookupProcess.UrlLookup
 */
export declare class LookupProcess_UrlLookup extends Message<LookupProcess_UrlLookup> {
  /**
   * @generated from field: string url = 5;
   */
  url: string;

  /**
   * the template file used to convert records to proto
   * if left blank it assumes already converted format
   *
   * @generated from field: api.v0alpha.FileTemplate file_template = 10;
   */
  fileTemplate?: FileTemplate;

  constructor(data?: PartialMessage<LookupProcess_UrlLookup>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.LookupProcess.UrlLookup";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LookupProcess_UrlLookup;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LookupProcess_UrlLookup;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LookupProcess_UrlLookup;

  static equals(a: LookupProcess_UrlLookup | PlainMessage<LookupProcess_UrlLookup> | undefined, b: LookupProcess_UrlLookup | PlainMessage<LookupProcess_UrlLookup> | undefined): boolean;
}

/**
 * DEPRECATED
 *
 * @generated from message api.v0alpha.ComplProcess
 */
export declare class ComplProcess extends Message<ComplProcess> {
  constructor(data?: PartialMessage<ComplProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ComplProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComplProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComplProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComplProcess;

  static equals(a: ComplProcess | PlainMessage<ComplProcess> | undefined, b: ComplProcess | PlainMessage<ComplProcess> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.CFSExportConfig
 */
export declare class CFSExportConfig extends Message<CFSExportConfig> {
  /**
   * @generated from field: api.commons.ExportType type = 1;
   */
  type: ExportType;

  /**
   * @generated from field: string value = 2;
   */
  value: string;

  constructor(data?: PartialMessage<CFSExportConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.CFSExportConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CFSExportConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CFSExportConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CFSExportConfig;

  static equals(a: CFSExportConfig | PlainMessage<CFSExportConfig> | undefined, b: CFSExportConfig | PlainMessage<CFSExportConfig> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.CFSExportReqHeader
 */
export declare class CFSExportReqHeader extends Message<CFSExportReqHeader> {
  /**
   * @generated from field: api.v0alpha.ExportHeader export_header = 1;
   */
  exportHeader?: ExportHeader;

  /**
   * @generated from field: repeated api.v0alpha.CFSExportConfig configs = 2;
   */
  configs: CFSExportConfig[];

  /**
   * @generated from field: string org_id = 3;
   */
  orgId: string;

  /**
   * @generated from field: string region_id = 4;
   */
  regionId: string;

  constructor(data?: PartialMessage<CFSExportReqHeader>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.CFSExportReqHeader";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CFSExportReqHeader;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CFSExportReqHeader;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CFSExportReqHeader;

  static equals(a: CFSExportReqHeader | PlainMessage<CFSExportReqHeader> | undefined, b: CFSExportReqHeader | PlainMessage<CFSExportReqHeader> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.CFSExportProcess
 */
export declare class CFSExportProcess extends Message<CFSExportProcess> {
  /**
   * @generated from field: api.v0alpha.ExportHeader export_header = 1;
   */
  exportHeader?: ExportHeader;

  /**
   * @generated from field: repeated api.v0alpha.CFSExportConfig configs = 2;
   */
  configs: CFSExportConfig[];

  constructor(data?: PartialMessage<CFSExportProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.CFSExportProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CFSExportProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CFSExportProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CFSExportProcess;

  static equals(a: CFSExportProcess | PlainMessage<CFSExportProcess> | undefined, b: CFSExportProcess | PlainMessage<CFSExportProcess> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.FilterProcess
 */
export declare class FilterProcess extends Message<FilterProcess> {
  /**
   * @generated from field: string expression = 1;
   */
  expression: string;

  /**
   * @generated from field: repeated api.v0alpha.FilterOperation operations = 2;
   */
  operations: FilterOperation[];

  /**
   * @generated from field: bool negate = 3;
   */
  negate: boolean;

  constructor(data?: PartialMessage<FilterProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.FilterProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilterProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilterProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilterProcess;

  static equals(a: FilterProcess | PlainMessage<FilterProcess> | undefined, b: FilterProcess | PlainMessage<FilterProcess> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.FilterOperation
 */
export declare class FilterOperation extends Message<FilterOperation> {
  /**
   * sequence of checks taken on a record that all must reduce to a boolean.
   * All results are then either AND-ed or OR-ed together. The resulting bool is
   * returned.
   *
   * @generated from field: repeated api.v0alpha.FilterCheck checks = 1;
   */
  checks: FilterCheck[];

  /**
   * @generated from field: api.commons.ChainOperator operator = 2;
   */
  operator: ChainOperator;

  constructor(data?: PartialMessage<FilterOperation>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.FilterOperation";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilterOperation;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilterOperation;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilterOperation;

  static equals(a: FilterOperation | PlainMessage<FilterOperation> | undefined, b: FilterOperation | PlainMessage<FilterOperation> | undefined): boolean;
}

/**
 * Describes a lookup of a field on a record, checking its value or type against
 * another value. Each FilterCheck must boil down to a bool value.
 *
 * @generated from message api.v0alpha.FilterCheck
 */
export declare class FilterCheck extends Message<FilterCheck> {
  /**
   * We can either check value, or type in one step, not both.
   *
   * @generated from oneof api.v0alpha.FilterCheck.check
   */
  check: {
    /**
     * @generated from field: api.v0alpha.FilterCheck.ValueComparison val_comp = 12;
     */
    value: FilterCheck_ValueComparison;
    case: "valComp";
  } | {
    /**
     * @generated from field: api.v0alpha.FilterCheck.TypeComparison type_comp = 13;
     */
    value: FilterCheck_TypeComparison;
    case: "typeComp";
  } | {
    /**
     * @generated from field: api.v0alpha.FilterCheck.ListComparison list_comp = 14;
     */
    value: FilterCheck_ListComparison;
    case: "listComp";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<FilterCheck>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.FilterCheck";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilterCheck;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilterCheck;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilterCheck;

  static equals(a: FilterCheck | PlainMessage<FilterCheck> | undefined, b: FilterCheck | PlainMessage<FilterCheck> | undefined): boolean;
}

/**
 * a value to compare against.
 *
 * @generated from message api.v0alpha.FilterCheck.Value
 */
export declare class FilterCheck_Value extends Message<FilterCheck_Value> {
  /**
   * @generated from oneof api.v0alpha.FilterCheck.Value.val
   */
  val: {
    /**
     * compare against the provided static string
     *
     * @generated from field: string string_val = 1;
     */
    value: string;
    case: "stringVal";
  } | {
    /**
     * compare against the provided static double
     *
     * @generated from field: double number_val = 2;
     */
    value: number;
    case: "numberVal";
  } | {
    /**
     * @generated from field: bool bool_val = 3;
     */
    value: boolean;
    case: "boolVal";
  } | {
    /**
     * compare against the value looked up from the record by field_name
     *
     * @generated from field: api.v0alpha.FieldIndex field_name = 5;
     */
    value: FieldIndex;
    case: "fieldName";
  } | {
    /**
     * compare against the datetime value
     *
     * @generated from field: api.v0alpha.DateTime date_time = 14;
     */
    value: DateTime;
    case: "dateTime";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<FilterCheck_Value>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.FilterCheck.Value";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilterCheck_Value;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilterCheck_Value;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilterCheck_Value;

  static equals(a: FilterCheck_Value | PlainMessage<FilterCheck_Value> | undefined, b: FilterCheck_Value | PlainMessage<FilterCheck_Value> | undefined): boolean;
}

/**
 * A bool comparison of a field vs some other value
 *
 * @generated from message api.v0alpha.FilterCheck.ValueComparison
 */
export declare class FilterCheck_ValueComparison extends Message<FilterCheck_ValueComparison> {
  /**
   * name of the field to lookup in record. This field's value will be used
   *
   * @generated from field: api.v0alpha.FieldIndex field_name = 6;
   */
  fieldName?: FieldIndex;

  /**
   * operation we are performing
   *
   * @generated from field: api.commons.CompareOperator op = 7;
   */
  op: CompareOperator;

  /**
   * other value to compare against
   *
   * @generated from field: api.v0alpha.FilterCheck.Value value = 8;
   */
  value?: FilterCheck_Value;

  /**
   * if "negate" is true, we negate the result of this comparison
   *
   * @generated from field: bool negate = 9;
   */
  negate: boolean;

  /**
   * if "exists" is true, we check for field existence
   *
   * @generated from field: bool exists = 10;
   */
  exists: boolean;

  constructor(data?: PartialMessage<FilterCheck_ValueComparison>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.FilterCheck.ValueComparison";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilterCheck_ValueComparison;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilterCheck_ValueComparison;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilterCheck_ValueComparison;

  static equals(a: FilterCheck_ValueComparison | PlainMessage<FilterCheck_ValueComparison> | undefined, b: FilterCheck_ValueComparison | PlainMessage<FilterCheck_ValueComparison> | undefined): boolean;
}

/**
 * bool comparison saying the field matches a specific type or not
 *
 * @generated from message api.v0alpha.FilterCheck.TypeComparison
 */
export declare class FilterCheck_TypeComparison extends Message<FilterCheck_TypeComparison> {
  /**
   * name of the field to lookup in record. This field's type will be used
   *
   * @generated from field: api.v0alpha.FieldIndex field_name = 9;
   */
  fieldName?: FieldIndex;

  /**
   * the type we must match to report true
   *
   * @generated from field: api.commons.RecordType matches_field_type = 10;
   */
  matchesFieldType: RecordType;

  /**
   * if "negate" is true, we negate the result of this comparison
   *
   * @generated from field: bool negate = 11;
   */
  negate: boolean;

  constructor(data?: PartialMessage<FilterCheck_TypeComparison>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.FilterCheck.TypeComparison";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilterCheck_TypeComparison;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilterCheck_TypeComparison;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilterCheck_TypeComparison;

  static equals(a: FilterCheck_TypeComparison | PlainMessage<FilterCheck_TypeComparison> | undefined, b: FilterCheck_TypeComparison | PlainMessage<FilterCheck_TypeComparison> | undefined): boolean;
}

/**
 * list comparison of a list of fields vs list of values
 *
 * @generated from message api.v0alpha.FilterCheck.ListComparison
 */
export declare class FilterCheck_ListComparison extends Message<FilterCheck_ListComparison> {
  /**
   * name of the field to lookup in record. This field's value will be used
   *
   * @generated from field: api.v0alpha.FieldIndex field_name = 5;
   */
  fieldName?: FieldIndex;

  /**
   * @generated from field: repeated api.v0alpha.FilterCheck.ListComparison.FieldOrVal data = 8;
   */
  data: FilterCheck_ListComparison_FieldOrVal[];

  /**
   * if "negate" is true, we negate the result of this comparison
   *
   * @generated from field: bool negate = 9;
   */
  negate: boolean;

  constructor(data?: PartialMessage<FilterCheck_ListComparison>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.FilterCheck.ListComparison";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilterCheck_ListComparison;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilterCheck_ListComparison;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilterCheck_ListComparison;

  static equals(a: FilterCheck_ListComparison | PlainMessage<FilterCheck_ListComparison> | undefined, b: FilterCheck_ListComparison | PlainMessage<FilterCheck_ListComparison> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.FilterCheck.ListComparison.FieldOrVal
 */
export declare class FilterCheck_ListComparison_FieldOrVal extends Message<FilterCheck_ListComparison_FieldOrVal> {
  /**
   * @generated from oneof api.v0alpha.FilterCheck.ListComparison.FieldOrVal.val
   */
  val: {
    /**
     * @generated from field: api.v0alpha.FieldIndex field = 6;
     */
    value: FieldIndex;
    case: "field";
  } | {
    /**
     * @generated from field: api.v0alpha.FilterCheck.Value value = 7;
     */
    value: FilterCheck_Value;
    case: "value";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<FilterCheck_ListComparison_FieldOrVal>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.FilterCheck.ListComparison.FieldOrVal";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilterCheck_ListComparison_FieldOrVal;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilterCheck_ListComparison_FieldOrVal;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilterCheck_ListComparison_FieldOrVal;

  static equals(a: FilterCheck_ListComparison_FieldOrVal | PlainMessage<FilterCheck_ListComparison_FieldOrVal> | undefined, b: FilterCheck_ListComparison_FieldOrVal | PlainMessage<FilterCheck_ListComparison_FieldOrVal> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.GSExportProcess
 */
export declare class GSExportProcess extends Message<GSExportProcess> {
  /**
   * @generated from field: string bucket = 2;
   */
  bucket: string;

  /**
   * @generated from field: string file = 3;
   */
  file: string;

  constructor(data?: PartialMessage<GSExportProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.GSExportProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GSExportProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GSExportProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GSExportProcess;

  static equals(a: GSExportProcess | PlainMessage<GSExportProcess> | undefined, b: GSExportProcess | PlainMessage<GSExportProcess> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.P3ExportProcess
 */
export declare class P3ExportProcess extends Message<P3ExportProcess> {
  /**
   * Specifies which fields to export
   *
   * @generated from field: api.v0alpha.ExportHeader header = 1;
   */
  header?: ExportHeader;

  /**
   * @generated from field: string contact_list_prefix = 2;
   */
  contactListPrefix: string;

  /**
   * P3 API Username
   *
   * @generated from field: string username = 3;
   */
  username: string;

  /**
   * P3 API Password
   *
   * @generated from field: string password = 4;
   */
  password: string;

  /**
   * Call List Country
   *
   * @generated from field: string country = 5;
   */
  country: string;

  /**
   * Specifies how to handle duplicate phone numbers.
   * 'Keep and Discard' = keep the record, discard the number.
   * 'Allow' = keep the record & number.
   * 'Discard' = discard both.
   * 'Duplicate List' = create duplicate list
   * Default = 'Keep and Discard'
   *
   * @generated from field: api.commons.DuplicatePolicyType dupe_policy = 6;
   */
  dupePolicy: DuplicatePolicyType;

  /**
   * Specifies how records without numbers should be handled.
   *
   * @generated from field: api.commons.AbsentPolicyType absent_policy = 7;
   */
  absentPolicy: AbsentPolicyType;

  /**
   * / The number of the import template describing this import.
   *
   * @generated from field: int32 template_id = 8;
   */
  templateId: number;

  /**
   * Specifies a default area code to use with file
   *
   * @generated from field: int32 default_area_code = 9;
   */
  defaultAreaCode: number;

  /**
   * The number of the template describing the campaign to be sent.
   *
   * @generated from field: int32 schedule_template_number = 10;
   */
  scheduleTemplateNumber: number;

  /**
   * `description` will be deprecated in
   * favor of `file_pattern`,
   * currently it is ignored
   *
   * @generated from field: string description = 11;
   */
  description: string;

  /**
   * To Disable or run as test
   *
   * @generated from field: api.commons.RunType run_type = 12;
   */
  runType: RunType;

  /**
   * `file_pattern` is what sets the description
   * we are using api.commons.FilePattern so that it
   * can change depending on the day.
   * The directory field in this `file_pattern`
   * should not be used (it will be ignored)
   *
   * @generated from field: api.commons.FilePattern file_pattern = 13 [deprecated = true];
   * @deprecated
   */
  filePattern?: FilePattern;

  /**
   * what to name the file
   *
   * @generated from field: api.commons.ConstructedFilename filename = 43;
   */
  filename?: ConstructedFilename;

  /**
   * Advanced options
   * Allows ids to be specificied in place of the ones
   * already specified into the schedule template
   *
   * @generated from field: repeated int64 caller_ids = 14;
   */
  callerIds: bigint[];

  /**
   * Scrub known cell numbers from call list
   *
   * @generated from field: bool cell_scrub = 15;
   */
  cellScrub: boolean;

  /**
   * Campaign start time
   *
   * @generated from field: google.protobuf.Timestamp start_time = 16;
   */
  startTime?: Timestamp$1;

  /**
   * Campaign end time
   *
   * @generated from field: google.protobuf.Timestamp end_time = 17;
   */
  endTime?: Timestamp$1;

  /**
   * FIRST, NATURAL, or CUSTOM. Will default to FIRST
   *
   * @generated from field: api.commons.DialOrderType dial_order = 18;
   */
  dialOrder: DialOrderType;

  /**
   * Identifies the Email column in the contact list.
   *
   * @generated from field: string email_field = 20;
   */
  emailField: string;

  /**
   * Email address to send campaign from.
   *
   * @generated from field: string email_from = 21;
   */
  emailFrom: string;

  /**
   * Dial numbers from east to west.
   * 'true' = numbers will be dialed from east to west.
   * 'false' = numbers will be dialed in default order.
   * Default = 'false'
   *
   * @generated from field: bool follow_the_sun = 22;
   */
  followTheSun: boolean;

  /**
   * Messages Per Minute
   *
   * @generated from field: int32 messages_per_minute = 23;
   */
  messagesPerMinute: number;

  /**
   * Allow contacts to be inserted in random order.
   *
   * @generated from field: bool randomize_contacts = 24;
   */
  randomizeContacts: boolean;

  /**
   * Specifies if to schedule as paused.
   *
   * @generated from field: bool schedule_as_paused = 25;
   */
  scheduleAsPaused: boolean;

  /**
   * Allows selection of a schedule rule (input by name)
   *
   * @generated from field: string schedule_rule = 26;
   */
  scheduleRule: string;

  /**
   * TCN P3 will attempt to very file uniqueness over a 20 hour period.
   * If duplicates are found the duplicates are failed.
   * 'true' = do not attempt to verify file uniqueness.
   * 'false' = attempt to verify file uniqueness.
   * Default = 'false'
   *
   * @generated from field: bool sha_digest_override = 27;
   */
  shaDigestOverride: boolean;

  /**
   * Identifies the Cell Phone column in the contact list.
   *
   * @generated from field: string sms_field = 28;
   */
  smsField: string;

  /**
   * Number to to send campaign from.
   *
   * @generated from field: int64 sms_source_number = 29;
   */
  smsSourceNumber: bigint;

  /**
   *  Allow calls after hours.
   * 'true' = calls may go out after 9 P.M. and before 8 A.M.
   * 'false = calls will not go out after 9 P.M. and before 8 A.M.
   * Default = 'false'
   *
   * @generated from field: bool timezone_override = 30;
   */
  timezoneOverride: boolean;

  /**
   * Specifies how to handle zip code scrubbing.
   * If client preference is set to use zip code scrub, that value will be default.
   * 'true' = will scrub based on the client preference for zip code fields.
   * 'false' = will not scrub based on zip code.
   * Default = 'false'
   *
   * @generated from field: bool zip_scrub = 31;
   */
  zipScrub: boolean;

  /**
   * Specifies the completion percentage at which to execute campaign linking.
   *
   * @generated from field: int32 completion_threshold = 32;
   */
  completionThreshold: number;

  /**
   * TIMEZONE must exist in the TZ database:
   * http://en.wikipedia.org/wiki/List_of_tz_database_time_zones
   *
   * @generated from field: string timezone = 33;
   */
  timezone: string;

  /**
   * Specifies the Natural Language Compliance Rule
   * to be used. Empty will not use NLC
   *
   * @generated from field: string compliance_rule = 34;
   */
  complianceRule: string;

  /**
   * what separates a field from another.  In csv this is ','
   *
   * @generated from field: string field_delimiter = 35;
   */
  fieldDelimiter: string;

  /**
   * what separates a record from another. In csv this is '\n'
   *
   * @generated from field: string record_delimiter = 36;
   */
  recordDelimiter: string;

  /**
   * Wrap fields with `"`
   *
   * @generated from field: bool quote_fields = 37;
   */
  quoteFields: boolean;

  /**
   * Specifies whether to export using the date
   * format defined by the field in the file
   * template or use the default
   *
   * @generated from field: bool use_custom_date_format = 38;
   */
  useCustomDateFormat: boolean;

  /**
   * Specifies the export filetype
   * (CSV, CUSTOM, TSV, etc.)
   * If the export filetype is anything other than custom
   * `field_delimiter`, `record_delimiter` and `quote_fields`
   * will be ignored
   *
   * @generated from field: api.commons.FileFormat file_format = 39;
   */
  fileFormat: FileFormat;

  /**
   * The fields `days_into_future`, `start_hour`
   * and `end_hour`
   * will override `start_time`, `end_time`
   * and should be used over `start_time`, and `end_time`
   * Specifies how many days into the future to schedule
   * 0 <= days < 7, 0 = today, 1 = tomorrow, etc.
   *
   * @generated from field: int64 days_into_future = 40;
   */
  daysIntoFuture: bigint;

  /**
   * Specifies the time to start
   * in format "15:04"
   *
   * @generated from field: string start_hour = 41;
   */
  startHour: string;

  /**
   * Specifies the time to end
   * in format "15:04"
   *
   * @generated from field: string end_hour = 42;
   */
  endHour: string;

  /**
   * will schedule the campaign by timezone
   *
   * @generated from field: bool schedule_by_timezone = 44;
   */
  scheduleByTimezone: boolean;

  /**
   * If true, it will try to bunch all phone number
   * fields to the left.
   *
   * @generated from field: bool shift_phone_fields = 45;
   */
  shiftPhoneFields: boolean;

  /**
   * campaign linking
   *
   * @generated from field: bool do_campaign_linking = 46;
   */
  doCampaignLinking: boolean;

  /**
   * @generated from field: string campaign_link_id = 47;
   */
  campaignLinkId: string;

  /**
   * @generated from field: string stop_trigger = 48;
   */
  stopTrigger: string;

  constructor(data?: PartialMessage<P3ExportProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.P3ExportProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): P3ExportProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): P3ExportProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): P3ExportProcess;

  static equals(a: P3ExportProcess | PlainMessage<P3ExportProcess> | undefined, b: P3ExportProcess | PlainMessage<P3ExportProcess> | undefined): boolean;
}

/**
 * Describes an export process to compliance list/DNCL
 * Expiration is optional
 * CountryCode is required only if the field type is phone/sms
 *
 * @generated from message api.v0alpha.ComplianceExportProcess
 */
export declare class ComplianceExportProcess extends Message<ComplianceExportProcess> {
  /**
   * @generated from field: string list_name = 2;
   */
  listName: string;

  /**
   * @generated from field: string field = 3;
   */
  field: string;

  /**
   * Optional, has to be type date
   *
   * @generated from field: string expiration_field = 4;
   */
  expirationField: string;

  /**
   * Optional, only needed with phone/sms
   *
   * @generated from field: string country_code = 5;
   */
  countryCode: string;

  /**
   * @generated from field: api.commons.RunType run_type = 6;
   */
  runType: RunType;

  /**
   * @generated from field: api.commons.ComplianceListType compliance_list_type = 7;
   */
  complianceListType: ComplianceListType;

  constructor(data?: PartialMessage<ComplianceExportProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ComplianceExportProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComplianceExportProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComplianceExportProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComplianceExportProcess;

  static equals(a: ComplianceExportProcess | PlainMessage<ComplianceExportProcess> | undefined, b: ComplianceExportProcess | PlainMessage<ComplianceExportProcess> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ScrubProcess
 */
export declare class ScrubProcess extends Message<ScrubProcess> {
  /**
   * @generated from field: string list_id = 3;
   */
  listId: string;

  /**
   * @generated from field: string field = 4;
   */
  field: string;

  constructor(data?: PartialMessage<ScrubProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ScrubProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScrubProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScrubProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScrubProcess;

  static equals(a: ScrubProcess | PlainMessage<ScrubProcess> | undefined, b: ScrubProcess | PlainMessage<ScrubProcess> | undefined): boolean;
}

/**
 * This process collects data from a specific fields in all the records in the lms list
 * and calls Compliance.DeleteScrubListEntries() on them.
 *
 * @generated from message api.v0alpha.DeleteScrubEntriesProcess
 */
export declare class DeleteScrubEntriesProcess extends Message<DeleteScrubEntriesProcess> {
  /**
   * 'list_id' is the id of the scrub list in compliance to delete from
   *
   * @generated from field: string list_id = 3;
   */
  listId: string;

  /**
   * 'field' is which column on an lms record that contains the data we want to delete
   * from the scrub list in compliance.
   * ex: if field is "first"  all records that contain a record field named "first" will have their contents
   * collected, and sent to compliance to be deleted from scrub list.
   *
   * @generated from field: string field = 4;
   */
  field: string;

  constructor(data?: PartialMessage<DeleteScrubEntriesProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.DeleteScrubEntriesProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteScrubEntriesProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteScrubEntriesProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteScrubEntriesProcess;

  static equals(a: DeleteScrubEntriesProcess | PlainMessage<DeleteScrubEntriesProcess> | undefined, b: DeleteScrubEntriesProcess | PlainMessage<DeleteScrubEntriesProcess> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.FrequencyProcess
 */
export declare class FrequencyProcess extends Message<FrequencyProcess> {
  /**
   * LMS field from the list to be used
   *
   * @generated from field: string field = 4;
   */
  field: string;

  /**
   * Duration to check frequency
   *
   * @generated from field: int64 days = 5;
   */
  days: bigint;

  /**
   * Country code needed if `field` is a phone number
   *
   * @generated from field: string country_code = 6;
   */
  countryCode: string;

  /**
   * Field we are checking against in frequency
   * e.g. Account Number
   * Will default to "phone_number"
   *
   * @generated from field: string meta_field = 7;
   */
  metaField: string;

  /**
   * Option for dispositions given in key
   * value pairs. Value is optional, it will
   * just check for existence of key if left out.
   *
   * @generated from field: repeated api.v0alpha.DispositionPair dispositions = 8;
   */
  dispositions: DispositionPair[];

  /**
   * Different result types
   * e.g. Answered,Answered Machine,Busy, etc.
   *
   * @generated from field: repeated string results = 9;
   */
  results: string[];

  /**
   * Options for dispositions given in key/value
   * pair sets. Values are optional. Must have
   * at least one match in each set.
   *
   * @generated from field: repeated api.v0alpha.DispositionSet disposition_sets = 10;
   */
  dispositionSets: DispositionSet[];

  constructor(data?: PartialMessage<FrequencyProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.FrequencyProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FrequencyProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FrequencyProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FrequencyProcess;

  static equals(a: FrequencyProcess | PlainMessage<FrequencyProcess> | undefined, b: FrequencyProcess | PlainMessage<FrequencyProcess> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.DispositionSet
 */
export declare class DispositionSet extends Message<DispositionSet> {
  /**
   * A set of disposition pairs.
   *
   * @generated from field: repeated api.v0alpha.DispositionPair dispositions = 1;
   */
  dispositions: DispositionPair[];

  constructor(data?: PartialMessage<DispositionSet>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.DispositionSet";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DispositionSet;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DispositionSet;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DispositionSet;

  static equals(a: DispositionSet | PlainMessage<DispositionSet> | undefined, b: DispositionSet | PlainMessage<DispositionSet> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.DispositionPair
 */
export declare class DispositionPair extends Message<DispositionPair> {
  /**
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * Value is optional.
   * If left blank, we will just
   * check for existence of `key`.
   *
   * @generated from field: string value = 2;
   */
  value: string;

  constructor(data?: PartialMessage<DispositionPair>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.DispositionPair";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DispositionPair;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DispositionPair;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DispositionPair;

  static equals(a: DispositionPair | PlainMessage<DispositionPair> | undefined, b: DispositionPair | PlainMessage<DispositionPair> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.SftpExportProcess
 */
export declare class SftpExportProcess extends Message<SftpExportProcess> {
  /**
   * where we try and write the data to on the destination filesystem
   *
   * DEPRECATED!!
   *
   * @generated from field: string dest_filepath = 1;
   */
  destFilepath: string;

  /**
   * if left "", the service will attempt to use a public key instead
   *
   * DEPRECATED
   *
   * @generated from field: string password = 2;
   */
  password: string;

  /**
   * where we are trying to connect to.
   *
   * @generated from field: string address = 3;
   */
  address: string;

  /**
   * username for sftp connection
   *
   * DEPRECATED
   *
   * @generated from field: string username = 4;
   */
  username: string;

  /**
   * port we will attempt to establish a connection with
   *
   * @generated from field: int32 port = 5;
   */
  port: number;

  /**
   * File format to use (CSV, CUSTOM, TSV, etc.)
   * `field_delimiter`, `record_dilimiter`, and `quote_fields`
   * will be ignored the the format is not CUSTOM
   *
   * @generated from field: api.commons.FileFormat fileformat = 7;
   */
  fileformat: FileFormat;

  /**
   * Specifies whether to use headers in the
   * export file or not.
   *
   * @generated from field: bool prepend_headers = 8;
   */
  prependHeaders: boolean;

  /**
   * Specifies custom field delimiter (default `,`)
   *
   * @generated from field: string field_delimiter = 9;
   */
  fieldDelimiter: string;

  /**
   * Specifies custom record delimiter (default `\n`)
   *
   * @generated from field: string record_delimiter = 10;
   */
  recordDelimiter: string;

  /**
   * Specifies the construction of the export filename
   *
   * @generated from field: api.commons.FilePattern file_pattern = 11 [deprecated = true];
   * @deprecated
   */
  filePattern?: FilePattern;

  /**
   * Run type can be RUN (default), TEST, or DISABLED
   *
   * @generated from field: api.commons.RunType run_type = 12;
   */
  runType: RunType;

  /**
   * Specifies which fields to export
   *
   * @generated from field: api.v0alpha.ExportHeader header = 13;
   */
  header?: ExportHeader;

  /**
   * Wrap fields with `"`
   *
   * @generated from field: bool quote_fields = 14;
   */
  quoteFields: boolean;

  /**
   * Specifies whether to export using the date
   * format defined by the field in the file
   * template or use the default
   *
   * @generated from field: bool use_custom_date_format = 15;
   */
  useCustomDateFormat: boolean;

  /**
   * directory to put the file in
   *
   * @generated from field: string directory = 16;
   */
  directory: string;

  /**
   * what to name the file
   *
   * @generated from field: api.commons.ConstructedFilename filename = 17;
   */
  filename?: ConstructedFilename;

  /**
   * If true, it will try to bunch all phone number
   * fields to the left.
   *
   * @generated from field: bool shift_phone_fields = 18;
   */
  shiftPhoneFields: boolean;

  /**
   * transfer configs will be unique by name, transfer configs store credential data
   *
   * @generated from field: string transfer_config_name = 19;
   */
  transferConfigName: string;

  constructor(data?: PartialMessage<SftpExportProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.SftpExportProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SftpExportProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SftpExportProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SftpExportProcess;

  static equals(a: SftpExportProcess | PlainMessage<SftpExportProcess> | undefined, b: SftpExportProcess | PlainMessage<SftpExportProcess> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.WfmMultiSkill
 */
export declare class WfmMultiSkill extends Message<WfmMultiSkill> {
  constructor(data?: PartialMessage<WfmMultiSkill>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.WfmMultiSkill";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WfmMultiSkill;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WfmMultiSkill;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WfmMultiSkill;

  static equals(a: WfmMultiSkill | PlainMessage<WfmMultiSkill> | undefined, b: WfmMultiSkill | PlainMessage<WfmMultiSkill> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.WfmExportProcess
 */
export declare class WfmExportProcess extends Message<WfmExportProcess> {
  /**
   * single_skill import with this sid in the data
   * multi_skill wfm will fetch the data from
   * the 'Skill Profile' column
   *
   * @generated from oneof api.v0alpha.WfmExportProcess.skill_profile
   */
  skillProfile: {
    /**
     * @generated from field: int64 single = 1;
     */
    value: bigint;
    case: "single";
  } | {
    /**
     * @generated from field: api.v0alpha.WfmMultiSkill multi = 2;
     */
    value: WfmMultiSkill;
    case: "multi";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<WfmExportProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.WfmExportProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WfmExportProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WfmExportProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WfmExportProcess;

  static equals(a: WfmExportProcess | PlainMessage<WfmExportProcess> | undefined, b: WfmExportProcess | PlainMessage<WfmExportProcess> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ExportHeader
 */
export declare class ExportHeader extends Message<ExportHeader> {
  /**
   * @generated from field: repeated string names = 1;
   */
  names: string[];

  constructor(data?: PartialMessage<ExportHeader>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ExportHeader";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExportHeader;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExportHeader;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExportHeader;

  static equals(a: ExportHeader | PlainMessage<ExportHeader> | undefined, b: ExportHeader | PlainMessage<ExportHeader> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.SortReq
 */
export declare class SortReq extends Message<SortReq> {
  /**
   * @generated from oneof api.v0alpha.SortReq.request
   */
  request: {
    /**
     * the header, this will always be sent as the first message, and only
     * records will be sent after that.
     *
     * @generated from field: api.v0alpha.SortCriteria criteria = 1;
     */
    value: SortCriteria;
    case: "criteria";
  } | {
    /**
     * @generated from field: api.v0alpha.RecordProto record = 2;
     */
    value: RecordProto;
    case: "record";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<SortReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.SortReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SortReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SortReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SortReq;

  static equals(a: SortReq | PlainMessage<SortReq> | undefined, b: SortReq | PlainMessage<SortReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.CFSExportReq
 */
export declare class CFSExportReq extends Message<CFSExportReq> {
  /**
   * @generated from oneof api.v0alpha.CFSExportReq.request
   */
  request: {
    /**
     * @generated from field: api.v0alpha.CFSExportReqHeader header = 1;
     */
    value: CFSExportReqHeader;
    case: "header";
  } | {
    /**
     * @generated from field: api.v0alpha.RecordProto record = 2;
     */
    value: RecordProto;
    case: "record";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<CFSExportReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.CFSExportReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CFSExportReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CFSExportReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CFSExportReq;

  static equals(a: CFSExportReq | PlainMessage<CFSExportReq> | undefined, b: CFSExportReq | PlainMessage<CFSExportReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.DeDupCriteria
 */
export declare class DeDupCriteria extends Message<DeDupCriteria> {
  /**
   * @generated from field: api.commons.DeDupActions action = 3;
   */
  action: DeDupActions;

  /**
   * @generated from field: repeated api.v0alpha.FieldIndex fields = 2;
   */
  fields: FieldIndex[];

  constructor(data?: PartialMessage<DeDupCriteria>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.DeDupCriteria";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeDupCriteria;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeDupCriteria;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeDupCriteria;

  static equals(a: DeDupCriteria | PlainMessage<DeDupCriteria> | undefined, b: DeDupCriteria | PlainMessage<DeDupCriteria> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.SortCriteria
 */
export declare class SortCriteria extends Message<SortCriteria> {
  /**
   * The ordering, ascending or descending
   *
   * @generated from field: repeated api.commons.SortOrder ordering = 1;
   */
  ordering: SortOrder[];

  /**
   * @generated from field: repeated api.v0alpha.FieldIndex field_order = 2;
   */
  fieldOrder: FieldIndex[];

  constructor(data?: PartialMessage<SortCriteria>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.SortCriteria";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SortCriteria;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SortCriteria;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SortCriteria;

  static equals(a: SortCriteria | PlainMessage<SortCriteria> | undefined, b: SortCriteria | PlainMessage<SortCriteria> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.Error
 */
export declare class Error extends Message<Error> {
  /**
   * @generated from field: string error = 1;
   */
  error: string;

  /**
   * @generated from field: string raw_value = 2;
   */
  rawValue: string;

  constructor(data?: PartialMessage<Error>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.Error";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Error;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Error;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Error;

  static equals(a: Error | PlainMessage<Error> | undefined, b: Error | PlainMessage<Error> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.RecordFieldMap
 */
export declare class RecordFieldMap extends Message<RecordFieldMap> {
  /**
   * @generated from field: map<string, api.v0alpha.RecordFieldProto> fields = 1;
   */
  fields: { [key: string]: RecordFieldProto };

  constructor(data?: PartialMessage<RecordFieldMap>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.RecordFieldMap";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordFieldMap;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordFieldMap;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordFieldMap;

  static equals(a: RecordFieldMap | PlainMessage<RecordFieldMap> | undefined, b: RecordFieldMap | PlainMessage<RecordFieldMap> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.Currency
 */
export declare class Currency extends Message<Currency> {
  /**
   * @generated from field: string symbol = 1;
   */
  symbol: string;

  /**
   * @generated from field: string raw_value = 2;
   */
  rawValue: string;

  /**
   * @generated from field: double value = 3;
   */
  value: number;

  /**
   * @generated from field: string name = 4;
   */
  name: string;

  /**
   * @generated from field: bool invalid = 5;
   */
  invalid: boolean;

  constructor(data?: PartialMessage<Currency>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.Currency";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Currency;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Currency;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Currency;

  static equals(a: Currency | PlainMessage<Currency> | undefined, b: Currency | PlainMessage<Currency> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.Phone
 */
export declare class Phone extends Message<Phone> {
  /**
   * @generated from field: string raw_value = 3;
   */
  rawValue: string;

  /**
   * @generated from field: string full_number = 4;
   */
  fullNumber: string;

  /**
   * @generated from field: bool invalid = 5;
   */
  invalid: boolean;

  constructor(data?: PartialMessage<Phone>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.Phone";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Phone;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Phone;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Phone;

  static equals(a: Phone | PlainMessage<Phone> | undefined, b: Phone | PlainMessage<Phone> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.PostalCode
 */
export declare class PostalCode extends Message<PostalCode> {
  /**
   * @generated from field: string postal_code = 1;
   */
  postalCode: string;

  /**
   * @generated from field: bool invalid = 2;
   */
  invalid: boolean;

  constructor(data?: PartialMessage<PostalCode>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.PostalCode";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostalCode;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostalCode;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostalCode;

  static equals(a: PostalCode | PlainMessage<PostalCode> | undefined, b: PostalCode | PlainMessage<PostalCode> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.Email
 */
export declare class Email extends Message<Email> {
  /**
   * @generated from field: string local_part = 1;
   */
  localPart: string;

  /**
   * @generated from field: string domain = 2;
   */
  domain: string;

  /**
   * @generated from field: string full_address = 3;
   */
  fullAddress: string;

  /**
   * @generated from field: bool invalid = 4;
   */
  invalid: boolean;

  constructor(data?: PartialMessage<Email>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.Email";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Email;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Email;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Email;

  static equals(a: Email | PlainMessage<Email> | undefined, b: Email | PlainMessage<Email> | undefined): boolean;
}

/**
 * modifies a DateTime by specific amount
 *
 * @generated from message api.v0alpha.DateTimeModifier
 */
export declare class DateTimeModifier extends Message<DateTimeModifier> {
  /**
   * @generated from field: int32 years = 1;
   */
  years: number;

  /**
   * @generated from field: int32 weeks = 3;
   */
  weeks: number;

  /**
   * @generated from field: int32 days = 4;
   */
  days: number;

  /**
   * @generated from field: int32 hours = 5;
   */
  hours: number;

  /**
   * @generated from field: int32 minutes = 6;
   */
  minutes: number;

  /**
   * @generated from field: int32 seconds = 7;
   */
  seconds: number;

  constructor(data?: PartialMessage<DateTimeModifier>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.DateTimeModifier";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DateTimeModifier;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DateTimeModifier;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DateTimeModifier;

  static equals(a: DateTimeModifier | PlainMessage<DateTimeModifier> | undefined, b: DateTimeModifier | PlainMessage<DateTimeModifier> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.DateTime
 */
export declare class DateTime extends Message<DateTime> {
  /**
   * the raw string given when parsing the datetime obj
   *
   * @generated from field: string raw_value = 1;
   */
  rawValue: string;

  /**
   * the format string used to create this datetime object
   *
   * @generated from field: string format = 2;
   */
  format: string;

  /**
   * our date value ordered from most specific to least
   *
   * @generated from field: api.commons.DateTimePrecision precision = 3;
   */
  precision: DateTimePrecision;

  /**
   * modifier to apply to our value when comparing
   *
   * @generated from field: api.v0alpha.DateTimeModifier modifier = 11;
   */
  modifier?: DateTimeModifier;

  constructor(data?: PartialMessage<DateTime>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.DateTime";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DateTime;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DateTime;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DateTime;

  static equals(a: DateTime | PlainMessage<DateTime> | undefined, b: DateTime | PlainMessage<DateTime> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.EnrichedPhone
 */
export declare class EnrichedPhone extends Message<EnrichedPhone> {
  /**
   * @generated from field: string area_code = 1;
   */
  areaCode: string;

  /**
   * @generated from field: string block_id = 2;
   */
  blockId: string;

  /**
   * @generated from field: string carrier = 3;
   */
  carrier: string;

  /**
   * @generated from field: string cc = 4;
   */
  cc: string;

  /**
   * @generated from field: string ccnsn = 5;
   */
  ccnsn: string;

  /**
   * @generated from field: string cell_prefix = 6;
   */
  cellPrefix: string;

  /**
   * @generated from field: string city = 7;
   */
  city: string;

  /**
   * @generated from field: string coc_type = 8;
   */
  cocType: string;

  /**
   * @generated from field: bool dst = 9;
   */
  dst: boolean;

  /**
   * @generated from field: string international_prefix = 10;
   */
  internationalPrefix: string;

  /**
   * @generated from field: string iso2 = 11;
   */
  iso2: string;

  /**
   * @generated from field: string language = 12;
   */
  language: string;

  /**
   * Location location = 13;
   *
   * @generated from field: string max = 14;
   */
  max: string;

  /**
   * @generated from field: string min = 15;
   */
  min: string;

  /**
   * @generated from field: string national_prefix = 16;
   */
  nationalPrefix: string;

  /**
   * @generated from field: string ndc = 17;
   */
  ndc: string;

  /**
   * @generated from field: string prefix = 18;
   */
  prefix: string;

  /**
   * @generated from field: string region_code = 19;
   */
  regionCode: string;

  /**
   * @generated from field: string region_name = 20;
   */
  regionName: string;

  /**
   * @generated from field: string ssc1 = 21;
   */
  ssc1: string;

  /**
   * @generated from field: string ssc2 = 22;
   */
  ssc2: string;

  /**
   * @generated from field: string ssc3 = 23;
   */
  ssc3: string;

  /**
   * @generated from field: string ssc4 = 24;
   */
  ssc4: string;

  /**
   * @generated from field: string source = 25;
   */
  source: string;

  /**
   * @generated from field: string time_zone = 26;
   */
  timeZone: string;

  /**
   * @generated from field: string type = 27;
   */
  type: string;

  /**
   * @generated from field: bool uses_ndc = 28;
   */
  usesNdc: boolean;

  /**
   * RecordFieldProto enriched_from = 30;
   *
   * @generated from field: float utc = 29;
   */
  utc: number;

  constructor(data?: PartialMessage<EnrichedPhone>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.EnrichedPhone";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnrichedPhone;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnrichedPhone;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnrichedPhone;

  static equals(a: EnrichedPhone | PlainMessage<EnrichedPhone> | undefined, b: EnrichedPhone | PlainMessage<EnrichedPhone> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.EnrichedZip
 */
export declare class EnrichedZip extends Message<EnrichedZip> {
  /**
   * @generated from field: int32 accuracy = 1;
   */
  accuracy: number;

  /**
   * @generated from field: string admin_code1 = 2;
   */
  adminCode1: string;

  /**
   * @generated from field: string admin_code2 = 3;
   */
  adminCode2: string;

  /**
   * @generated from field: string admin_code3 = 4;
   */
  adminCode3: string;

  /**
   * @generated from field: string admin_name1 = 5;
   */
  adminName1: string;

  /**
   * @generated from field: string admin_name2 = 6;
   */
  adminName2: string;

  /**
   * @generated from field: string admin_name3 = 7;
   */
  adminName3: string;

  /**
   * @generated from field: string area_code = 8;
   */
  areaCode: string;

  /**
   * @generated from field: string city_name = 9;
   */
  cityName: string;

  /**
   * @generated from field: string city_type = 10;
   */
  cityType: string;

  /**
   * @generated from field: string country_code = 11;
   */
  countryCode: string;

  /**
   * @generated from field: string county_fips = 12;
   */
  countyFips: string;

  /**
   * @generated from field: string county_name = 13;
   */
  countyName: string;

  /**
   * @generated from field: bool dst = 14;
   */
  dst: boolean;

  /**
   * @generated from field: string iso2 = 15;
   */
  iso2: string;

  /**
   * Location location = 16;
   *
   * @generated from field: string msa_code = 17;
   */
  msaCode: string;

  /**
   * @generated from field: string place_name = 18;
   */
  placeName: string;

  /**
   * @generated from field: string postal_code = 19;
   */
  postalCode: string;

  /**
   * @generated from field: string postal_code_key = 20;
   */
  postalCodeKey: string;

  /**
   * @generated from field: string postal_type = 21;
   */
  postalType: string;

  /**
   * @generated from field: string province_abbr = 22;
   */
  provinceAbbr: string;

  /**
   * @generated from field: string province_name = 23;
   */
  provinceName: string;

  /**
   * @generated from field: string source = 24;
   */
  source: string;

  /**
   * @generated from field: string state_fips = 25;
   */
  stateFips: string;

  /**
   * @generated from field: string time_zone = 26;
   */
  timeZone: string;

  /**
   * RecordFieldProto enriched_from = 28;
   *
   * @generated from field: float utc = 27;
   */
  utc: number;

  constructor(data?: PartialMessage<EnrichedZip>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.EnrichedZip";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnrichedZip;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnrichedZip;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnrichedZip;

  static equals(a: EnrichedZip | PlainMessage<EnrichedZip> | undefined, b: EnrichedZip | PlainMessage<EnrichedZip> | undefined): boolean;
}

/**
 * represents need for getting current timestamp during processing
 *
 * @generated from message api.v0alpha.Now
 */
export declare class Now extends Message<Now> {
  constructor(data?: PartialMessage<Now>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.Now";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Now;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Now;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Now;

  static equals(a: Now | PlainMessage<Now> | undefined, b: Now | PlainMessage<Now> | undefined): boolean;
}

/**
 * a specific point in time, down to second presision.
 *
 * @generated from message api.v0alpha.Timestamp
 */
export declare class Timestamp extends Message<Timestamp> {
  /**
   * @generated from field: int32 year = 3;
   */
  year: number;

  /**
   * januaury = 1, december = 12
   *
   * @generated from field: int32 month = 4;
   */
  month: number;

  /**
   * between 1-53
   *
   * @generated from field: int32 week = 5;
   */
  week: number;

  /**
   * depending on the month 1-31
   *
   * @generated from field: int32 day_of_month = 6;
   */
  dayOfMonth: number;

  /**
   * 0-6 sunday = 0
   *
   * @generated from field: int32 day_of_week = 7;
   */
  dayOfWeek: number;

  /**
   * 1 - 366 (leap year)
   *
   * @generated from field: int32 day_of_year = 8;
   */
  dayOfYear: number;

  /**
   * 0-23
   *
   * @generated from field: int32 hour = 9;
   */
  hour: number;

  /**
   * 0-59
   *
   * @generated from field: int32 minute = 10;
   */
  minute: number;

  /**
   * 0-59
   *
   * @generated from field: int32 second = 11;
   */
  second: number;

  constructor(data?: PartialMessage<Timestamp>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.Timestamp";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Timestamp;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Timestamp;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Timestamp;

  static equals(a: Timestamp | PlainMessage<Timestamp> | undefined, b: Timestamp | PlainMessage<Timestamp> | undefined): boolean;
}

/**
 * a specific year, month, and day.
 *
 * @generated from message api.v0alpha.Date
 */
export declare class Date extends Message<Date> {
  /**
   * @generated from field: int32 year = 3;
   */
  year: number;

  /**
   * @generated from field: int32 month = 4;
   */
  month: number;

  /**
   * @generated from field: int32 week = 5;
   */
  week: number;

  /**
   * @generated from field: int32 day_of_month = 6;
   */
  dayOfMonth: number;

  /**
   * @generated from field: int32 day_of_week = 7;
   */
  dayOfWeek: number;

  /**
   * @generated from field: int32 day_of_year = 8;
   */
  dayOfYear: number;

  constructor(data?: PartialMessage<Date>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.Date";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Date;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Date;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Date;

  static equals(a: Date | PlainMessage<Date> | undefined, b: Date | PlainMessage<Date> | undefined): boolean;
}

/**
 * a specific month and day of the year
 *
 * @generated from message api.v0alpha.MonthAndDay
 */
export declare class MonthAndDay extends Message<MonthAndDay> {
  /**
   * @generated from field: int32 month = 3;
   */
  month: number;

  /**
   * @generated from field: int32 week = 4;
   */
  week: number;

  /**
   * @generated from field: int32 day_of_month = 5;
   */
  dayOfMonth: number;

  /**
   * @generated from field: int32 day_of_week = 6;
   */
  dayOfWeek: number;

  /**
   * @generated from field: int32 day_of_year = 7;
   */
  dayOfYear: number;

  constructor(data?: PartialMessage<MonthAndDay>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.MonthAndDay";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MonthAndDay;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MonthAndDay;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MonthAndDay;

  static equals(a: MonthAndDay | PlainMessage<MonthAndDay> | undefined, b: MonthAndDay | PlainMessage<MonthAndDay> | undefined): boolean;
}

/**
 * a specific day of the week.  sunday = 0
 *
 * @generated from message api.v0alpha.DayOfWeek
 */
export declare class DayOfWeek extends Message<DayOfWeek> {
  /**
   * @generated from field: int32 day_of_week = 3;
   */
  dayOfWeek: number;

  constructor(data?: PartialMessage<DayOfWeek>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.DayOfWeek";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DayOfWeek;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DayOfWeek;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DayOfWeek;

  static equals(a: DayOfWeek | PlainMessage<DayOfWeek> | undefined, b: DayOfWeek | PlainMessage<DayOfWeek> | undefined): boolean;
}

/**
 * a specific time of day. 24 hour format. 12:00:00AM = 0,0,0
 *
 * @generated from message api.v0alpha.TimeOfDay
 */
export declare class TimeOfDay extends Message<TimeOfDay> {
  /**
   * @generated from field: int32 hour = 3;
   */
  hour: number;

  /**
   * @generated from field: int32 minute = 4;
   */
  minute: number;

  /**
   * @generated from field: int32 second = 5;
   */
  second: number;

  constructor(data?: PartialMessage<TimeOfDay>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.TimeOfDay";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeOfDay;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeOfDay;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeOfDay;

  static equals(a: TimeOfDay | PlainMessage<TimeOfDay> | undefined, b: TimeOfDay | PlainMessage<TimeOfDay> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.FileFormatParams
 */
export declare class FileFormatParams extends Message<FileFormatParams> {
  /**
   * use skip_first_lines
   *
   * @generated from field: int32 skip_first_no_lines = 10 [deprecated = true];
   * @deprecated
   */
  skipFirstNoLines: number;

  /**
   * @generated from field: string skip_lines_match_regex = 11 [deprecated = true];
   * @deprecated
   */
  skipLinesMatchRegex: string;

  /**
   * @generated from field: bool trim_spaces = 12;
   */
  trimSpaces: boolean;

  /**
   * @generated from field: string custom_delimiter = 13;
   */
  customDelimiter: string;

  /**
   * @generated from field: bool skip_first_line = 14;
   */
  skipFirstLine: boolean;

  /**
   * for json file formats:
   * if non-empty represents that the file is one large json object,
   * and that this is the json path to the root that contains all the records.
   * example: { response: { records: [...] } }
   * to get to the records stored at [...], we would use
   * json_dot_path="response.records"
   * If left blank, we are expected each json object to be on its own line: (jsonl)
   *
   * @generated from field: string json_dot_path = 15;
   */
  jsonDotPath: string;

  constructor(data?: PartialMessage<FileFormatParams>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.FileFormatParams";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FileFormatParams;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FileFormatParams;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FileFormatParams;

  static equals(a: FileFormatParams | PlainMessage<FileFormatParams> | undefined, b: FileFormatParams | PlainMessage<FileFormatParams> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ReshapeProcess
 */
export declare class ReshapeProcess extends Message<ReshapeProcess> {
  /**
   * @generated from field: repeated api.v0alpha.ReshapeAction actions = 1;
   */
  actions: ReshapeAction[];

  constructor(data?: PartialMessage<ReshapeProcess>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeProcess";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeProcess;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeProcess;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeProcess;

  static equals(a: ReshapeProcess | PlainMessage<ReshapeProcess> | undefined, b: ReshapeProcess | PlainMessage<ReshapeProcess> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ReshapeAction
 */
export declare class ReshapeAction extends Message<ReshapeAction> {
  /**
   * NOT a FieldIndex
   *
   * @generated from field: string field = 19;
   */
  field: string;

  /**
   * will only execute on the matching type (defaults to ALL)
   *
   * @generated from field: api.commons.RecordType matching_type = 20 [deprecated = true];
   * @deprecated
   */
  matchingType: RecordType;

  /**
   * @generated from field: api.v0alpha.FilterCheck predicate = 50;
   */
  predicate?: FilterCheck;

  /**
   * @generated from oneof api.v0alpha.ReshapeAction.action
   */
  action: {
    /**
     * @generated from field: api.v0alpha.ReshapeAction.Rename rename = 22;
     */
    value: ReshapeAction_Rename;
    case: "rename";
  } | {
    /**
     * @generated from field: api.v0alpha.ReshapeAction.AddValue add_value = 23;
     */
    value: ReshapeAction_AddValue;
    case: "addValue";
  } | {
    /**
     * @generated from field: api.v0alpha.ReshapeAction.AddField add_field = 24;
     */
    value: ReshapeAction_AddField;
    case: "addField";
  } | {
    /**
     * @generated from field: api.v0alpha.ReshapeAction.AddDate add_date = 47;
     */
    value: ReshapeAction_AddDate;
    case: "addDate";
  } | {
    /**
     * @generated from field: api.v0alpha.ReshapeAction.SubtractValue subtract_value = 25;
     */
    value: ReshapeAction_SubtractValue;
    case: "subtractValue";
  } | {
    /**
     * @generated from field: api.v0alpha.ReshapeAction.SubtractField subtract_field = 26;
     */
    value: ReshapeAction_SubtractField;
    case: "subtractField";
  } | {
    /**
     * @generated from field: api.v0alpha.ReshapeAction.Convert convert = 28;
     */
    value: ReshapeAction_Convert;
    case: "convert";
  } | {
    /**
     * @generated from field: api.v0alpha.ReshapeAction.RemoveField remove_field = 29;
     */
    value: ReshapeAction_RemoveField;
    case: "removeField";
  } | {
    /**
     * @generated from field: api.v0alpha.ReshapeAction.AddNewField add_new_field = 30;
     */
    value: ReshapeAction_AddNewField;
    case: "addNewField";
  } | {
    /**
     * @generated from field: api.v0alpha.ReshapeAction.ChangeCurrencyType change_currency_type = 31;
     */
    value: ReshapeAction_ChangeCurrencyType;
    case: "changeCurrencyType";
  } | {
    /**
     * @generated from field: api.v0alpha.ReshapeAction.Divide divide = 32;
     */
    value: ReshapeAction_Divide;
    case: "divide";
  } | {
    /**
     * @generated from field: api.v0alpha.ReshapeAction.Multiply multiply = 33;
     */
    value: ReshapeAction_Multiply;
    case: "multiply";
  } | {
    /**
     * @generated from field: api.v0alpha.ReshapeAction.Modulo modulo = 34;
     */
    value: ReshapeAction_Modulo;
    case: "modulo";
  } | {
    /**
     * @generated from field: api.v0alpha.ReshapeAction.Merge merge = 40;
     */
    value: ReshapeAction_Merge;
    case: "merge";
  } | {
    /**
     * @generated from field: api.v0alpha.ReshapeAction.SetFieldValue set_field_value = 41;
     */
    value: ReshapeAction_SetFieldValue;
    case: "setFieldValue";
  } | {
    /**
     * @generated from field: api.v0alpha.ReshapeAction.AddNewFieldFromField add_new_field_from_field = 45;
     */
    value: ReshapeAction_AddNewFieldFromField;
    case: "addNewFieldFromField";
  } | {
    /**
     * @generated from field: api.v0alpha.ReshapeAction.SetFieldFromField set_field_from_field = 46;
     */
    value: ReshapeAction_SetFieldFromField;
    case: "setFieldFromField";
  } | {
    /**
     * @generated from field: api.v0alpha.ReshapeAction.Pad pad = 52;
     */
    value: ReshapeAction_Pad;
    case: "pad";
  } | {
    /**
     * @generated from field: api.v0alpha.ReshapeAction.Trim trim = 53;
     */
    value: ReshapeAction_Trim;
    case: "trim";
  } | {
    /**
     * @generated from field: api.v0alpha.ReshapeAction.Extract extract = 54;
     */
    value: ReshapeAction_Extract;
    case: "extract";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<ReshapeAction>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction;

  static equals(a: ReshapeAction | PlainMessage<ReshapeAction> | undefined, b: ReshapeAction | PlainMessage<ReshapeAction> | undefined): boolean;
}

/**
 * rename this field's name to new_name, keep the value the same
 *
 * legal: All
 *
 * @generated from message api.v0alpha.ReshapeAction.Rename
 */
export declare class ReshapeAction_Rename extends Message<ReshapeAction_Rename> {
  /**
   * @generated from field: string new_name = 10;
   */
  newName: string;

  constructor(data?: PartialMessage<ReshapeAction_Rename>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.Rename";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_Rename;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_Rename;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_Rename;

  static equals(a: ReshapeAction_Rename | PlainMessage<ReshapeAction_Rename> | undefined, b: ReshapeAction_Rename | PlainMessage<ReshapeAction_Rename> | undefined): boolean;
}

/**
 * add a static value to field's current value.
 *
 * legal: numbers, currency, timestamp, time, date
 *
 * @generated from message api.v0alpha.ReshapeAction.AddValue
 */
export declare class ReshapeAction_AddValue extends Message<ReshapeAction_AddValue> {
  /**
   * if the field type is time-like, this is number of seconds
   *
   * @generated from field: double value = 11;
   */
  value: number;

  constructor(data?: PartialMessage<ReshapeAction_AddValue>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.AddValue";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_AddValue;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_AddValue;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_AddValue;

  static equals(a: ReshapeAction_AddValue | PlainMessage<ReshapeAction_AddValue> | undefined, b: ReshapeAction_AddValue | PlainMessage<ReshapeAction_AddValue> | undefined): boolean;
}

/**
 * add or subtract a datetime modifier to the field
 *
 * @generated from message api.v0alpha.ReshapeAction.AddDate
 */
export declare class ReshapeAction_AddDate extends Message<ReshapeAction_AddDate> {
  /**
   * @generated from field: api.v0alpha.DateTimeModifier datetime = 45;
   */
  datetime?: DateTimeModifier;

  constructor(data?: PartialMessage<ReshapeAction_AddDate>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.AddDate";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_AddDate;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_AddDate;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_AddDate;

  static equals(a: ReshapeAction_AddDate | PlainMessage<ReshapeAction_AddDate> | undefined, b: ReshapeAction_AddDate | PlainMessage<ReshapeAction_AddDate> | undefined): boolean;
}

/**
 * add two fields values together. If field is time-like, other_field must be
 * either number or timestamp
 *
 * legal: numbers, currency, timestamp, time, date
 *
 * @generated from message api.v0alpha.ReshapeAction.AddField
 */
export declare class ReshapeAction_AddField extends Message<ReshapeAction_AddField> {
  /**
   * @generated from field: api.v0alpha.FieldIndex other_field = 12;
   */
  otherField?: FieldIndex;

  constructor(data?: PartialMessage<ReshapeAction_AddField>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.AddField";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_AddField;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_AddField;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_AddField;

  static equals(a: ReshapeAction_AddField | PlainMessage<ReshapeAction_AddField> | undefined, b: ReshapeAction_AddField | PlainMessage<ReshapeAction_AddField> | undefined): boolean;
}

/**
 * subtract a static value to field's current value
 *
 * legal: numbers, currency, timestamp, time, date
 *
 * @generated from message api.v0alpha.ReshapeAction.SubtractValue
 */
export declare class ReshapeAction_SubtractValue extends Message<ReshapeAction_SubtractValue> {
  /**
   * if the field type is time-like, this is number of seconds
   *
   * @generated from field: double value = 11;
   */
  value: number;

  constructor(data?: PartialMessage<ReshapeAction_SubtractValue>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.SubtractValue";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_SubtractValue;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_SubtractValue;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_SubtractValue;

  static equals(a: ReshapeAction_SubtractValue | PlainMessage<ReshapeAction_SubtractValue> | undefined, b: ReshapeAction_SubtractValue | PlainMessage<ReshapeAction_SubtractValue> | undefined): boolean;
}

/**
 * subtract two fields values. If field is time-like, other_field must be
 * either number or timestamp
 *
 * legal: numbers, currency, timestamp, time, date
 *
 * @generated from message api.v0alpha.ReshapeAction.SubtractField
 */
export declare class ReshapeAction_SubtractField extends Message<ReshapeAction_SubtractField> {
  /**
   * @generated from field: api.v0alpha.FieldIndex other_field = 12;
   */
  otherField?: FieldIndex;

  constructor(data?: PartialMessage<ReshapeAction_SubtractField>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.SubtractField";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_SubtractField;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_SubtractField;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_SubtractField;

  static equals(a: ReshapeAction_SubtractField | PlainMessage<ReshapeAction_SubtractField> | undefined, b: ReshapeAction_SubtractField | PlainMessage<ReshapeAction_SubtractField> | undefined): boolean;
}

/**
 * convert a field to another type, if conversion fails, it will be an error
 * type
 *
 * @generated from message api.v0alpha.ReshapeAction.Convert
 */
export declare class ReshapeAction_Convert extends Message<ReshapeAction_Convert> {
  /**
   * @generated from field: api.commons.RecordType newType = 17 [deprecated = true];
   * @deprecated
   */
  newType: RecordType;

  /**
   * @generated from field: api.v0alpha.Field new_field = 18;
   */
  newField?: Field;

  /**
   * @generated from field: api.v0alpha.RecordFieldProto default_value = 19;
   */
  defaultValue?: RecordFieldProto;

  constructor(data?: PartialMessage<ReshapeAction_Convert>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.Convert";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_Convert;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_Convert;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_Convert;

  static equals(a: ReshapeAction_Convert | PlainMessage<ReshapeAction_Convert> | undefined, b: ReshapeAction_Convert | PlainMessage<ReshapeAction_Convert> | undefined): boolean;
}

/**
 * Represents a message for division operation.
 *
 * @generated from message api.v0alpha.ReshapeAction.Divide
 */
export declare class ReshapeAction_Divide extends Message<ReshapeAction_Divide> {
  /**
   * The default value to be used if no other value is provided.
   *
   * @generated from field: double default_value = 1;
   */
  defaultValue: number;

  /**
   * The divisor to be used for the division operation.
   *
   * @generated from field: double divisor = 2;
   */
  divisor: number;

  constructor(data?: PartialMessage<ReshapeAction_Divide>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.Divide";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_Divide;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_Divide;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_Divide;

  static equals(a: ReshapeAction_Divide | PlainMessage<ReshapeAction_Divide> | undefined, b: ReshapeAction_Divide | PlainMessage<ReshapeAction_Divide> | undefined): boolean;
}

/**
 * Represents a message for multiplication operation.
 *
 * @generated from message api.v0alpha.ReshapeAction.Multiply
 */
export declare class ReshapeAction_Multiply extends Message<ReshapeAction_Multiply> {
  /**
   * The default value to be used if no other value is provided.
   *
   * @generated from field: double default_value = 1;
   */
  defaultValue: number;

  /**
   * The multiplier to be used for the multiplication operation.
   *
   * @generated from field: double multiplier = 2;
   */
  multiplier: number;

  constructor(data?: PartialMessage<ReshapeAction_Multiply>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.Multiply";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_Multiply;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_Multiply;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_Multiply;

  static equals(a: ReshapeAction_Multiply | PlainMessage<ReshapeAction_Multiply> | undefined, b: ReshapeAction_Multiply | PlainMessage<ReshapeAction_Multiply> | undefined): boolean;
}

/**
 * Represents a message for modulo operation.
 *
 * @generated from message api.v0alpha.ReshapeAction.Modulo
 */
export declare class ReshapeAction_Modulo extends Message<ReshapeAction_Modulo> {
  /**
   * The default value to be used if no other value is provided.
   *
   * @generated from field: int32 default_value = 1;
   */
  defaultValue: number;

  /**
   * The modulus to be used for the modulo operation.
   *
   * @generated from field: int32 modulus = 2;
   */
  modulus: number;

  constructor(data?: PartialMessage<ReshapeAction_Modulo>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.Modulo";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_Modulo;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_Modulo;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_Modulo;

  static equals(a: ReshapeAction_Modulo | PlainMessage<ReshapeAction_Modulo> | undefined, b: ReshapeAction_Modulo | PlainMessage<ReshapeAction_Modulo> | undefined): boolean;
}

/**
 * will remove "field" from the record
 *
 * @generated from message api.v0alpha.ReshapeAction.RemoveField
 */
export declare class ReshapeAction_RemoveField extends Message<ReshapeAction_RemoveField> {
  constructor(data?: PartialMessage<ReshapeAction_RemoveField>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.RemoveField";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_RemoveField;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_RemoveField;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_RemoveField;

  static equals(a: ReshapeAction_RemoveField | PlainMessage<ReshapeAction_RemoveField> | undefined, b: ReshapeAction_RemoveField | PlainMessage<ReshapeAction_RemoveField> | undefined): boolean;
}

/**
 * will add "field" to the record with default starting value
 * TODO: make a RecordFieldProtoValue, it is a noeof
 *
 * @generated from message api.v0alpha.ReshapeAction.AddNewField
 */
export declare class ReshapeAction_AddNewField extends Message<ReshapeAction_AddNewField> {
  /**
   * @generated from field: api.v0alpha.RecordFieldProto starting_value = 18;
   */
  startingValue?: RecordFieldProto;

  constructor(data?: PartialMessage<ReshapeAction_AddNewField>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.AddNewField";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_AddNewField;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_AddNewField;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_AddNewField;

  static equals(a: ReshapeAction_AddNewField | PlainMessage<ReshapeAction_AddNewField> | undefined, b: ReshapeAction_AddNewField | PlainMessage<ReshapeAction_AddNewField> | undefined): boolean;
}

/**
 * will add "field" to the record with default starting value from other field
 *
 * @generated from message api.v0alpha.ReshapeAction.AddNewFieldFromField
 */
export declare class ReshapeAction_AddNewFieldFromField extends Message<ReshapeAction_AddNewFieldFromField> {
  /**
   * @generated from field: string name = 10;
   */
  name: string;

  /**
   * @generated from field: api.v0alpha.FieldIndex other_field = 12;
   */
  otherField?: FieldIndex;

  constructor(data?: PartialMessage<ReshapeAction_AddNewFieldFromField>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.AddNewFieldFromField";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_AddNewFieldFromField;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_AddNewFieldFromField;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_AddNewFieldFromField;

  static equals(a: ReshapeAction_AddNewFieldFromField | PlainMessage<ReshapeAction_AddNewFieldFromField> | undefined, b: ReshapeAction_AddNewFieldFromField | PlainMessage<ReshapeAction_AddNewFieldFromField> | undefined): boolean;
}

/**
 * change the currency value to one represented
 *
 * legal: Currency
 *
 * @generated from message api.v0alpha.ReshapeAction.ChangeCurrencyType
 */
export declare class ReshapeAction_ChangeCurrencyType extends Message<ReshapeAction_ChangeCurrencyType> {
  constructor(data?: PartialMessage<ReshapeAction_ChangeCurrencyType>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.ChangeCurrencyType";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_ChangeCurrencyType;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_ChangeCurrencyType;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_ChangeCurrencyType;

  static equals(a: ReshapeAction_ChangeCurrencyType | PlainMessage<ReshapeAction_ChangeCurrencyType> | undefined, b: ReshapeAction_ChangeCurrencyType | PlainMessage<ReshapeAction_ChangeCurrencyType> | undefined): boolean;
}

/**
 * will set field with the value
 *
 * @generated from message api.v0alpha.ReshapeAction.SetFieldValue
 */
export declare class ReshapeAction_SetFieldValue extends Message<ReshapeAction_SetFieldValue> {
  /**
   * @generated from field: api.v0alpha.RecordFieldProto value = 18;
   */
  value?: RecordFieldProto;

  constructor(data?: PartialMessage<ReshapeAction_SetFieldValue>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.SetFieldValue";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_SetFieldValue;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_SetFieldValue;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_SetFieldValue;

  static equals(a: ReshapeAction_SetFieldValue | PlainMessage<ReshapeAction_SetFieldValue> | undefined, b: ReshapeAction_SetFieldValue | PlainMessage<ReshapeAction_SetFieldValue> | undefined): boolean;
}

/**
 * will set "field" from other field
 *
 * @generated from message api.v0alpha.ReshapeAction.SetFieldFromField
 */
export declare class ReshapeAction_SetFieldFromField extends Message<ReshapeAction_SetFieldFromField> {
  /**
   * @generated from field: string name = 10;
   */
  name: string;

  /**
   * @generated from field: api.v0alpha.FieldIndex other_field = 12;
   */
  otherField?: FieldIndex;

  constructor(data?: PartialMessage<ReshapeAction_SetFieldFromField>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.SetFieldFromField";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_SetFieldFromField;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_SetFieldFromField;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_SetFieldFromField;

  static equals(a: ReshapeAction_SetFieldFromField | PlainMessage<ReshapeAction_SetFieldFromField> | undefined, b: ReshapeAction_SetFieldFromField | PlainMessage<ReshapeAction_SetFieldFromField> | undefined): boolean;
}

/**
 * merges together all the strings fetched from FieldOrVal into the reshape
 * action field. overrides any data already in the field.
 *
 * Legal: StringValue
 *
 * @generated from message api.v0alpha.ReshapeAction.Merge
 */
export declare class ReshapeAction_Merge extends Message<ReshapeAction_Merge> {
  /**
   * @generated from field: repeated api.v0alpha.ReshapeAction.Merge.FieldOrVal data = 44;
   */
  data: ReshapeAction_Merge_FieldOrVal[];

  constructor(data?: PartialMessage<ReshapeAction_Merge>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.Merge";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_Merge;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_Merge;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_Merge;

  static equals(a: ReshapeAction_Merge | PlainMessage<ReshapeAction_Merge> | undefined, b: ReshapeAction_Merge | PlainMessage<ReshapeAction_Merge> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ReshapeAction.Merge.FieldOrVal
 */
export declare class ReshapeAction_Merge_FieldOrVal extends Message<ReshapeAction_Merge_FieldOrVal> {
  /**
   * @generated from oneof api.v0alpha.ReshapeAction.Merge.FieldOrVal.val
   */
  val: {
    /**
     * fetch the string from this field
     *
     * @generated from field: api.v0alpha.FieldIndex field = 38;
     */
    value: FieldIndex;
    case: "field";
  } | {
    /**
     * use this exact string value
     *
     * @generated from field: string value = 43;
     */
    value: string;
    case: "value";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<ReshapeAction_Merge_FieldOrVal>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.Merge.FieldOrVal";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_Merge_FieldOrVal;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_Merge_FieldOrVal;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_Merge_FieldOrVal;

  static equals(a: ReshapeAction_Merge_FieldOrVal | PlainMessage<ReshapeAction_Merge_FieldOrVal> | undefined, b: ReshapeAction_Merge_FieldOrVal | PlainMessage<ReshapeAction_Merge_FieldOrVal> | undefined): boolean;
}

/**
 * provide padding to the right or left of the string field
 *
 * @generated from message api.v0alpha.ReshapeAction.Pad
 */
export declare class ReshapeAction_Pad extends Message<ReshapeAction_Pad> {
  /**
   * what character to pad with.  Must be length 1.
   *
   * @generated from field: string char = 10;
   */
  char: string;

  /**
   * what the desired length of the string is.
   * if < 0 we will use the len of the longest string in the column
   *
   * @generated from field: int32 amount = 12;
   */
  amount: number;

  /**
   * prefixorsuffix
   *
   * @generated from field: bool prefix = 13;
   */
  prefix: boolean;

  constructor(data?: PartialMessage<ReshapeAction_Pad>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.Pad";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_Pad;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_Pad;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_Pad;

  static equals(a: ReshapeAction_Pad | PlainMessage<ReshapeAction_Pad> | undefined, b: ReshapeAction_Pad | PlainMessage<ReshapeAction_Pad> | undefined): boolean;
}

/**
 * trims off specific characters from a prefix or suffix.
 * Or can trim off a certain amount of characters from the left or right.
 *
 * @generated from message api.v0alpha.ReshapeAction.Trim
 */
export declare class ReshapeAction_Trim extends Message<ReshapeAction_Trim> {
  /**
   * @generated from oneof api.v0alpha.ReshapeAction.Trim.opt
   */
  opt: {
    /**
     * trim this exact amount of chars. If the string is less than amount in length
     * the string is set to the empty string
     * examples:
     * - trim.amount = 3 on 'abcdef' => 'def'
     * - trim.amount = 3 on 'ab' => ''
     *
     * @generated from field: int32 amount = 1;
     */
    value: number;
    case: "amount";
  } | {
    /**
     * trim this specific string from the field if it exists, otherwise do nothing
     * examples:
     * - trim.data = 'abc' on 'abcdef' => 'def'
     * - trim.data = 'abc' on 'ab' => 'ab'
     *
     * @generated from field: string data = 2;
     */
    value: string;
    case: "data";
  } | {
    /**
     * trim til this specific marker. If marker doesn't exist string is left alone
     * examples:
     * - trim.marker = 'de' on 'abcdef' = 'def'
     *
     * @generated from field: string marker = 3;
     */
    value: string;
    case: "marker";
  } | { case: undefined; value?: undefined };

  /**
   * if true, the trim operation starts at the end of the string and works backwards
   *
   * @generated from field: bool suffix = 10;
   */
  suffix: boolean;

  constructor(data?: PartialMessage<ReshapeAction_Trim>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.Trim";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_Trim;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_Trim;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_Trim;

  static equals(a: ReshapeAction_Trim | PlainMessage<ReshapeAction_Trim> | undefined, b: ReshapeAction_Trim | PlainMessage<ReshapeAction_Trim> | undefined): boolean;
}

/**
 * extract takes a string and can take any combination of substrings of the string
 *
 * @generated from message api.v0alpha.ReshapeAction.Extract
 */
export declare class ReshapeAction_Extract extends Message<ReshapeAction_Extract> {
  /**
   * parts represents several substrings using indices
   *
   * @generated from field: repeated api.v0alpha.ReshapeAction.Extract.Slice parts = 39;
   */
  parts: ReshapeAction_Extract_Slice[];

  constructor(data?: PartialMessage<ReshapeAction_Extract>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.Extract";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_Extract;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_Extract;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_Extract;

  static equals(a: ReshapeAction_Extract | PlainMessage<ReshapeAction_Extract> | undefined, b: ReshapeAction_Extract | PlainMessage<ReshapeAction_Extract> | undefined): boolean;
}

/**
 * represents an index. can be a string or a number
 *
 * @generated from message api.v0alpha.ReshapeAction.Extract.Index
 */
export declare class ReshapeAction_Extract_Index extends Message<ReshapeAction_Extract_Index> {
  /**
   * @generated from oneof api.v0alpha.ReshapeAction.Extract.Index.val
   */
  val: {
    /**
     * the base 0 index of the string
     *
     * @generated from field: int32 position = 12;
     */
    value: number;
    case: "position";
  } | {
    /**
     * an index matching the substring. Starting at the beginning of the substring
     *
     * @generated from field: string match = 43;
     */
    value: string;
    case: "match";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<ReshapeAction_Extract_Index>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.Extract.Index";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_Extract_Index;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_Extract_Index;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_Extract_Index;

  static equals(a: ReshapeAction_Extract_Index | PlainMessage<ReshapeAction_Extract_Index> | undefined, b: ReshapeAction_Extract_Index | PlainMessage<ReshapeAction_Extract_Index> | undefined): boolean;
}

/**
 * Slice represents a part of a string. think of a python or golang slice operator
 * where the new substring starts at the starting index and ends at the ending index exclusively
 *
 * @generated from message api.v0alpha.ReshapeAction.Extract.Slice
 */
export declare class ReshapeAction_Extract_Slice extends Message<ReshapeAction_Extract_Slice> {
  /**
   * the default inclusivity is [start, end)
   * this marks whether to not include the start_index marker in the slice
   *
   * @generated from field: bool start_is_exclusive = 13;
   */
  startIsExclusive: boolean;

  /**
   * this marks whether to include the end_index marker in the slice
   *
   * @generated from field: bool end_is_inclusive = 14;
   */
  endIsInclusive: boolean;

  /**
   * start index marks where to start the slice at. can be a string or number
   * subsequent indexes are backup indexes incase the first doesn't exist
   *
   * @generated from field: repeated api.v0alpha.ReshapeAction.Extract.Index start_index = 35;
   */
  startIndex: ReshapeAction_Extract_Index[];

  /**
   * end index marks where to start the slice at. can be a string or number
   * subsequent indexes are backup indexes incase the first doesn't exist
   *
   * @generated from field: repeated api.v0alpha.ReshapeAction.Extract.Index end_index = 36;
   */
  endIndex: ReshapeAction_Extract_Index[];

  constructor(data?: PartialMessage<ReshapeAction_Extract_Slice>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ReshapeAction.Extract.Slice";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshapeAction_Extract_Slice;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshapeAction_Extract_Slice;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshapeAction_Extract_Slice;

  static equals(a: ReshapeAction_Extract_Slice | PlainMessage<ReshapeAction_Extract_Slice> | undefined, b: ReshapeAction_Extract_Slice | PlainMessage<ReshapeAction_Extract_Slice> | undefined): boolean;
}

/**
 * stored as json in lms_history table
 *
 * @generated from message api.v0alpha.ListMetrics
 */
export declare class ListMetrics extends Message<ListMetrics> {
  /**
   * signifies how many records existed at the beginning of the operation
   *
   * @generated from field: int32 input_record_count = 1;
   */
  inputRecordCount: number;

  /**
   * how many records existed on the element at the end of the operation
   *
   * @generated from field: int32 output_record_count = 2;
   */
  outputRecordCount: number;

  /**
   * all the field names that exist in the list
   *
   * @generated from field: repeated string field_names = 3;
   */
  fieldNames: string[];

  /**
   * all the field types that exist. field_types[i] has a name of field_names[i].
   * THeir indexes match up
   *
   * @generated from field: repeated api.commons.RecordType field_types = 4 [deprecated = true];
   * @deprecated
   */
  fieldTypes: RecordType[];

  /**
   * @generated from field: repeated api.commons.FieldType ftypes = 18;
   */
  ftypes: FieldType[];

  /**
   * the counts of the field_name[i], field_type[i] pairs.
   * ex: if field_name[i] == 'test' and field_types[i] == record_type_err, and field_counts[i] == 10
   * means we woud have 10 fiels named test that were error types in the list.
   *
   * @generated from field: repeated int32 field_counts = 5;
   */
  fieldCounts: number[];

  /**
   * the run type for the exchange.  Will only mean anything if the element is an exchange.
   *
   * @generated from field: api.commons.RunType run_type = 6;
   */
  runType: RunType;

  /**
   * will contain the http post response body from the POST request to p3 backoffice
   * only relevent on p3 exchange elements.
   *
   * @generated from field: string success_message = 7;
   */
  successMessage: string;

  /**
   * specifies the number of fields the largest record had in the list.
   * ex: max_record_width of 10 means that there exists at least 1 record in the list had 10 fields.
   * meta fields (fields that start with an '_') are not counted
   *
   * @generated from field: int32 max_record_width = 8;
   */
  maxRecordWidth: number;

  /**
   * opposite of max_record_width
   *
   * @generated from field: int32 min_record_width = 9;
   */
  minRecordWidth: number;

  /**
   * the first index we can find the record with max_record_width fields
   *
   * @generated from field: int32 max_record_index = 10;
   */
  maxRecordIndex: number;

  /**
   * the first index we can find the record with min_record_width fields
   *
   * @generated from field: int32 min_record_index = 11;
   */
  minRecordIndex: number;

  /**
   * the upstream files that were used to process this element.
   * usually this field will either be empty, or have 1 item in it.
   *
   * @generated from field: repeated string files = 12;
   */
  files: string[];

  /**
   * which groups exist in the list.
   * a group is a tagged record with a field '_group' and a string payload
   *
   * @generated from field: repeated string groups = 13;
   */
  groups: string[];

  /**
   * represents which fields were looked up, but were missing from the record
   * this is the set of all missing fields
   *
   * @generated from field: repeated string missing_fields = 15;
   */
  missingFields: string[];

  /**
   * represents how many seconds it took for the event to start getting worked on
   *
   * @generated from field: double seconds_to_start = 16;
   */
  secondsToStart: number;

  /**
   * represents how mahy seconds it took to process the event
   *
   * @generated from field: double seconds_to_process = 17;
   */
  secondsToProcess: number;

  constructor(data?: PartialMessage<ListMetrics>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ListMetrics";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListMetrics;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListMetrics;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListMetrics;

  static equals(a: ListMetrics | PlainMessage<ListMetrics> | undefined, b: ListMetrics | PlainMessage<ListMetrics> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ParseReq
 */
export declare class ParseReq extends Message<ParseReq> {
  /**
   * if empty, we will use GetAvailableFields instead of
   * ListAvailableFieldsByElementId
   *
   * @generated from field: string element_id = 3;
   */
  elementId: string;

  /**
   * if empty, a new session will be returned with the response
   *
   * @generated from field: string session_id = 4;
   */
  sessionId: string;

  /**
   * current expression string, can be empty
   *
   * @generated from field: string expression = 5;
   */
  expression: string;

  constructor(data?: PartialMessage<ParseReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ParseReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ParseReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ParseReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ParseReq;

  static equals(a: ParseReq | PlainMessage<ParseReq> | undefined, b: ParseReq | PlainMessage<ParseReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ParseRes
 */
export declare class ParseRes extends Message<ParseRes> {
  /**
   * the session_id should be returned on future requests to make things faster
   *
   * @generated from field: string session_id = 1;
   */
  sessionId: string;

  /**
   * @generated from field: string expression = 2;
   */
  expression: string;

  /**
   * a list of valid tokens we can use at this point
   *
   * @generated from field: repeated string next_tokens = 3;
   */
  nextTokens: string[];

  /**
   * if not a valid expression, error should have the message why
   *
   * @generated from field: string error = 5;
   */
  error: string;

  /**
   * whether the result_expression is complete
   *
   * @generated from field: bool complete = 6;
   */
  complete: boolean;

  /**
   * if complete is true, process will have a completed Process defined.
   * if complete is true, you will be able to send process to lms_api through
   * CreatePipelineElement.
   *
   * @generated from field: api.v0alpha.Process process = 7;
   */
  process?: Process;

  constructor(data?: PartialMessage<ParseRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ParseRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ParseRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ParseRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ParseRes;

  static equals(a: ParseRes | PlainMessage<ParseRes> | undefined, b: ParseRes | PlainMessage<ParseRes> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.Event
 */
export declare class Event extends Message<Event> {
  /**
   * pk
   *
   * @generated from field: int64 event_id = 3;
   */
  eventId: bigint;

  /**
   * element_id that created this event (nil if its an upload, or sftp_import)
   *
   * @generated from field: google.protobuf.StringValue parent_id = 5;
   */
  parentId?: string;

  /**
   * other inputs to this event
   *
   * @generated from field: api.commons.StringArraySql input_ids = 6;
   */
  inputIds?: StringArraySql;

  /**
   * @generated from field: string element_id = 7;
   */
  elementId: string;

  /**
   * @generated from field: api.v0alpha.Process process = 9;
   */
  process?: Process;

  /**
   * when this event got to the database
   *
   * @generated from field: google.protobuf.Timestamp upload_ts = 10;
   */
  uploadTs?: Timestamp$1;

  /**
   * when the scheduler started processing (could be nil if not started)
   *
   * @generated from field: google.protobuf.Timestamp started_ts = 11;
   */
  startedTs?: Timestamp$1;

  /**
   * processing finished (could be nil if not finished)
   *
   * @generated from field: google.protobuf.Timestamp finished_ts = 12;
   */
  finishedTs?: Timestamp$1;

  /**
   * (not used yet, so always nil) event wont be attempted till after this time
   *
   * @generated from field: google.protobuf.Timestamp backoff_till = 13;
   */
  backoffTill?: Timestamp$1;

  /**
   * how many attempts this event is taking
   *
   * @generated from field: int32 attempts = 14;
   */
  attempts: number;

  /**
   * which hisotry record this event maps to. (only populated if finished_ts is
   * not nil)
   *
   * @generated from field: google.protobuf.Int64Value latest_history = 15;
   */
  latestHistory?: bigint;

  constructor(data?: PartialMessage<Event>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.Event";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Event;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Event;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Event;

  static equals(a: Event | PlainMessage<Event> | undefined, b: Event | PlainMessage<Event> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.Events
 */
export declare class Events extends Message<Events> {
  /**
   * @generated from field: repeated api.v0alpha.Event events = 1;
   */
  events: Event[];

  constructor(data?: PartialMessage<Events>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.Events";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Events;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Events;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Events;

  static equals(a: Events | PlainMessage<Events> | undefined, b: Events | PlainMessage<Events> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ViewQueueReq
 */
export declare class ViewQueueReq extends Message<ViewQueueReq> {
  /**
   * return events with upload_ts times newer than this timestamp
   *
   * @generated from field: google.protobuf.Timestamp newer_than = 1;
   */
  newerThan?: Timestamp$1;

  /**
   * do not return events with upload_ts times newer than this timestamp
   *
   * @generated from field: google.protobuf.Timestamp no_newer_than = 2;
   */
  noNewerThan?: Timestamp$1;

  /**
   * skip records with event_id smaller than this id
   *
   * @generated from field: int64 after_event_id = 3;
   */
  afterEventId: bigint;

  /**
   * max number of records to retrieve
   *
   * @generated from field: int64 number_of_records = 4;
   */
  numberOfRecords: bigint;

  constructor(data?: PartialMessage<ViewQueueReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ViewQueueReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ViewQueueReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ViewQueueReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ViewQueueReq;

  static equals(a: ViewQueueReq | PlainMessage<ViewQueueReq> | undefined, b: ViewQueueReq | PlainMessage<ViewQueueReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.CollectionMetadata
 */
export declare class CollectionMetadata extends Message<CollectionMetadata> {
  /**
   * Name and ID of the collection
   *
   * @generated from field: string collection_id = 3;
   */
  collectionId: string;

  /**
   * @generated from field: string collection_name = 4;
   */
  collectionName: string;

  /**
   * Describes the fields used by the collection
   *
   * @generated from field: repeated api.v0alpha.CollectionFieldMetadata fields = 5;
   */
  fields: CollectionFieldMetadata[];

  /**
   * @generated from field: bool deleted = 6;
   */
  deleted: boolean;

  /**
   * @generated from field: string created_by = 7;
   */
  createdBy: string;

  /**
   * @generated from field: google.protobuf.Timestamp created_on = 8;
   */
  createdOn?: Timestamp$1;

  /**
   * @generated from field: google.protobuf.Timestamp last_queried = 9;
   */
  lastQueried?: Timestamp$1;

  /**
   * @generated from field: int64 query_count = 10;
   */
  queryCount: bigint;

  /**
   * @generated from field: int64 entry_count = 11;
   */
  entryCount: bigint;

  /**
   * @generated from field: google.protobuf.Timestamp last_updated = 12;
   */
  lastUpdated?: Timestamp$1;

  /**
   * @generated from field: int64 search_count = 13;
   */
  searchCount: bigint;

  /**
   * @generated from field: google.protobuf.Timestamp last_searched = 14;
   */
  lastSearched?: Timestamp$1;

  constructor(data?: PartialMessage<CollectionMetadata>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.CollectionMetadata";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionMetadata;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionMetadata;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionMetadata;

  static equals(a: CollectionMetadata | PlainMessage<CollectionMetadata> | undefined, b: CollectionMetadata | PlainMessage<CollectionMetadata> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.CollectionEntry
 */
export declare class CollectionEntry extends Message<CollectionEntry> {
  /**
   * @generated from field: string collection_id = 3;
   */
  collectionId: string;

  /**
   * @generated from field: string entry_id = 4;
   */
  entryId: string;

  /**
   * @generated from field: repeated api.v0alpha.CollectionField fields = 5;
   */
  fields: CollectionField[];

  /**
   * @generated from field: google.protobuf.Timestamp last_updated = 6;
   */
  lastUpdated?: Timestamp$1;

  constructor(data?: PartialMessage<CollectionEntry>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.CollectionEntry";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionEntry;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionEntry;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionEntry;

  static equals(a: CollectionEntry | PlainMessage<CollectionEntry> | undefined, b: CollectionEntry | PlainMessage<CollectionEntry> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.MatchReq
 */
export declare class MatchReq extends Message<MatchReq> {
  /**
   * @generated from field: string collection_id = 3;
   */
  collectionId: string;

  /**
   * @generated from field: repeated api.v0alpha.CollectionField fields = 4;
   */
  fields: CollectionField[];

  /**
   * @generated from field: int64 batch_size = 5;
   */
  batchSize: bigint;

  constructor(data?: PartialMessage<MatchReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.MatchReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MatchReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MatchReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MatchReq;

  static equals(a: MatchReq | PlainMessage<MatchReq> | undefined, b: MatchReq | PlainMessage<MatchReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.MatchRes
 */
export declare class MatchRes extends Message<MatchRes> {
  /**
   * @generated from field: repeated api.v0alpha.CollectionEntry entries = 1;
   */
  entries: CollectionEntry[];

  constructor(data?: PartialMessage<MatchRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.MatchRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MatchRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MatchRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MatchRes;

  static equals(a: MatchRes | PlainMessage<MatchRes> | undefined, b: MatchRes | PlainMessage<MatchRes> | undefined): boolean;
}

/**
 * Metadata associated with a field
 *
 * @generated from message api.v0alpha.CollectionFieldMetadata
 */
export declare class CollectionFieldMetadata extends Message<CollectionFieldMetadata> {
  /**
   * @generated from field: string field_name = 1;
   */
  fieldName: string;

  /**
   * @generated from field: api.commons.FieldType field_type = 2;
   */
  fieldType: FieldType;

  /**
   * Optional field
   * Specifies formating for the field
   * e.g. for a datetime it might be
   * something like "MM/DD/YYYY hh:mm:ss"
   *
   * @generated from field: string field_format = 3;
   */
  fieldFormat: string;

  constructor(data?: PartialMessage<CollectionFieldMetadata>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.CollectionFieldMetadata";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionFieldMetadata;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionFieldMetadata;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionFieldMetadata;

  static equals(a: CollectionFieldMetadata | PlainMessage<CollectionFieldMetadata> | undefined, b: CollectionFieldMetadata | PlainMessage<CollectionFieldMetadata> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.CollectionField
 */
export declare class CollectionField extends Message<CollectionField> {
  /**
   * @generated from field: string field_name = 1;
   */
  fieldName: string;

  /**
   * @generated from field: string field_value = 2;
   */
  fieldValue: string;

  constructor(data?: PartialMessage<CollectionField>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.CollectionField";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionField;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionField;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionField;

  static equals(a: CollectionField | PlainMessage<CollectionField> | undefined, b: CollectionField | PlainMessage<CollectionField> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.GetCollectionReq
 */
export declare class GetCollectionReq extends Message<GetCollectionReq> {
  /**
   * @generated from field: string collection_id = 3;
   */
  collectionId: string;

  constructor(data?: PartialMessage<GetCollectionReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.GetCollectionReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCollectionReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCollectionReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCollectionReq;

  static equals(a: GetCollectionReq | PlainMessage<GetCollectionReq> | undefined, b: GetCollectionReq | PlainMessage<GetCollectionReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.StreamCollectionReq
 */
export declare class StreamCollectionReq extends Message<StreamCollectionReq> {
  /**
   * @generated from field: string collection_id = 3;
   */
  collectionId: string;

  constructor(data?: PartialMessage<StreamCollectionReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.StreamCollectionReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamCollectionReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamCollectionReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamCollectionReq;

  static equals(a: StreamCollectionReq | PlainMessage<StreamCollectionReq> | undefined, b: StreamCollectionReq | PlainMessage<StreamCollectionReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.DeleteCollectionReq
 */
export declare class DeleteCollectionReq extends Message<DeleteCollectionReq> {
  /**
   * @generated from field: string collection_id = 3;
   */
  collectionId: string;

  constructor(data?: PartialMessage<DeleteCollectionReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.DeleteCollectionReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteCollectionReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteCollectionReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteCollectionReq;

  static equals(a: DeleteCollectionReq | PlainMessage<DeleteCollectionReq> | undefined, b: DeleteCollectionReq | PlainMessage<DeleteCollectionReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ResetCollectionReq
 */
export declare class ResetCollectionReq extends Message<ResetCollectionReq> {
  /**
   * @generated from field: string collection_id = 3;
   */
  collectionId: string;

  constructor(data?: PartialMessage<ResetCollectionReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ResetCollectionReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResetCollectionReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResetCollectionReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResetCollectionReq;

  static equals(a: ResetCollectionReq | PlainMessage<ResetCollectionReq> | undefined, b: ResetCollectionReq | PlainMessage<ResetCollectionReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ListCollectionsReq
 */
export declare class ListCollectionsReq extends Message<ListCollectionsReq> {
  constructor(data?: PartialMessage<ListCollectionsReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ListCollectionsReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListCollectionsReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListCollectionsReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListCollectionsReq;

  static equals(a: ListCollectionsReq | PlainMessage<ListCollectionsReq> | undefined, b: ListCollectionsReq | PlainMessage<ListCollectionsReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ListCollectionsRes
 */
export declare class ListCollectionsRes extends Message<ListCollectionsRes> {
  /**
   * @generated from field: repeated api.v0alpha.CollectionMetadata collections = 1;
   */
  collections: CollectionMetadata[];

  constructor(data?: PartialMessage<ListCollectionsRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ListCollectionsRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListCollectionsRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListCollectionsRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListCollectionsRes;

  static equals(a: ListCollectionsRes | PlainMessage<ListCollectionsRes> | undefined, b: ListCollectionsRes | PlainMessage<ListCollectionsRes> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.SearchCollectionsPaginatedReq
 */
export declare class SearchCollectionsPaginatedReq extends Message<SearchCollectionsPaginatedReq> {
  /**
   * Specifies which collections we are searching in
   * If empty it will search all collections.
   *
   * @generated from field: repeated string collection_ids = 3;
   */
  collectionIds: string[];

  /**
   * Specifies what we are searching for
   *
   * @generated from field: api.v0alpha.Search search = 4;
   */
  search?: Search;

  /**
   * Specifies where to start in the results
   *
   * @generated from field: int64 from = 5;
   */
  from: bigint;

  /**
   * How many results to include in a page
   *
   * @generated from field: int64 page_size = 6;
   */
  pageSize: bigint;

  constructor(data?: PartialMessage<SearchCollectionsPaginatedReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.SearchCollectionsPaginatedReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchCollectionsPaginatedReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchCollectionsPaginatedReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchCollectionsPaginatedReq;

  static equals(a: SearchCollectionsPaginatedReq | PlainMessage<SearchCollectionsPaginatedReq> | undefined, b: SearchCollectionsPaginatedReq | PlainMessage<SearchCollectionsPaginatedReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.Search
 */
export declare class Search extends Message<Search> {
  /**
   * The term we are searching for
   *
   * @generated from field: string term = 1;
   */
  term: string;

  /**
   * Sets the amount of fuzziness allowed
   * in matches
   * Example:
   * Searching "term" would also match "temr"
   * Not compatible with a substring match
   *
   * @generated from field: int64 fuzziness = 2;
   */
  fuzziness: bigint;

  /**
   * Checks if a subset of the content matches
   * Example:
   * Searching "but" would also match "rebuttal"
   * Not compatible with fuzziness (will override fuzziness)
   *
   * @generated from field: bool substring = 3;
   */
  substring: boolean;

  /**
   * Specifies if the search should be negated
   * Example:
   * Searching "term" would match everything NOT including "term"
   *
   * @generated from field: bool negate = 4;
   */
  negate: boolean;

  /**
   * Specifies if we should be case sensitive
   *
   * @generated from field: bool case_sensitive = 5;
   */
  caseSensitive: boolean;

  constructor(data?: PartialMessage<Search>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.Search";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Search;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Search;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Search;

  static equals(a: Search | PlainMessage<Search> | undefined, b: Search | PlainMessage<Search> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.PaginatedSearchRes
 */
export declare class PaginatedSearchRes extends Message<PaginatedSearchRes> {
  /**
   * A page of results
   *
   * @generated from field: repeated api.v0alpha.CollectionEntry entries = 1;
   */
  entries: CollectionEntry[];

  /**
   * Specifies the total number of results
   *
   * @generated from field: int64 total = 2;
   */
  total: bigint;

  constructor(data?: PartialMessage<PaginatedSearchRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.PaginatedSearchRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaginatedSearchRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaginatedSearchRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaginatedSearchRes;

  static equals(a: PaginatedSearchRes | PlainMessage<PaginatedSearchRes> | undefined, b: PaginatedSearchRes | PlainMessage<PaginatedSearchRes> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.GetCollectionEntriesReq
 */
export declare class GetCollectionEntriesReq extends Message<GetCollectionEntriesReq> {
  /**
   * @generated from field: string collection_id = 3;
   */
  collectionId: string;

  /**
   * @generated from field: int64 from = 4;
   */
  from: bigint;

  /**
   * @generated from field: int64 page_size = 5;
   */
  pageSize: bigint;

  /**
   * @generated from field: string search_after_id = 6;
   */
  searchAfterId: string;

  constructor(data?: PartialMessage<GetCollectionEntriesReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.GetCollectionEntriesReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCollectionEntriesReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCollectionEntriesReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCollectionEntriesReq;

  static equals(a: GetCollectionEntriesReq | PlainMessage<GetCollectionEntriesReq> | undefined, b: GetCollectionEntriesReq | PlainMessage<GetCollectionEntriesReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.GetCollectionEntriesRes
 */
export declare class GetCollectionEntriesRes extends Message<GetCollectionEntriesRes> {
  /**
   * @generated from field: api.v0alpha.CollectionMetadata metadata = 1;
   */
  metadata?: CollectionMetadata;

  /**
   * @generated from field: repeated api.v0alpha.CollectionEntry entries = 2;
   */
  entries: CollectionEntry[];

  constructor(data?: PartialMessage<GetCollectionEntriesRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.GetCollectionEntriesRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCollectionEntriesRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCollectionEntriesRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCollectionEntriesRes;

  static equals(a: GetCollectionEntriesRes | PlainMessage<GetCollectionEntriesRes> | undefined, b: GetCollectionEntriesRes | PlainMessage<GetCollectionEntriesRes> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.DeleteCollectionEntryReq
 */
export declare class DeleteCollectionEntryReq extends Message<DeleteCollectionEntryReq> {
  /**
   * @generated from field: string collection_id = 3;
   */
  collectionId: string;

  /**
   * @generated from field: string entry_id = 4;
   */
  entryId: string;

  constructor(data?: PartialMessage<DeleteCollectionEntryReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.DeleteCollectionEntryReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteCollectionEntryReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteCollectionEntryReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteCollectionEntryReq;

  static equals(a: DeleteCollectionEntryReq | PlainMessage<DeleteCollectionEntryReq> | undefined, b: DeleteCollectionEntryReq | PlainMessage<DeleteCollectionEntryReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ListCampaignLinksRes
 */
export declare class ListCampaignLinksRes extends Message<ListCampaignLinksRes> {
  /**
   * @generated from field: repeated api.v0alpha.Link Links = 1;
   */
  Links: Link[];

  constructor(data?: PartialMessage<ListCampaignLinksRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ListCampaignLinksRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListCampaignLinksRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListCampaignLinksRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListCampaignLinksRes;

  static equals(a: ListCampaignLinksRes | PlainMessage<ListCampaignLinksRes> | undefined, b: ListCampaignLinksRes | PlainMessage<ListCampaignLinksRes> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.Link
 */
export declare class Link extends Message<Link> {
  /**
   * @generated from field: int64 xml_client_prop_sid = 1;
   */
  xmlClientPropSid: bigint;

  /**
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * @generated from field: string description = 3;
   */
  description: string;

  constructor(data?: PartialMessage<Link>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.Link";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Link;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Link;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Link;

  static equals(a: Link | PlainMessage<Link> | undefined, b: Link | PlainMessage<Link> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.CjsSearchField
 */
export declare class CjsSearchField extends Message<CjsSearchField> {
  /**
   * @generated from field: string cjs_search_field_id = 1;
   */
  cjsSearchFieldId: string;

  /**
   * @generated from field: string cjs_search_definition_id = 2;
   */
  cjsSearchDefinitionId: string;

  /**
   * @generated from field: string field_name = 3;
   */
  fieldName: string;

  /**
   * @generated from field: api.commons.FieldType field_type = 4;
   */
  fieldType: FieldType;

  /**
   * leave empty in definition to prompt user for value
   *
   * @generated from field: string field_value = 5;
   */
  fieldValue: string;

  constructor(data?: PartialMessage<CjsSearchField>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.CjsSearchField";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CjsSearchField;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CjsSearchField;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CjsSearchField;

  static equals(a: CjsSearchField | PlainMessage<CjsSearchField> | undefined, b: CjsSearchField | PlainMessage<CjsSearchField> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.CjsSearchDefinitionMetadata
 */
export declare class CjsSearchDefinitionMetadata extends Message<CjsSearchDefinitionMetadata> {
  /**
   * @generated from field: string cjs_search_definition_id = 1;
   */
  cjsSearchDefinitionId: string;

  /**
   * @generated from field: string name = 4;
   */
  name: string;

  /**
   * @generated from field: string description = 5;
   */
  description: string;

  /**
   * @generated from field: bool deleted = 6;
   */
  deleted: boolean;

  /**
   * @generated from field: int64 exec_count = 7;
   */
  execCount: bigint;

  /**
   * @generated from field: int64 exec_success = 8;
   */
  execSuccess: bigint;

  /**
   * @generated from field: int64 exec_fail = 9;
   */
  execFail: bigint;

  /**
   * @generated from field: google.protobuf.Timestamp created_date = 10;
   */
  createdDate?: Timestamp$1;

  /**
   * @generated from field: google.protobuf.Timestamp last_edited = 11;
   */
  lastEdited?: Timestamp$1;

  constructor(data?: PartialMessage<CjsSearchDefinitionMetadata>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.CjsSearchDefinitionMetadata";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CjsSearchDefinitionMetadata;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CjsSearchDefinitionMetadata;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CjsSearchDefinitionMetadata;

  static equals(a: CjsSearchDefinitionMetadata | PlainMessage<CjsSearchDefinitionMetadata> | undefined, b: CjsSearchDefinitionMetadata | PlainMessage<CjsSearchDefinitionMetadata> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.CjsSearchDefinition
 */
export declare class CjsSearchDefinition extends Message<CjsSearchDefinition> {
  /**
   * @generated from field: api.v0alpha.CjsSearchDefinitionMetadata metadata = 1;
   */
  metadata?: CjsSearchDefinitionMetadata;

  /**
   * @generated from field: repeated api.v0alpha.CjsSearchField search_fields = 2;
   */
  searchFields: CjsSearchField[];

  /**
   * @generated from field: repeated api.v0alpha.CjsSearchField whitelisted_return_fields = 3;
   */
  whitelistedReturnFields: CjsSearchField[];

  /**
   * @generated from field: repeated api.v0alpha.CjsSearchField blacklisted_return_fields = 4;
   */
  blacklistedReturnFields: CjsSearchField[];

  /**
   * field(s) used to identify a unique individual within a collection (ex. account_number)
   *
   * @generated from field: repeated api.v0alpha.CjsSearchField unique_identifiers = 5;
   */
  uniqueIdentifiers: CjsSearchField[];

  constructor(data?: PartialMessage<CjsSearchDefinition>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.CjsSearchDefinition";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CjsSearchDefinition;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CjsSearchDefinition;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CjsSearchDefinition;

  static equals(a: CjsSearchDefinition | PlainMessage<CjsSearchDefinition> | undefined, b: CjsSearchDefinition | PlainMessage<CjsSearchDefinition> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.GetCjsSearchDefinitionReq
 */
export declare class GetCjsSearchDefinitionReq extends Message<GetCjsSearchDefinitionReq> {
  /**
   * @generated from field: string cjs_search_definition_id = 1;
   */
  cjsSearchDefinitionId: string;

  constructor(data?: PartialMessage<GetCjsSearchDefinitionReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.GetCjsSearchDefinitionReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCjsSearchDefinitionReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCjsSearchDefinitionReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCjsSearchDefinitionReq;

  static equals(a: GetCjsSearchDefinitionReq | PlainMessage<GetCjsSearchDefinitionReq> | undefined, b: GetCjsSearchDefinitionReq | PlainMessage<GetCjsSearchDefinitionReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.DeleteCjsSearchDefinitionReq
 */
export declare class DeleteCjsSearchDefinitionReq extends Message<DeleteCjsSearchDefinitionReq> {
  /**
   * @generated from field: string cjs_search_definition_id = 1;
   */
  cjsSearchDefinitionId: string;

  constructor(data?: PartialMessage<DeleteCjsSearchDefinitionReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.DeleteCjsSearchDefinitionReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteCjsSearchDefinitionReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteCjsSearchDefinitionReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteCjsSearchDefinitionReq;

  static equals(a: DeleteCjsSearchDefinitionReq | PlainMessage<DeleteCjsSearchDefinitionReq> | undefined, b: DeleteCjsSearchDefinitionReq | PlainMessage<DeleteCjsSearchDefinitionReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ListCjsSearchDefinitionsReq
 */
export declare class ListCjsSearchDefinitionsReq extends Message<ListCjsSearchDefinitionsReq> {
  constructor(data?: PartialMessage<ListCjsSearchDefinitionsReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ListCjsSearchDefinitionsReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListCjsSearchDefinitionsReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListCjsSearchDefinitionsReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListCjsSearchDefinitionsReq;

  static equals(a: ListCjsSearchDefinitionsReq | PlainMessage<ListCjsSearchDefinitionsReq> | undefined, b: ListCjsSearchDefinitionsReq | PlainMessage<ListCjsSearchDefinitionsReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ListCjsSearchDefinitionsRes
 */
export declare class ListCjsSearchDefinitionsRes extends Message<ListCjsSearchDefinitionsRes> {
  /**
   * @generated from field: repeated api.v0alpha.CjsSearchDefinitionMetadata definitions = 1;
   */
  definitions: CjsSearchDefinitionMetadata[];

  constructor(data?: PartialMessage<ListCjsSearchDefinitionsRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ListCjsSearchDefinitionsRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListCjsSearchDefinitionsRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListCjsSearchDefinitionsRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListCjsSearchDefinitionsRes;

  static equals(a: ListCjsSearchDefinitionsRes | PlainMessage<ListCjsSearchDefinitionsRes> | undefined, b: ListCjsSearchDefinitionsRes | PlainMessage<ListCjsSearchDefinitionsRes> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ExecuteCjsSearchDefinitionReq
 */
export declare class ExecuteCjsSearchDefinitionReq extends Message<ExecuteCjsSearchDefinitionReq> {
  /**
   * @generated from field: string search_definition_id = 1;
   */
  searchDefinitionId: string;

  /**
   * @generated from field: repeated api.v0alpha.CjsExecuteSearchField search_fields = 4;
   */
  searchFields: CjsExecuteSearchField[];

  constructor(data?: PartialMessage<ExecuteCjsSearchDefinitionReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ExecuteCjsSearchDefinitionReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecuteCjsSearchDefinitionReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecuteCjsSearchDefinitionReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecuteCjsSearchDefinitionReq;

  static equals(a: ExecuteCjsSearchDefinitionReq | PlainMessage<ExecuteCjsSearchDefinitionReq> | undefined, b: ExecuteCjsSearchDefinitionReq | PlainMessage<ExecuteCjsSearchDefinitionReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.ExecuteCjsSearchDefinitionRes
 */
export declare class ExecuteCjsSearchDefinitionRes extends Message<ExecuteCjsSearchDefinitionRes> {
  /**
   * @generated from field: repeated api.v0alpha.CollectionEntries collection_entries = 1;
   */
  collectionEntries: CollectionEntries[];

  constructor(data?: PartialMessage<ExecuteCjsSearchDefinitionRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.ExecuteCjsSearchDefinitionRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecuteCjsSearchDefinitionRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecuteCjsSearchDefinitionRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecuteCjsSearchDefinitionRes;

  static equals(a: ExecuteCjsSearchDefinitionRes | PlainMessage<ExecuteCjsSearchDefinitionRes> | undefined, b: ExecuteCjsSearchDefinitionRes | PlainMessage<ExecuteCjsSearchDefinitionRes> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.CollectionEntries
 */
export declare class CollectionEntries extends Message<CollectionEntries> {
  /**
   * @generated from field: api.v0alpha.CollectionMetadata metadata = 1;
   */
  metadata?: CollectionMetadata;

  /**
   * @generated from field: repeated api.v0alpha.CollectionEntry entries = 2;
   */
  entries: CollectionEntry[];

  constructor(data?: PartialMessage<CollectionEntries>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.CollectionEntries";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionEntries;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionEntries;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionEntries;

  static equals(a: CollectionEntries | PlainMessage<CollectionEntries> | undefined, b: CollectionEntries | PlainMessage<CollectionEntries> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.CjsExecuteSearchField
 */
export declare class CjsExecuteSearchField extends Message<CjsExecuteSearchField> {
  /**
   * @generated from oneof api.v0alpha.CjsExecuteSearchField.field
   */
  field: {
    /**
     * @generated from field: string field_name = 1;
     */
    value: string;
    case: "fieldName";
  } | {
    /**
     * @generated from field: api.commons.FieldType field_type = 2;
     */
    value: FieldType;
    case: "fieldType";
  } | { case: undefined; value?: undefined };

  /**
   * @generated from field: string field_value = 3;
   */
  fieldValue: string;

  constructor(data?: PartialMessage<CjsExecuteSearchField>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.CjsExecuteSearchField";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CjsExecuteSearchField;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CjsExecuteSearchField;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CjsExecuteSearchField;

  static equals(a: CjsExecuteSearchField | PlainMessage<CjsExecuteSearchField> | undefined, b: CjsExecuteSearchField | PlainMessage<CjsExecuteSearchField> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.CjsSecureSearchCriteriaMetadata
 */
export declare class CjsSecureSearchCriteriaMetadata extends Message<CjsSecureSearchCriteriaMetadata> {
  /**
   * @generated from field: string cjs_secure_search_criteria_id = 1;
   */
  cjsSecureSearchCriteriaId: string;

  /**
   * @generated from field: bool deleted = 4;
   */
  deleted: boolean;

  /**
   * auditing
   *
   * @generated from field: google.protobuf.Timestamp created_on = 10;
   */
  createdOn?: Timestamp$1;

  /**
   * @generated from field: google.protobuf.Timestamp last_updated = 11;
   */
  lastUpdated?: Timestamp$1;

  constructor(data?: PartialMessage<CjsSecureSearchCriteriaMetadata>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.CjsSecureSearchCriteriaMetadata";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CjsSecureSearchCriteriaMetadata;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CjsSecureSearchCriteriaMetadata;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CjsSecureSearchCriteriaMetadata;

  static equals(a: CjsSecureSearchCriteriaMetadata | PlainMessage<CjsSecureSearchCriteriaMetadata> | undefined, b: CjsSecureSearchCriteriaMetadata | PlainMessage<CjsSecureSearchCriteriaMetadata> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.CjsSecureSearchCriteria
 */
export declare class CjsSecureSearchCriteria extends Message<CjsSecureSearchCriteria> {
  /**
   * @generated from field: api.v0alpha.CjsSecureSearchCriteriaMetadata metadata = 1;
   */
  metadata?: CjsSecureSearchCriteriaMetadata;

  /**
   * @generated from field: repeated api.v0alpha.CjsSecureSearchCriteriaField fields = 2;
   */
  fields: CjsSecureSearchCriteriaField[];

  constructor(data?: PartialMessage<CjsSecureSearchCriteria>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.CjsSecureSearchCriteria";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CjsSecureSearchCriteria;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CjsSecureSearchCriteria;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CjsSecureSearchCriteria;

  static equals(a: CjsSecureSearchCriteria | PlainMessage<CjsSecureSearchCriteria> | undefined, b: CjsSecureSearchCriteria | PlainMessage<CjsSecureSearchCriteria> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.GetCjsSecureSearchCriteriaReq
 */
export declare class GetCjsSecureSearchCriteriaReq extends Message<GetCjsSecureSearchCriteriaReq> {
  constructor(data?: PartialMessage<GetCjsSecureSearchCriteriaReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.GetCjsSecureSearchCriteriaReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCjsSecureSearchCriteriaReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCjsSecureSearchCriteriaReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCjsSecureSearchCriteriaReq;

  static equals(a: GetCjsSecureSearchCriteriaReq | PlainMessage<GetCjsSecureSearchCriteriaReq> | undefined, b: GetCjsSecureSearchCriteriaReq | PlainMessage<GetCjsSecureSearchCriteriaReq> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.CjsSecureSearchCriteriaField
 */
export declare class CjsSecureSearchCriteriaField extends Message<CjsSecureSearchCriteriaField> {
  /**
   * @generated from field: string cjs_secure_search_criteria_field_id = 1;
   */
  cjsSecureSearchCriteriaFieldId: string;

  /**
   * @generated from field: string cjs_secure_search_criteria_id = 2;
   */
  cjsSecureSearchCriteriaId: string;

  /**
   * @generated from field: api.commons.FieldType field_type = 3;
   */
  fieldType: FieldType;

  constructor(data?: PartialMessage<CjsSecureSearchCriteriaField>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.CjsSecureSearchCriteriaField";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CjsSecureSearchCriteriaField;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CjsSecureSearchCriteriaField;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CjsSecureSearchCriteriaField;

  static equals(a: CjsSecureSearchCriteriaField | PlainMessage<CjsSecureSearchCriteriaField> | undefined, b: CjsSecureSearchCriteriaField | PlainMessage<CjsSecureSearchCriteriaField> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.SplitCriteria
 */
export declare class SplitCriteria extends Message<SplitCriteria> {
  /**
   * @generated from oneof api.v0alpha.SplitCriteria.action
   */
  action: {
    /**
     * @generated from field: api.v0alpha.SplitByUnique unique = 1;
     */
    value: SplitByUnique;
    case: "unique";
  } | {
    /**
     * @generated from field: api.v0alpha.SplitByMaxSize max_size = 2;
     */
    value: SplitByMaxSize;
    case: "maxSize";
  } | {
    /**
     * @generated from field: api.v0alpha.SplitByEqualParts equal_parts = 3;
     */
    value: SplitByEqualParts;
    case: "equalParts";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<SplitCriteria>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.SplitCriteria";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SplitCriteria;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SplitCriteria;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SplitCriteria;

  static equals(a: SplitCriteria | PlainMessage<SplitCriteria> | undefined, b: SplitCriteria | PlainMessage<SplitCriteria> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.UniquePair
 */
export declare class UniquePair extends Message<UniquePair> {
  /**
   * @generated from field: api.v0alpha.FieldIndex split_on_fields = 1;
   */
  splitOnFields?: FieldIndex;

  /**
   * @generated from field: string split_value = 2;
   */
  splitValue: string;

  constructor(data?: PartialMessage<UniquePair>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.UniquePair";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UniquePair;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UniquePair;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UniquePair;

  static equals(a: UniquePair | PlainMessage<UniquePair> | undefined, b: UniquePair | PlainMessage<UniquePair> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.SplitByNamedUnique
 */
export declare class SplitByNamedUnique extends Message<SplitByNamedUnique> {
  /**
   * @generated from field: repeated api.v0alpha.UniquePair named_fields = 1;
   */
  namedFields: UniquePair[];

  constructor(data?: PartialMessage<SplitByNamedUnique>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.SplitByNamedUnique";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SplitByNamedUnique;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SplitByNamedUnique;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SplitByNamedUnique;

  static equals(a: SplitByNamedUnique | PlainMessage<SplitByNamedUnique> | undefined, b: SplitByNamedUnique | PlainMessage<SplitByNamedUnique> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.SplitByUnique
 */
export declare class SplitByUnique extends Message<SplitByUnique> {
  /**
   * @generated from field: repeated api.v0alpha.FieldIndex split_on_fields = 1;
   */
  splitOnFields: FieldIndex[];

  constructor(data?: PartialMessage<SplitByUnique>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.SplitByUnique";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SplitByUnique;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SplitByUnique;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SplitByUnique;

  static equals(a: SplitByUnique | PlainMessage<SplitByUnique> | undefined, b: SplitByUnique | PlainMessage<SplitByUnique> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.SplitByMaxSize
 */
export declare class SplitByMaxSize extends Message<SplitByMaxSize> {
  /**
   * @generated from field: int32 max_size = 1;
   */
  maxSize: number;

  constructor(data?: PartialMessage<SplitByMaxSize>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.SplitByMaxSize";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SplitByMaxSize;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SplitByMaxSize;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SplitByMaxSize;

  static equals(a: SplitByMaxSize | PlainMessage<SplitByMaxSize> | undefined, b: SplitByMaxSize | PlainMessage<SplitByMaxSize> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.SplitByEqualParts
 */
export declare class SplitByEqualParts extends Message<SplitByEqualParts> {
  /**
   * @generated from field: int32 part_size = 1;
   */
  partSize: number;

  constructor(data?: PartialMessage<SplitByEqualParts>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.SplitByEqualParts";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SplitByEqualParts;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SplitByEqualParts;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SplitByEqualParts;

  static equals(a: SplitByEqualParts | PlainMessage<SplitByEqualParts> | undefined, b: SplitByEqualParts | PlainMessage<SplitByEqualParts> | undefined): boolean;
}

/**
 * EHR EPIC
 *
 * @generated from message api.v0alpha.EpicEntrypoint
 */
export declare class EpicEntrypoint extends Message<EpicEntrypoint> {
  /**
   * how often this event needs to run.
   * this cron string will be restricted differently depending
   * on the specific operation being run. For example, Epic
   * only allows calls once per 24 hours.
   *
   * @generated from field: string cron = 2;
   */
  cron: string;

  /**
   * how long in minutes we will wait with the entrypoint
   * in the CHECK state. 0 is interpreted as wait indefinitely.
   *
   * the file template that will convert the raw data during the process state.
   * do we need to specify a file template id? Or should we only push into journey?
   * string file_template_id = 4;
   *
   * @generated from field: double max_wait_time = 3;
   */
  maxWaitTime: number;

  /**
   * the types of entities we want retrieved
   *
   * @generated from field: repeated api.v0alpha.EpicEntityType entity_types = 4;
   */
  entityTypes: EpicEntityType[];

  /**
   * the base url that points to the group of entites we are querying.
   * Each group can be contacted once every 24 hours max.
   * Example: https://apporchard.epic.com/interconnect-aocurprd-oauth/api/FHIR/R4
   *
   * @generated from field: string group_base_url = 5;
   */
  groupBaseUrl: string;

  /**
   * the id for the group we are matching.
   * Example: eIscQb2HmqkT.aPxBKDR1mIj3721CpVk1suC7rlu3yX83
   *
   * @generated from field: string group_fhir_id = 6;
   */
  groupFhirId: string;

  /**
   * values during event processing.
   * Not visible to user.
   *
   * @generated from field: api.v0alpha.RuntimeValues runtime_values = 7;
   */
  runtimeValues?: RuntimeValues;

  /**
   * how many pages we should save before aggregating the data and sending downstream
   * default is 100. Max is 10000.
   * If a termination state hasn't been reached, the event will be re-queued and continue
   * where it left off.
   *
   * @generated from field: int64 flush_page_count = 8;
   */
  flushPageCount: bigint;

  /**
   * how much total elapsed time (in minutes) we want to wait before flushing records.
   * if total time spent aggregating the data goes over this many minutes, we will flush
   * the current records downstream.
   * default is 20. Max is 120. Min is 1.
   * If a termination state hasn't been reached, the event will be re-queued and continue
   * where it left off.
   *
   * @generated from field: int64 flush_minute_count = 9;
   */
  flushMinuteCount: bigint;

  /**
   * if true, we will switch to processing mode when we have enough records to flush
   * even if we haven't downloaded all the pages yet.
   * after the current records are flushed, we switch back to downloading the remaining records.
   * If false (default), we download all the pages before we start processing any records.
   *
   * @generated from field: bool flush_during_check = 10;
   */
  flushDuringCheck: boolean;

  constructor(data?: PartialMessage<EpicEntrypoint>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.EpicEntrypoint";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EpicEntrypoint;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EpicEntrypoint;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EpicEntrypoint;

  static equals(a: EpicEntrypoint | PlainMessage<EpicEntrypoint> | undefined, b: EpicEntrypoint | PlainMessage<EpicEntrypoint> | undefined): boolean;
}

/**
 * These values are invisible to the user, and null in the lms_elements table.
 * These will be used during the processing of the event.
 *
 * @generated from message api.v0alpha.RuntimeValues
 */
export declare class RuntimeValues extends Message<RuntimeValues> {
  /**
   * current state of the entrypoint
   * this is set to kickoff when the entrypoint is queued up
   *
   * @generated from field: api.commons.EventState state = 1;
   */
  state: EventState;

  /**
   * the token we are using for this session.
   * This value is retrieved by sending a jwt to epic's auth endpoint.
   *
   * @generated from field: string access_token = 2;
   */
  accessToken: string;

  /**
   * the url returned from the kickoff's 'Content-Location' response header
   * used during the CHECK state.
   *
   * @generated from field: string check_url = 3;
   */
  checkUrl: string;

  /**
   * the the location for all the data we are importing.
   * Epic returns newline delimited json for each url endpoint
   *
   * @generated from field: repeated api.v0alpha.EntityURL data_urls = 4;
   */
  dataUrls: EntityURL[];

  /**
   * how many times we have ran the paginated request
   *
   * @generated from field: int64 current_iteration = 5;
   */
  currentIteration: bigint;

  /**
   * @generated from field: int64 total_seconds_spent = 6;
   */
  totalSecondsSpent: bigint;

  /**
   * any errors that happened during processing
   *
   * @generated from field: repeated string errors = 7;
   */
  errors: string[];

  /**
   * how many times the bulk entrypoint has been not ready total
   *
   * @generated from field: int64 total_not_ready_count = 8;
   */
  totalNotReadyCount: bigint;

  /**
   * as of writing, the unflushed input is stored in fts.
   * the keys will be the fts_id the page, and the values the size of the request in bytes
   *
   * @generated from field: map<string, int64> file_ids = 9;
   */
  fileIds: { [key: string]: bigint };

  /**
   * the named variables saved from the preliminary requests
   * these can be used in the paginated_request
   *
   * @generated from field: map<string, string> preliminary_vars = 10;
   */
  preliminaryVars: { [key: string]: string };

  /**
   * the events that happened before this one
   *
   * @generated from field: repeated int64 parent_event_ids = 11;
   */
  parentEventIds: bigint[];

  /**
   * if true we wont need to switch back from process state, to check state.
   * if false, we need to continue in check state after flushing records
   *
   * @generated from field: bool no_more_pages = 12;
   */
  noMorePages: boolean;

  /**
   * tracks all fts files we have writen regardless of whether they have been processed yet
   *
   * @generated from field: repeated string total_fts_ids = 13;
   */
  totalFtsIds: string[];

  constructor(data?: PartialMessage<RuntimeValues>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.RuntimeValues";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RuntimeValues;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RuntimeValues;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RuntimeValues;

  static equals(a: RuntimeValues | PlainMessage<RuntimeValues> | undefined, b: RuntimeValues | PlainMessage<RuntimeValues> | undefined): boolean;
}

/**
 * @generated from message api.v0alpha.EntityURL
 */
export declare class EntityURL extends Message<EntityURL> {
  /**
   * @generated from field: api.v0alpha.EpicEntityType entity_type = 1;
   */
  entityType: EpicEntityType;

  /**
   * @generated from field: string url = 2;
   */
  url: string;

  constructor(data?: PartialMessage<EntityURL>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v0alpha.EntityURL";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EntityURL;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EntityURL;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EntityURL;

  static equals(a: EntityURL | PlainMessage<EntityURL> | undefined, b: EntityURL | PlainMessage<EntityURL> | undefined): boolean;
}

