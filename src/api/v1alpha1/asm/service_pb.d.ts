// Copyright (c) 2020, TCN Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.1 with parameter "target=js+dts"
// @generated from file api/v1alpha1/asm/service.proto (package api.v1alpha1.asm, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, FieldMask, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Timestamp } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { AsmSubsessionType, DashboardAgentInfo } from "../../commons/asm_pb.js";
import type { AsmEvent, Event } from "../../commons/event_pb.js";
import type { AgentAlert, AgentStatus_Enum, CallType_Enum, QueuedNotificationType, TransferMember } from "../../commons/acd_pb.js";
import type { AgentConversationAssignmentStatus, AgentConversationAssignmentType, ChannelType, ConversationCollectedData, ConversationCustomerInformation, ConversationStatus, OmniConversation, OmniSenderType, SLATimeouts } from "../../commons/omnichannel_pb.js";
import type { AuthenticatedUser } from "../../commons/auth/user_pb.js";

/**
 * @generated from message api.v1alpha1.asm.CreateSessionReq
 */
export declare class CreateSessionReq extends Message<CreateSessionReq> {
  /**
   * @generated from field: int64 hunt_group_sid = 1;
   */
  huntGroupSid: bigint;

  /**
   * @generated from field: map<string, int64> skills = 2;
   */
  skills: { [key: string]: bigint };

  /**
   * @generated from field: api.commons.AsmSubsessionType subsession_type = 3;
   */
  subsessionType: AsmSubsessionType;

  constructor(data?: PartialMessage<CreateSessionReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.CreateSessionReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSessionReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSessionReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateSessionReq;

  static equals(a: CreateSessionReq | PlainMessage<CreateSessionReq> | undefined, b: CreateSessionReq | PlainMessage<CreateSessionReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.CreateSessionRes
 */
export declare class CreateSessionRes extends Message<CreateSessionRes> {
  /**
   * @generated from field: int64 asm_session_sid = 1;
   */
  asmSessionSid: bigint;

  /**
   * @generated from field: int64 voice_session_sid = 2;
   */
  voiceSessionSid: bigint;

  /**
   * @generated from field: api.v1alpha1.asm.VoiceRegistration voice_registration = 3;
   */
  voiceRegistration?: VoiceRegistration;

  constructor(data?: PartialMessage<CreateSessionRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.CreateSessionRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSessionRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSessionRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateSessionRes;

  static equals(a: CreateSessionRes | PlainMessage<CreateSessionRes> | undefined, b: CreateSessionRes | PlainMessage<CreateSessionRes> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.VoiceRegistration
 */
export declare class VoiceRegistration extends Message<VoiceRegistration> {
  /**
   * The pin used to log in via a connected phone
   *
   * @generated from field: string username = 2;
   */
  username: string;

  /**
   * The pass used to log in via a connected phone
   *
   * @generated from field: string password = 3;
   */
  password: string;

  /**
   * The extention appended
   *
   * @generated from field: string dial_url = 4;
   */
  dialUrl: string;

  /**
   * pstn phone number that will be used for the agent to dial in
   * if it's an empty string then the voip connection must be used
   *
   * @generated from field: string pstn_phone = 5;
   */
  pstnPhone: string;

  /**
   * @generated from field: string default_time_zone = 6;
   */
  defaultTimeZone: string;

  /**
   * @generated from field: int64 expiration_timestamp = 7;
   */
  expirationTimestamp: bigint;

  constructor(data?: PartialMessage<VoiceRegistration>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.VoiceRegistration";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VoiceRegistration;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VoiceRegistration;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VoiceRegistration;

  static equals(a: VoiceRegistration | PlainMessage<VoiceRegistration> | undefined, b: VoiceRegistration | PlainMessage<VoiceRegistration> | undefined): boolean;
}

/**
 * request used to establish a stream of status updates
 * based on the given asm session sid. Ths will return
 * all payload types in the responses
 *
 * @generated from message api.v1alpha1.asm.StreamAgentStateReq
 */
export declare class StreamAgentStateReq extends Message<StreamAgentStateReq> {
  /**
   * @generated from field: int64 asm_session_sid = 1;
   */
  asmSessionSid: bigint;

  /**
   * @generated from field: bool keep_alive = 2;
   */
  keepAlive: boolean;

  constructor(data?: PartialMessage<StreamAgentStateReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.StreamAgentStateReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamAgentStateReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamAgentStateReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamAgentStateReq;

  static equals(a: StreamAgentStateReq | PlainMessage<StreamAgentStateReq> | undefined, b: StreamAgentStateReq | PlainMessage<StreamAgentStateReq> | undefined): boolean;
}

/**
 * request used to establish a stream of status updates
 * based on the current authenticated user's org_id
 * This will only return the AgentState payload type
 * in the reponses
 *
 * @generated from message api.v1alpha1.asm.ManagerStreamAgentStateReq
 */
export declare class ManagerStreamAgentStateReq extends Message<ManagerStreamAgentStateReq> {
  constructor(data?: PartialMessage<ManagerStreamAgentStateReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.ManagerStreamAgentStateReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ManagerStreamAgentStateReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ManagerStreamAgentStateReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ManagerStreamAgentStateReq;

  static equals(a: ManagerStreamAgentStateReq | PlainMessage<ManagerStreamAgentStateReq> | undefined, b: ManagerStreamAgentStateReq | PlainMessage<ManagerStreamAgentStateReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.GetStatusReq
 */
export declare class GetStatusReq extends Message<GetStatusReq> {
  /**
   * @generated from field: int64 asm_session_sid = 1;
   */
  asmSessionSid: bigint;

  /**
   * @generated from field: bool perform_keep_alive = 2;
   */
  performKeepAlive: boolean;

  /**
   * @generated from field: bool perform_get_queued_calls = 3;
   */
  performGetQueuedCalls: boolean;

  /**
   * @generated from field: bool perform_get_message = 4;
   */
  performGetMessage: boolean;

  /**
   * @generated from field: int64 minimum_message_timestamp = 5;
   */
  minimumMessageTimestamp: bigint;

  /**
   * @generated from field: repeated string skills = 6;
   */
  skills: string[];

  /**
   * @generated from field: repeated api.commons.Event events = 7;
   */
  events: Event[];

  /**
   * the current agents pbx extensions
   *
   * @generated from field: repeated string agent_pbx_extensions = 8;
   */
  agentPbxExtensions: string[];

  constructor(data?: PartialMessage<GetStatusReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.GetStatusReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStatusReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStatusReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStatusReq;

  static equals(a: GetStatusReq | PlainMessage<GetStatusReq> | undefined, b: GetStatusReq | PlainMessage<GetStatusReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.GetStatusRes
 */
export declare class GetStatusRes extends Message<GetStatusRes> {
  /**
   * @generated from field: api.v1alpha1.asm.VoiceStatus voice_status = 1;
   */
  voiceStatus?: VoiceStatus;

  constructor(data?: PartialMessage<GetStatusRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.GetStatusRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetStatusRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetStatusRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetStatusRes;

  static equals(a: GetStatusRes | PlainMessage<GetStatusRes> | undefined, b: GetStatusRes | PlainMessage<GetStatusRes> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.VoiceStatus
 */
export declare class VoiceStatus extends Message<VoiceStatus> {
  /**
   * @generated from field: int64 status = 2;
   */
  status: bigint;

  /**
   * @generated from field: api.commons.AgentStatus.Enum status_desc = 3;
   */
  statusDesc: AgentStatus_Enum;

  /**
   * @generated from field: bool paused = 4;
   */
  paused: boolean;

  /**
   * @generated from field: string queue = 5;
   */
  queue: string;

  /**
   * @generated from field: int64 current_session_id = 6;
   */
  currentSessionId: bigint;

  /**
   * @generated from field: int64 last_status_change = 7;
   */
  lastStatusChange: bigint;

  /**
   * @generated from field: bool monitoring = 8;
   */
  monitoring: boolean;

  /**
   * @generated from field: int64 calls_count = 9;
   */
  callsCount: bigint;

  /**
   * @generated from field: int64 last_sip_code = 10;
   */
  lastSipCode: bigint;

  /**
   * @generated from field: bool agent_peer_is_lost_call = 11;
   */
  agentPeerIsLostCall: boolean;

  /**
   * @generated from field: bool disabled = 12;
   */
  disabled: boolean;

  /**
   * @generated from field: bool keep_alive_succeeded = 13;
   */
  keepAliveSucceeded: boolean;

  /**
   * @generated from field: string message = 14;
   */
  message: string;

  /**
   * @generated from field: int64 message_timestamp = 15;
   */
  messageTimestamp: bigint;

  /**
   * @generated from field: api.v1alpha1.asm.QueuedCalls queued_calls = 16;
   */
  queuedCalls?: QueuedCalls;

  /**
   * @generated from field: bool caller_was_suspended = 17;
   */
  callerWasSuspended: boolean;

  /**
   * @generated from field: repeated api.commons.TransferMember transfer_members = 18;
   */
  transferMembers: TransferMember[];

  /**
   * @generated from field: api.commons.AgentAlert alert = 19;
   */
  alert?: AgentAlert;

  /**
   * indicates if the current call is a direct to agent call
   *
   * @generated from field: bool agent_peer_is_direct_to_agent = 20;
   */
  agentPeerIsDirectToAgent: boolean;

  /**
   * indicates if the agent is muted or not
   *
   * @generated from field: bool agent_is_muted = 21;
   */
  agentIsMuted: boolean;

  constructor(data?: PartialMessage<VoiceStatus>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.VoiceStatus";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VoiceStatus;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VoiceStatus;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VoiceStatus;

  static equals(a: VoiceStatus | PlainMessage<VoiceStatus> | undefined, b: VoiceStatus | PlainMessage<VoiceStatus> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.QueuedCalls
 */
export declare class QueuedCalls extends Message<QueuedCalls> {
  /**
   * calls that were queued and have a matching subset of the agent_skills from the request.
   *
   * @generated from field: repeated api.v1alpha1.asm.QueuedCalls.QueuedCallData agent_queue_calls = 16;
   */
  agentQueueCalls: QueuedCalls_QueuedCallData[];

  /**
   * calls that were placed on multi-hold by the agent_sid from the request.
   *
   * @generated from field: repeated api.v1alpha1.asm.QueuedCalls.QueuedCallData on_hold_calls = 17;
   */
  onHoldCalls: QueuedCalls_QueuedCallData[];

  /**
   * calls that were placed in the Hold Queue Monitor, are still on hold by the destination (hold music is being played by the other party) and have
   * a matching subset of the agent_skills from the request.
   *
   * @generated from field: repeated api.v1alpha1.asm.QueuedCalls.QueuedCallData hqm_calls = 18;
   */
  hqmCalls: QueuedCalls_QueuedCallData[];

  constructor(data?: PartialMessage<QueuedCalls>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.QueuedCalls";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueuedCalls;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueuedCalls;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueuedCalls;

  static equals(a: QueuedCalls | PlainMessage<QueuedCalls> | undefined, b: QueuedCalls | PlainMessage<QueuedCalls> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.QueuedCalls.QueuedCallData
 */
export declare class QueuedCalls_QueuedCallData extends Message<QueuedCalls_QueuedCallData> {
  /**
   * id of the found call.
   *
   * @generated from field: int64 call_sid = 1;
   */
  callSid: bigint;

  /**
   * number dialed when the call was placed.
   *
   * @generated from field: string phone_number = 2;
   */
  phoneNumber: string;

  /**
   * caller_id used when the call was placed.
   *
   * @generated from field: string caller_id = 3;
   */
  callerId: string;

  /**
   * call type of the found call.
   *
   * @generated from field: api.commons.CallType.Enum call_type = 4;
   */
  callType: CallType_Enum;

  /**
   * timestamp indicating when the call started.
   *
   * @generated from field: google.protobuf.Timestamp start_date = 5;
   */
  startDate?: Timestamp;

  /**
   * timestamp indicating when the call was put on hold (only set when call is a hold call).
   *
   * @generated from field: google.protobuf.Timestamp hold_date = 6;
   */
  holdDate?: Timestamp;

  /**
   * formatted skills that the call requires.
   *
   * @generated from field: repeated string skills = 7;
   */
  skills: string[];

  /**
   * indicates if the call is specific to the agent (multi-hold) or it can be picked up by multiple agents (queued and HQM calls).
   *
   * @generated from field: bool agent_specific = 8;
   */
  agentSpecific: boolean;

  /**
   * queued notification type of the call.
   *
   * @generated from field: api.commons.QueuedNotificationType queued_notification_type = 9;
   */
  queuedNotificationType: QueuedNotificationType;

  constructor(data?: PartialMessage<QueuedCalls_QueuedCallData>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.QueuedCalls.QueuedCallData";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueuedCalls_QueuedCallData;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueuedCalls_QueuedCallData;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueuedCalls_QueuedCallData;

  static equals(a: QueuedCalls_QueuedCallData | PlainMessage<QueuedCalls_QueuedCallData> | undefined, b: QueuedCalls_QueuedCallData | PlainMessage<QueuedCalls_QueuedCallData> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.EndSessionReq
 */
export declare class EndSessionReq extends Message<EndSessionReq> {
  /**
   * @generated from field: int64 asm_session_sid = 1;
   */
  asmSessionSid: bigint;

  /**
   * @generated from field: string reason = 2;
   */
  reason: string;

  constructor(data?: PartialMessage<EndSessionReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.EndSessionReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EndSessionReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EndSessionReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EndSessionReq;

  static equals(a: EndSessionReq | PlainMessage<EndSessionReq> | undefined, b: EndSessionReq | PlainMessage<EndSessionReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.EndSessionRes
 */
export declare class EndSessionRes extends Message<EndSessionRes> {
  constructor(data?: PartialMessage<EndSessionRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.EndSessionRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EndSessionRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EndSessionRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EndSessionRes;

  static equals(a: EndSessionRes | PlainMessage<EndSessionRes> | undefined, b: EndSessionRes | PlainMessage<EndSessionRes> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.GetCurrentSessionReq
 */
export declare class GetCurrentSessionReq extends Message<GetCurrentSessionReq> {
  constructor(data?: PartialMessage<GetCurrentSessionReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.GetCurrentSessionReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCurrentSessionReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCurrentSessionReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCurrentSessionReq;

  static equals(a: GetCurrentSessionReq | PlainMessage<GetCurrentSessionReq> | undefined, b: GetCurrentSessionReq | PlainMessage<GetCurrentSessionReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.AsmSession
 */
export declare class AsmSession extends Message<AsmSession> {
  /**
   * @generated from field: int64 asm_session_sid = 1;
   */
  asmSessionSid: bigint;

  /**
   * @generated from field: google.protobuf.Timestamp asm_session_start = 4;
   */
  asmSessionStart?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp asm_session_end = 5;
   */
  asmSessionEnd?: Timestamp;

  /**
   * @generated from field: api.v1alpha1.asm.VoiceSession voice_session = 6;
   */
  voiceSession?: VoiceSession;

  constructor(data?: PartialMessage<AsmSession>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.AsmSession";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AsmSession;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AsmSession;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AsmSession;

  static equals(a: AsmSession | PlainMessage<AsmSession> | undefined, b: AsmSession | PlainMessage<AsmSession> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.VoiceSession
 */
export declare class VoiceSession extends Message<VoiceSession> {
  /**
   * @generated from field: int64 voice_session_sid = 1;
   */
  voiceSessionSid: bigint;

  /**
   * @generated from field: google.protobuf.Timestamp voice_session_start = 2;
   */
  voiceSessionStart?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp voice_session_end = 3;
   */
  voiceSessionEnd?: Timestamp;

  constructor(data?: PartialMessage<VoiceSession>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.VoiceSession";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VoiceSession;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VoiceSession;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VoiceSession;

  static equals(a: VoiceSession | PlainMessage<VoiceSession> | undefined, b: VoiceSession | PlainMessage<VoiceSession> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.SwitchSubsessionReq
 */
export declare class SwitchSubsessionReq extends Message<SwitchSubsessionReq> {
  /**
   * @generated from field: int64 asm_session_sid = 1;
   */
  asmSessionSid: bigint;

  /**
   * @generated from field: int64 hunt_group_sid = 2;
   */
  huntGroupSid: bigint;

  /**
   * @generated from field: map<string, int64> skills = 3;
   */
  skills: { [key: string]: bigint };

  /**
   * @generated from field: api.commons.AsmSubsessionType channel_type = 4;
   */
  channelType: AsmSubsessionType;

  constructor(data?: PartialMessage<SwitchSubsessionReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.SwitchSubsessionReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwitchSubsessionReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwitchSubsessionReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwitchSubsessionReq;

  static equals(a: SwitchSubsessionReq | PlainMessage<SwitchSubsessionReq> | undefined, b: SwitchSubsessionReq | PlainMessage<SwitchSubsessionReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.SwitchSubsessionRes
 */
export declare class SwitchSubsessionRes extends Message<SwitchSubsessionRes> {
  /**
   * @generated from field: int64 voice_session_sid = 1;
   */
  voiceSessionSid: bigint;

  /**
   * @generated from field: api.v1alpha1.asm.VoiceRegistration voice_registration = 2;
   */
  voiceRegistration?: VoiceRegistration;

  constructor(data?: PartialMessage<SwitchSubsessionRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.SwitchSubsessionRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwitchSubsessionRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwitchSubsessionRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwitchSubsessionRes;

  static equals(a: SwitchSubsessionRes | PlainMessage<SwitchSubsessionRes> | undefined, b: SwitchSubsessionRes | PlainMessage<SwitchSubsessionRes> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.Conversation
 */
export declare class Conversation extends Message<Conversation> {
  /**
   * conversation details
   * agent conversation id
   *
   * @generated from field: int64 conversation_sid = 6;
   */
  conversationSid: bigint;

  /**
   * initial agent conversation created time
   *
   * @generated from field: google.protobuf.Timestamp conversation_created_time = 7;
   */
  conversationCreatedTime?: Timestamp;

  /**
   * agent conversation assigned time
   *
   * @generated from field: google.protobuf.Timestamp assigned_last_updated_time = 8;
   */
  assignedLastUpdatedTime?: Timestamp;

  /**
   * conversation status - open, closed
   *
   * @generated from field: api.commons.ConversationStatus conversation_status = 9;
   */
  conversationStatus: ConversationStatus;

  /**
   * channel type - voice|sms|email|chat
   *
   * @generated from field: api.commons.ChannelType channel_type = 10;
   */
  channelType: ChannelType;

  /**
   * @generated from field: api.commons.ConversationCustomerInformation customer_info = 11;
   */
  customerInfo?: ConversationCustomerInformation;

  /**
   * received time
   *
   * @generated from field: google.protobuf.Timestamp last_message_time = 12;
   */
  lastMessageTime?: Timestamp;

  /**
   * skills
   *
   * @generated from field: api.v1alpha1.asm.ConversationSkills skills = 13;
   */
  skills?: ConversationSkills;

  /**
   * agent conversation assignment status
   *
   * @generated from field: api.commons.AgentConversationAssignmentStatus assignment_status = 14;
   */
  assignmentStatus: AgentConversationAssignmentStatus;

  /**
   * agent conversation assignment type
   *
   * @generated from field: api.commons.AgentConversationAssignmentType assignment_type = 15;
   */
  assignmentType: AgentConversationAssignmentType;

  /**
   * sla and timeouts
   *
   * @generated from field: api.commons.SLATimeouts sla_timeouts = 16;
   */
  slaTimeouts?: SLATimeouts;

  /**
   * conversation collected data
   *
   * @generated from field: api.commons.ConversationCollectedData conversation_collected_data = 17;
   */
  conversationCollectedData?: ConversationCollectedData;

  /**
   * the time that the last group of message started. A message group is a
   * continuous set of messages from the same type of sender
   *
   * @generated from field: google.protobuf.Timestamp last_message_group_time = 18;
   */
  lastMessageGroupTime?: Timestamp;

  /**
   * the sender type of the last message group
   *
   * @generated from field: api.commons.OmniSenderType last_message_group_type = 19;
   */
  lastMessageGroupType: OmniSenderType;

  constructor(data?: PartialMessage<Conversation>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.Conversation";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Conversation;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Conversation;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Conversation;

  static equals(a: Conversation | PlainMessage<Conversation> | undefined, b: Conversation | PlainMessage<Conversation> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.ConversationSkills
 */
export declare class ConversationSkills extends Message<ConversationSkills> {
  /**
   * @generated from field: map<string, bool> skills = 1;
   */
  skills: { [key: string]: boolean };

  constructor(data?: PartialMessage<ConversationSkills>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.ConversationSkills";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConversationSkills;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConversationSkills;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConversationSkills;

  static equals(a: ConversationSkills | PlainMessage<ConversationSkills> | undefined, b: ConversationSkills | PlainMessage<ConversationSkills> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.AssignNewConversationReq
 */
export declare class AssignNewConversationReq extends Message<AssignNewConversationReq> {
  /**
   * @generated from field: int64 asm_session_sid = 1;
   */
  asmSessionSid: bigint;

  /**
   * skills
   *
   * @generated from field: map<string, int64> skills = 2;
   */
  skills: { [key: string]: bigint };

  /**
   * channel type - voice|sms|email|chat
   *
   * @generated from field: repeated api.commons.ChannelType channel_types = 3;
   */
  channelTypes: ChannelType[];

  constructor(data?: PartialMessage<AssignNewConversationReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.AssignNewConversationReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssignNewConversationReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssignNewConversationReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssignNewConversationReq;

  static equals(a: AssignNewConversationReq | PlainMessage<AssignNewConversationReq> | undefined, b: AssignNewConversationReq | PlainMessage<AssignNewConversationReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.AssignNewConversationRes
 */
export declare class AssignNewConversationRes extends Message<AssignNewConversationRes> {
  /**
   * @generated from field: api.v1alpha1.asm.Conversation conversation = 1;
   */
  conversation?: Conversation;

  /**
   * send back ghost notifier referenceID
   *
   * @generated from field: string reference_id = 2;
   */
  referenceId: string;

  constructor(data?: PartialMessage<AssignNewConversationRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.AssignNewConversationRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssignNewConversationRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssignNewConversationRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssignNewConversationRes;

  static equals(a: AssignNewConversationRes | PlainMessage<AssignNewConversationRes> | undefined, b: AssignNewConversationRes | PlainMessage<AssignNewConversationRes> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.ListAgentsReq
 */
export declare class ListAgentsReq extends Message<ListAgentsReq> {
  constructor(data?: PartialMessage<ListAgentsReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.ListAgentsReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAgentsReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAgentsReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAgentsReq;

  static equals(a: ListAgentsReq | PlainMessage<ListAgentsReq> | undefined, b: ListAgentsReq | PlainMessage<ListAgentsReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.ListAgentsRes
 */
export declare class ListAgentsRes extends Message<ListAgentsRes> {
  /**
   * list of agents in the system with enrichments
   *
   * @generated from field: repeated api.commons.DashboardAgentInfo agents = 1;
   */
  agents: DashboardAgentInfo[];

  constructor(data?: PartialMessage<ListAgentsRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.ListAgentsRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAgentsRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAgentsRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAgentsRes;

  static equals(a: ListAgentsRes | PlainMessage<ListAgentsRes> | undefined, b: ListAgentsRes | PlainMessage<ListAgentsRes> | undefined): boolean;
}

/**
 * request to set collected data for a conversation
 *
 * @generated from message api.v1alpha1.asm.SetConversationCollectedDataReq
 */
export declare class SetConversationCollectedDataReq extends Message<SetConversationCollectedDataReq> {
  /**
   * conversation_id
   *
   * @generated from field: int64 conversation_sid = 1;
   */
  conversationSid: bigint;

  /**
   * channel type - email|sms|chat|voice
   *
   * @generated from field: api.commons.ChannelType channel_type = 2;
   */
  channelType: ChannelType;

  /**
   * collected data - key/value
   *
   * @generated from field: map<string, string> collected_data = 3;
   */
  collectedData: { [key: string]: string };

  /**
   * asm session sid
   *
   * @generated from field: int64 asm_session_sid = 4;
   */
  asmSessionSid: bigint;

  constructor(data?: PartialMessage<SetConversationCollectedDataReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.SetConversationCollectedDataReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetConversationCollectedDataReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetConversationCollectedDataReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetConversationCollectedDataReq;

  static equals(a: SetConversationCollectedDataReq | PlainMessage<SetConversationCollectedDataReq> | undefined, b: SetConversationCollectedDataReq | PlainMessage<SetConversationCollectedDataReq> | undefined): boolean;
}

/**
 * response after setting collected data for a conversation
 *
 * @generated from message api.v1alpha1.asm.SetConversationCollectedDataRes
 */
export declare class SetConversationCollectedDataRes extends Message<SetConversationCollectedDataRes> {
  constructor(data?: PartialMessage<SetConversationCollectedDataRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.SetConversationCollectedDataRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetConversationCollectedDataRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetConversationCollectedDataRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetConversationCollectedDataRes;

  static equals(a: SetConversationCollectedDataRes | PlainMessage<SetConversationCollectedDataRes> | undefined, b: SetConversationCollectedDataRes | PlainMessage<SetConversationCollectedDataRes> | undefined): boolean;
}

/**
 * ListConversationsReq - request to list all conversations associated with a given user
 *
 * @generated from message api.v1alpha1.asm.ListConversationsReq
 */
export declare class ListConversationsReq extends Message<ListConversationsReq> {
  /**
   * the asm session identifier
   *
   * @generated from field: int64 asm_session_sid = 1;
   */
  asmSessionSid: bigint;

  /**
   * the currently signed in user
   *
   * @generated from field: api.commons.auth.AuthenticatedUser authenticated_user = 2;
   */
  authenticatedUser?: AuthenticatedUser;

  /**
   * an optional field, used to select a specific user rather than the auth user
   *
   * @generated from field: string user_id = 3;
   */
  userId: string;

  /**
   * an optional field, if only wanting to retrieve conversations with specific statuses
   *
   * @generated from field: repeated api.commons.ConversationStatus statuses = 4;
   */
  statuses: ConversationStatus[];

  /**
   * field mask to filter what is returned by each row
   *
   * @generated from field: google.protobuf.FieldMask field_mask = 5;
   */
  fieldMask?: FieldMask;

  /**
   * the channel types to list conversations for
   *
   * @generated from field: repeated api.commons.ChannelType channel_types = 6;
   */
  channelTypes: ChannelType[];

  constructor(data?: PartialMessage<ListConversationsReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.ListConversationsReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListConversationsReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListConversationsReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListConversationsReq;

  static equals(a: ListConversationsReq | PlainMessage<ListConversationsReq> | undefined, b: ListConversationsReq | PlainMessage<ListConversationsReq> | undefined): boolean;
}

/**
 * ListConversationsRes - result to listing a user's conversations
 *
 * @generated from message api.v1alpha1.asm.ListConversationsRes
 */
export declare class ListConversationsRes extends Message<ListConversationsRes> {
  /**
   * the conversations retrieved
   *
   * @generated from field: repeated api.commons.OmniConversation conversations = 1;
   */
  conversations: OmniConversation[];

  /**
   * Token to retrieve the next page of tasks, or empty if there are no more pages
   * Only returned if using the ByTime or ByAssignedUser filters
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;

  constructor(data?: PartialMessage<ListConversationsRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.ListConversationsRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListConversationsRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListConversationsRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListConversationsRes;

  static equals(a: ListConversationsRes | PlainMessage<ListConversationsRes> | undefined, b: ListConversationsRes | PlainMessage<ListConversationsRes> | undefined): boolean;
}

/**
 * GetQueuesDetailsReq - request to get details of queues
 *
 * @generated from message api.v1alpha1.asm.GetQueuesDetailsReq
 */
export declare class GetQueuesDetailsReq extends Message<GetQueuesDetailsReq> {
  /**
   * the agent's asm session
   *
   * @generated from field: int64 asm_session_sid = 1;
   */
  asmSessionSid: bigint;

  /**
   * the channel types to get details for
   *
   * @generated from field: repeated api.commons.ChannelType channel_types = 2;
   */
  channelTypes: ChannelType[];

  /**
   * the skills to check
   *
   * @generated from field: map<string, int64> skills = 3;
   */
  skills: { [key: string]: bigint };

  constructor(data?: PartialMessage<GetQueuesDetailsReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.GetQueuesDetailsReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetQueuesDetailsReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetQueuesDetailsReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetQueuesDetailsReq;

  static equals(a: GetQueuesDetailsReq | PlainMessage<GetQueuesDetailsReq> | undefined, b: GetQueuesDetailsReq | PlainMessage<GetQueuesDetailsReq> | undefined): boolean;
}

/**
 * PushEventsReq - request to push events
 *
 * @generated from message api.v1alpha1.asm.PushEventsReq
 */
export declare class PushEventsReq extends Message<PushEventsReq> {
  /**
   * @generated from field: int64 asm_session_sid = 1;
   */
  asmSessionSid: bigint;

  /**
   * @generated from field: repeated api.commons.AsmEvent events = 2;
   */
  events: AsmEvent[];

  constructor(data?: PartialMessage<PushEventsReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.PushEventsReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PushEventsReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PushEventsReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PushEventsReq;

  static equals(a: PushEventsReq | PlainMessage<PushEventsReq> | undefined, b: PushEventsReq | PlainMessage<PushEventsReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.PushEventsRes
 */
export declare class PushEventsRes extends Message<PushEventsRes> {
  constructor(data?: PartialMessage<PushEventsRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.PushEventsRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PushEventsRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PushEventsRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PushEventsRes;

  static equals(a: PushEventsRes | PlainMessage<PushEventsRes> | undefined, b: PushEventsRes | PlainMessage<PushEventsRes> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.EnableVoiceReq
 */
export declare class EnableVoiceReq extends Message<EnableVoiceReq> {
  /**
   * @generated from field: int64 asm_session_sid = 1;
   */
  asmSessionSid: bigint;

  /**
   * @generated from field: int64 hunt_group_sid = 2;
   */
  huntGroupSid: bigint;

  /**
   * @generated from field: map<string, int64> skills = 3;
   */
  skills: { [key: string]: bigint };

  constructor(data?: PartialMessage<EnableVoiceReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.EnableVoiceReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnableVoiceReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnableVoiceReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnableVoiceReq;

  static equals(a: EnableVoiceReq | PlainMessage<EnableVoiceReq> | undefined, b: EnableVoiceReq | PlainMessage<EnableVoiceReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.EnableVoiceRes
 */
export declare class EnableVoiceRes extends Message<EnableVoiceRes> {
  /**
   * @generated from field: int64 voice_session_sid = 1;
   */
  voiceSessionSid: bigint;

  /**
   * @generated from field: api.v1alpha1.asm.VoiceRegistration voice_registration = 2;
   */
  voiceRegistration?: VoiceRegistration;

  constructor(data?: PartialMessage<EnableVoiceRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.EnableVoiceRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnableVoiceRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnableVoiceRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnableVoiceRes;

  static equals(a: EnableVoiceRes | PlainMessage<EnableVoiceRes> | undefined, b: EnableVoiceRes | PlainMessage<EnableVoiceRes> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.DisableVoiceReq
 */
export declare class DisableVoiceReq extends Message<DisableVoiceReq> {
  /**
   * @generated from field: int64 asm_session_sid = 1;
   */
  asmSessionSid: bigint;

  /**
   * @generated from field: int64 hunt_group_sid = 2;
   */
  huntGroupSid: bigint;

  /**
   * @generated from field: map<string, int64> skills = 3;
   */
  skills: { [key: string]: bigint };

  constructor(data?: PartialMessage<DisableVoiceReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.DisableVoiceReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DisableVoiceReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DisableVoiceReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DisableVoiceReq;

  static equals(a: DisableVoiceReq | PlainMessage<DisableVoiceReq> | undefined, b: DisableVoiceReq | PlainMessage<DisableVoiceReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.asm.DisableVoiceRes
 */
export declare class DisableVoiceRes extends Message<DisableVoiceRes> {
  constructor(data?: PartialMessage<DisableVoiceRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.asm.DisableVoiceRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DisableVoiceRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DisableVoiceRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DisableVoiceRes;

  static equals(a: DisableVoiceRes | PlainMessage<DisableVoiceRes> | undefined, b: DisableVoiceRes | PlainMessage<DisableVoiceRes> | undefined): boolean;
}

