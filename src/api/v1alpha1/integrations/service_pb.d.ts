// @generated by protoc-gen-es v1.5.1 with parameter "target=js+dts"
// @generated from file api/v1alpha1/integrations/service.proto (package api.v1alpha1.integrations, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, FieldMask, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Timestamp } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { CompareOperation, FieldSource, IntegrationType as IntegrationType$1, InvoiceFlow, PaymentFlow, RequestMethod as RequestMethod$1, RequestSource as RequestSource$1, TransactionResult as TransactionResult$1, TransactionType as TransactionType$1, Validation as Validation$1, ValueType, VerificationFlow } from "../../commons/integrations/integrations_pb.js";

/**
 * @generated from message api.v1alpha1.integrations.ListJourneyConfigsReq
 */
export declare class ListJourneyConfigsReq extends Message<ListJourneyConfigsReq> {
  constructor(data?: PartialMessage<ListJourneyConfigsReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.ListJourneyConfigsReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListJourneyConfigsReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListJourneyConfigsReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListJourneyConfigsReq;

  static equals(a: ListJourneyConfigsReq | PlainMessage<ListJourneyConfigsReq> | undefined, b: ListJourneyConfigsReq | PlainMessage<ListJourneyConfigsReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.ListNonJourneyConfigsReq
 */
export declare class ListNonJourneyConfigsReq extends Message<ListNonJourneyConfigsReq> {
  constructor(data?: PartialMessage<ListNonJourneyConfigsReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.ListNonJourneyConfigsReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListNonJourneyConfigsReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListNonJourneyConfigsReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListNonJourneyConfigsReq;

  static equals(a: ListNonJourneyConfigsReq | PlainMessage<ListNonJourneyConfigsReq> | undefined, b: ListNonJourneyConfigsReq | PlainMessage<ListNonJourneyConfigsReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.IntegrationConfigs
 */
export declare class IntegrationConfigs extends Message<IntegrationConfigs> {
  /**
   * @generated from field: repeated api.v1alpha1.integrations.IntegrationConfig values = 1;
   */
  values: IntegrationConfig[];

  constructor(data?: PartialMessage<IntegrationConfigs>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.IntegrationConfigs";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntegrationConfigs;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntegrationConfigs;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntegrationConfigs;

  static equals(a: IntegrationConfigs | PlainMessage<IntegrationConfigs> | undefined, b: IntegrationConfigs | PlainMessage<IntegrationConfigs> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.GetIntegrationConfigReq
 */
export declare class GetIntegrationConfigReq extends Message<GetIntegrationConfigReq> {
  /**
   * @generated from field: api.commons.integrations.IntegrationType integration_id = 3;
   */
  integrationId: IntegrationType$1;

  /**
   * @generated from field: string name = 4;
   */
  name: string;

  /**
   * if this exists, we will do GetIntegrationConfigById, otherwise we will do GetIntegrationConfigByName
   *
   * @generated from field: string id = 5;
   */
  id: string;

  constructor(data?: PartialMessage<GetIntegrationConfigReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.GetIntegrationConfigReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIntegrationConfigReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIntegrationConfigReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIntegrationConfigReq;

  static equals(a: GetIntegrationConfigReq | PlainMessage<GetIntegrationConfigReq> | undefined, b: GetIntegrationConfigReq | PlainMessage<GetIntegrationConfigReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.UpdateIntegrationConfigReq
 */
export declare class UpdateIntegrationConfigReq extends Message<UpdateIntegrationConfigReq> {
  /**
   * if this exists, we will do UpdateIntegrationConfigById, otherwise we will do UpdateIntegrationConfigByName
   *
   * @generated from field: string id = 3;
   */
  id: string;

  /**
   * @generated from field: api.commons.integrations.IntegrationType integration_id = 4;
   */
  integrationId: IntegrationType$1;

  /**
   * @generated from field: string name = 5;
   */
  name: string;

  /**
   * @generated from field: string description = 7;
   */
  description: string;

  /**
   * @generated from field: api.v1alpha1.integrations.Values params = 9;
   */
  params?: Values;

  constructor(data?: PartialMessage<UpdateIntegrationConfigReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.UpdateIntegrationConfigReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateIntegrationConfigReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateIntegrationConfigReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateIntegrationConfigReq;

  static equals(a: UpdateIntegrationConfigReq | PlainMessage<UpdateIntegrationConfigReq> | undefined, b: UpdateIntegrationConfigReq | PlainMessage<UpdateIntegrationConfigReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.DeleteIntegrationConfigReq
 */
export declare class DeleteIntegrationConfigReq extends Message<DeleteIntegrationConfigReq> {
  /**
   * @generated from field: api.commons.integrations.IntegrationType integration_id = 4;
   */
  integrationId: IntegrationType$1;

  /**
   * @generated from field: string name = 5;
   */
  name: string;

  /**
   * if this exists we will delete by id, otherwise we delete by integration_id and name
   *
   * @generated from field: string id = 6;
   */
  id: string;

  constructor(data?: PartialMessage<DeleteIntegrationConfigReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.DeleteIntegrationConfigReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteIntegrationConfigReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteIntegrationConfigReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteIntegrationConfigReq;

  static equals(a: DeleteIntegrationConfigReq | PlainMessage<DeleteIntegrationConfigReq> | undefined, b: DeleteIntegrationConfigReq | PlainMessage<DeleteIntegrationConfigReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.ProcessReq
 */
export declare class ProcessReq extends Message<ProcessReq> {
  /**
   * an identifier for this request so we do not do duplicate calls
   * if a IntegrationsApi.Process() call times out, but doesn't fail
   * you can call IntegrationsApi.Process() again with the same request_id.
   * The second call will just return the result of the previous timed out call
   * instead of processing the request a second time.
   *
   * @generated from field: string request_id = 8;
   */
  requestId: string;

  /**
   * the id of handler we want to trigger
   *
   * @generated from field: api.commons.integrations.IntegrationType integration_id = 3;
   */
  integrationId: IntegrationType$1;

  /**
   * which integration config is going to be triggered
   *
   * @generated from field: api.commons.integrations.RequestMethod method_id = 4;
   */
  methodId: RequestMethod$1;

  /**
   * @generated from field: string config_name = 5;
   */
  configName: string;

  /**
   * if this exists, we will fetch the integration by id
   * otherwise we will get the integration by config_name (legecy)
   *
   * @generated from field: string config_id = 9;
   */
  configId: string;

  /**
   * parameters used for this request. These are combined with the parameters stored in the config
   *
   * @generated from field: map<string, api.v1alpha1.integrations.Value> params = 6;
   */
  params: { [key: string]: Value };

  /**
   * can be left nil, used for verification requests
   *
   * @generated from field: repeated api.v1alpha1.integrations.Condition conds = 7;
   */
  conds: Condition[];

  constructor(data?: PartialMessage<ProcessReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.ProcessReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProcessReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProcessReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProcessReq;

  static equals(a: ProcessReq | PlainMessage<ProcessReq> | undefined, b: ProcessReq | PlainMessage<ProcessReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.ProcessRes
 */
export declare class ProcessRes extends Message<ProcessRes> {
  /**
   * whether we were successful or the bool result the operation returned.
   *
   * @generated from field: bool result = 1;
   */
  result: boolean;

  /**
   * contains the response value from the transaction. This could be an amount for payments
   * an object from inquiries, or it could be nil
   *
   * @generated from field: map<string, api.v1alpha1.integrations.Value> data = 2;
   */
  data: { [key: string]: Value };

  /**
   * integration name that was called
   *
   * @generated from field: string integration = 3;
   */
  integration: string;

  /**
   * method that was called
   *
   * @generated from field: string method = 4;
   */
  method: string;

  /**
   * ID of thing we inserted into the db
   * If this is only empty if we fail to insert a transaction (which will return an error) or
   * the transaction is pending. This happens if we call IntegrationsApi.Process() with the same request_id
   * twice, with the first call timing out.
   *
   * @generated from field: string transaction_id = 5;
   */
  transactionId: string;

  constructor(data?: PartialMessage<ProcessRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.ProcessRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProcessRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProcessRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProcessRes;

  static equals(a: ProcessRes | PlainMessage<ProcessRes> | undefined, b: ProcessRes | PlainMessage<ProcessRes> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.SearchPastTransactionsRequest
 */
export declare class SearchPastTransactionsRequest extends Message<SearchPastTransactionsRequest> {
  /**
   * which plugin instance made this call.
   * optional. If empty string, we use the int_id
   *
   * @generated from field: string plugin_instance_id = 1;
   */
  pluginInstanceId: string;

  /**
   * @generated from field: api.commons.integrations.IntegrationType int_id = 2;
   */
  intId: IntegrationType$1;

  /**
   * which method to look up
   *
   * @generated from field: api.commons.integrations.RequestMethod method_id = 3;
   */
  methodId: RequestMethod$1;

  /**
   * what keys were given to IntegrationsApi during the ivr processing call
   * and the string representation of the values
   *
   * @generated from field: map<string, string> match_fields = 4;
   */
  matchFields: { [key: string]: string };

  /**
   * max records we will be looking for in the response.
   * no more than 10.
   * if left 0, default of 3 is used.
   *
   * @generated from field: uint32 limit = 5;
   */
  limit: number;

  /**
   * if provided, we will start the search at any transactions older than this timestamp.
   * if left empty, we will start at the current time.
   *
   * @generated from field: google.protobuf.Timestamp search_before = 6;
   */
  searchBefore?: Timestamp;

  constructor(data?: PartialMessage<SearchPastTransactionsRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.SearchPastTransactionsRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchPastTransactionsRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchPastTransactionsRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchPastTransactionsRequest;

  static equals(a: SearchPastTransactionsRequest | PlainMessage<SearchPastTransactionsRequest> | undefined, b: SearchPastTransactionsRequest | PlainMessage<SearchPastTransactionsRequest> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.SearchPastTransactionsResponse
 */
export declare class SearchPastTransactionsResponse extends Message<SearchPastTransactionsResponse> {
  /**
   * @generated from field: repeated api.v1alpha1.integrations.PastTxEntity values = 1;
   */
  values: PastTxEntity[];

  constructor(data?: PartialMessage<SearchPastTransactionsResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.SearchPastTransactionsResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchPastTransactionsResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchPastTransactionsResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchPastTransactionsResponse;

  static equals(a: SearchPastTransactionsResponse | PlainMessage<SearchPastTransactionsResponse> | undefined, b: SearchPastTransactionsResponse | PlainMessage<SearchPastTransactionsResponse> | undefined): boolean;
}

/**
 * simplified view of a IntegrationTransaction
 * all values converted to string.
 * only shows the request/resposne data, and timestamp it was created on
 *
 * @generated from message api.v1alpha1.integrations.PastTxEntity
 */
export declare class PastTxEntity extends Message<PastTxEntity> {
  /**
   * @generated from field: map<string, string> req = 1;
   */
  req: { [key: string]: string };

  /**
   * @generated from field: map<string, string> res = 2;
   */
  res: { [key: string]: string };

  /**
   * @generated from field: google.protobuf.Timestamp created_on = 3;
   */
  createdOn?: Timestamp;

  constructor(data?: PartialMessage<PastTxEntity>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.PastTxEntity";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PastTxEntity;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PastTxEntity;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PastTxEntity;

  static equals(a: PastTxEntity | PlainMessage<PastTxEntity> | undefined, b: PastTxEntity | PlainMessage<PastTxEntity> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.ListIntegrationsForOrgReq
 */
export declare class ListIntegrationsForOrgReq extends Message<ListIntegrationsForOrgReq> {
  constructor(data?: PartialMessage<ListIntegrationsForOrgReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.ListIntegrationsForOrgReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListIntegrationsForOrgReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListIntegrationsForOrgReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListIntegrationsForOrgReq;

  static equals(a: ListIntegrationsForOrgReq | PlainMessage<ListIntegrationsForOrgReq> | undefined, b: ListIntegrationsForOrgReq | PlainMessage<ListIntegrationsForOrgReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.IntegrationInfos
 */
export declare class IntegrationInfos extends Message<IntegrationInfos> {
  /**
   * @generated from field: repeated api.v1alpha1.integrations.IntegrationInfo values = 1;
   */
  values: IntegrationInfo[];

  constructor(data?: PartialMessage<IntegrationInfos>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.IntegrationInfos";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntegrationInfos;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntegrationInfos;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntegrationInfos;

  static equals(a: IntegrationInfos | PlainMessage<IntegrationInfos> | undefined, b: IntegrationInfos | PlainMessage<IntegrationInfos> | undefined): boolean;
}

/**
 * IntegrationInfo describes one of our payment sub-services
 * it is used in static structures in integrations/adapters/integrations go packages
 *
 * @generated from message api.v1alpha1.integrations.IntegrationInfo
 */
export declare class IntegrationInfo extends Message<IntegrationInfo> {
  /**
   * the pretty name of this integration. Ex: 'BrainTree'
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * identifies which integration handler this is
   *
   * @generated from field: api.commons.integrations.IntegrationType integration_id = 2;
   */
  integrationId: IntegrationType$1;

  /**
   * describes this integration
   *
   * @generated from field: string description = 3;
   */
  description: string;

  /**
   * what methods are available for this integration
   *
   * @generated from field: repeated api.v1alpha1.integrations.MethodInfo methods = 4;
   */
  methods: MethodInfo[];

  /**
   * the plugin fields for this integration.
   * These fields should be set on the plugin level and not the runtime.
   * key is a value starting at api.commons.integrations.Visiblity.VISIBILITY_GROUP
   * and ending at 99 more than that value, or parameters marked VISIBILITY_ANYWHERE
   *
   * @generated from field: map<int32, api.v1alpha1.integrations.Parameter> group_params = 5;
   */
  groupParams: { [key: number]: Parameter };

  constructor(data?: PartialMessage<IntegrationInfo>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.IntegrationInfo";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntegrationInfo;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntegrationInfo;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntegrationInfo;

  static equals(a: IntegrationInfo | PlainMessage<IntegrationInfo> | undefined, b: IntegrationInfo | PlainMessage<IntegrationInfo> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.MethodInfo
 */
export declare class MethodInfo extends Message<MethodInfo> {
  /**
   * the pretty name of the method
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * identifies which method this is
   *
   * @generated from field: api.commons.integrations.RequestMethod method_id = 2;
   */
  methodId: RequestMethod$1;

  /**
   * what type of method call this is: PAYMENT, INQUIRY, or VERIFY
   *
   * @generated from field: api.commons.integrations.TransactionType tx_type = 3;
   */
  txType: TransactionType$1;

  /**
   * what types of fields can/must be sent with the data when calling the method
   *
   * @generated from field: repeated api.v1alpha1.integrations.Parameter params = 4;
   */
  params: Parameter[];

  /**
   * the url we contact
   *
   * @generated from field: string url = 5;
   */
  url: string;

  /**
   * the expected response map will have these values
   * none of these should be required, and none should have a default value
   *
   * @generated from field: repeated api.v1alpha1.integrations.Parameter response = 6;
   */
  response: Parameter[];

  /**
   * fields specific to this method that should come over during the runtime
   * key will be a value starting at commnos.public.Visiblity.VISIBILITY_RUNTIME
   * and ending at 99 more than that value, or parameeters marked VISIBLITY_ANYWHERE
   *
   * @generated from field: map<int32, api.v1alpha1.integrations.Parameter> runtime_params = 7;
   */
  runtimeParams: { [key: number]: Parameter };

  constructor(data?: PartialMessage<MethodInfo>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.MethodInfo";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MethodInfo;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MethodInfo;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MethodInfo;

  static equals(a: MethodInfo | PlainMessage<MethodInfo> | undefined, b: MethodInfo | PlainMessage<MethodInfo> | undefined): boolean;
}

/**
 * Parameter is describes a key/value pair that needs to be on the requeset object
 * it is used in static structures in integrations/adapters/integrations go packages
 *
 * @generated from message api.v1alpha1.integrations.Parameter
 */
export declare class Parameter extends Message<Parameter> {
  /**
   * name of parameter. This will be the key of the field in the request payload
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * the type of the field. The value of the key value pair needs to be this type in the request payload
   * right now this will be STRING, NUMBER, BOOL
   *
   * @generated from field: api.commons.integrations.ValueType param_type = 2;
   */
  paramType: ValueType;

  /**
   * if the field must appear in the request payload or not
   *
   * @generated from field: bool required = 3;
   */
  required: boolean;

  /**
   * what is used if the value is not provided
   *
   * @generated from field: api.v1alpha1.integrations.Value default_value = 4;
   */
  defaultValue?: Value;

  /**
   * some names are really ugly, display names are what the user should be shown
   *
   * @generated from field: string display_name = 5;
   */
  displayName: string;

  /**
   * means we won't be storing in the database (and there is no way to override)
   *
   * @generated from field: bool sensitive = 6;
   */
  sensitive: boolean;

  /**
   * whether this value can be stored in an integration config.
   * If true, we do not allow the value to be put in the config, the value can only
   * be received during processing.
   * true values should be filtered on the front end
   *
   * @generated from field: bool runtime_param = 7;
   */
  runtimeParam: boolean;

  /**
   * tool tip info about the param
   *
   * @generated from field: string helper_text = 8;
   */
  helperText: string;

  /**
   * means the parameter is not allowed to be editted in the template builder.
   * template builder can use this to field to make the parameter read_only on the ui.
   * integration_config builder ui can ignore this field.
   * usually fields that are template_locked are ones that require extra work to
   * get an appropriate value for. like "collection_id"
   *
   * @generated from field: bool template_locked = 9;
   */
  templateLocked: boolean;

  /**
   * what type of data value we accept
   *
   * @generated from field: api.commons.integrations.Validation validation = 10;
   */
  validation: Validation$1;

  constructor(data?: PartialMessage<Parameter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.Parameter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Parameter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Parameter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Parameter;

  static equals(a: Parameter | PlainMessage<Parameter> | undefined, b: Parameter | PlainMessage<Parameter> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.Empty
 */
export declare class Empty extends Message<Empty> {
  constructor(data?: PartialMessage<Empty>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.Empty";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Empty;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Empty;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Empty;

  static equals(a: Empty | PlainMessage<Empty> | undefined, b: Empty | PlainMessage<Empty> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.GetIntegrationTransactionReq
 */
export declare class GetIntegrationTransactionReq extends Message<GetIntegrationTransactionReq> {
  /**
   * @generated from field: string integration_transaction_id = 1;
   */
  integrationTransactionId: string;

  constructor(data?: PartialMessage<GetIntegrationTransactionReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.GetIntegrationTransactionReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIntegrationTransactionReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIntegrationTransactionReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIntegrationTransactionReq;

  static equals(a: GetIntegrationTransactionReq | PlainMessage<GetIntegrationTransactionReq> | undefined, b: GetIntegrationTransactionReq | PlainMessage<GetIntegrationTransactionReq> | undefined): boolean;
}

/**
 * get a summary of all the aggregated data between two dates
 *
 * @generated from message api.v1alpha1.integrations.GetAggregatedMetadataReq
 */
export declare class GetAggregatedMetadataReq extends Message<GetAggregatedMetadataReq> {
  /**
   * @generated from field: google.protobuf.Timestamp start = 3;
   */
  start?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end = 4;
   */
  end?: Timestamp;

  /**
   * @generated from field: api.commons.integrations.RequestMethod method_id = 5;
   */
  methodId: RequestMethod$1;

  constructor(data?: PartialMessage<GetAggregatedMetadataReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.GetAggregatedMetadataReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAggregatedMetadataReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAggregatedMetadataReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAggregatedMetadataReq;

  static equals(a: GetAggregatedMetadataReq | PlainMessage<GetAggregatedMetadataReq> | undefined, b: GetAggregatedMetadataReq | PlainMessage<GetAggregatedMetadataReq> | undefined): boolean;
}

/**
 * the metadata values. All values should be numbers or dates
 *
 * @generated from message api.v1alpha1.integrations.GetAggregatedMetadataRes
 */
export declare class GetAggregatedMetadataRes extends Message<GetAggregatedMetadataRes> {
  /**
   * @generated from field: int32 views = 1;
   */
  views: number;

  /**
   * @generated from field: int32 verify_attempts = 2;
   */
  verifyAttempts: number;

  /**
   * @generated from field: int32 verify_successes = 3;
   */
  verifySuccesses: number;

  /**
   * @generated from field: int32 payment_attempts = 4;
   */
  paymentAttempts: number;

  /**
   * @generated from field: int32 payment_successes = 5;
   */
  paymentSuccesses: number;

  /**
   * @generated from field: double payment_amount = 6;
   */
  paymentAmount: number;

  /**
   * @generated from field: repeated string fields = 7;
   */
  fields: string[];

  constructor(data?: PartialMessage<GetAggregatedMetadataRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.GetAggregatedMetadataRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAggregatedMetadataRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAggregatedMetadataRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAggregatedMetadataRes;

  static equals(a: GetAggregatedMetadataRes | PlainMessage<GetAggregatedMetadataRes> | undefined, b: GetAggregatedMetadataRes | PlainMessage<GetAggregatedMetadataRes> | undefined): boolean;
}

/**
 * GetIntegrationTransactionReportReq gives summarizes the IntegrationTrasactions between two dates
 *
 * @generated from message api.v1alpha1.integrations.GetIntegrationTransactionReportReq
 */
export declare class GetIntegrationTransactionReportReq extends Message<GetIntegrationTransactionReportReq> {
  /**
   * @generated from field: google.protobuf.Timestamp start = 3;
   */
  start?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end = 4;
   */
  end?: Timestamp;

  /**
   * field names we want to group the data by
   *
   * @generated from field: repeated string group_by = 5;
   */
  groupBy: string[];

  constructor(data?: PartialMessage<GetIntegrationTransactionReportReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.GetIntegrationTransactionReportReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIntegrationTransactionReportReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIntegrationTransactionReportReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIntegrationTransactionReportReq;

  static equals(a: GetIntegrationTransactionReportReq | PlainMessage<GetIntegrationTransactionReportReq> | undefined, b: GetIntegrationTransactionReportReq | PlainMessage<GetIntegrationTransactionReportReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.IntegrationTransactionReportRow
 */
export declare class IntegrationTransactionReportRow extends Message<IntegrationTransactionReportRow> {
  /**
   * integration used
   *
   * @generated from field: api.commons.integrations.IntegrationType integration_id = 5;
   */
  integrationId: IntegrationType$1;

  /**
   * @generated from field: string integration_name = 17;
   */
  integrationName: string;

  /**
   * external service method
   *
   * @generated from field: api.commons.integrations.RequestMethod method_id = 6;
   */
  methodId: RequestMethod$1;

  /**
   * @generated from field: string method_name = 18;
   */
  methodName: string;

  /**
   * payment, data inquiry, etc.
   *
   * @generated from field: api.commons.integrations.TransactionType transaction_type = 7;
   */
  transactionType: TransactionType$1;

  /**
   * email/web/sms/ivr/chat
   *
   * @generated from field: api.commons.integrations.RequestSource request_source = 8;
   */
  requestSource: RequestSource$1;

  /**
   * name of the flow that was ran.
   * two flows can have the same method_id but have different flow_names due to
   * the payment portal and ivr portal using same methods, but different flows.
   * group by this to get rid of ivr data in the text2pay results
   *
   * @generated from field: string flow_name = 20;
   */
  flowName: string;

  /**
   * @generated from field: string campaign_type = 22;
   */
  campaignType: string;

  /**
   * the key value pairs for the 'group_by_fields' passed to the request
   *
   * @generated from field: map<string, string> group_by_values = 23;
   */
  groupByValues: { [key: string]: string };

  /**
   * aggregate results
   *
   * @generated from field: double revenue = 10;
   */
  revenue: number;

  /**
   * date => amount collected subtotals for this row.
   * if the transaction collected = 0 it is not included as an entry.
   * date format for the key is RFC339: "YYYY-MM-DDThh:mm:ss". It will always be in UTC.
   *
   * @generated from field: map<string, double> revenue_subtotals = 19;
   */
  revenueSubtotals: { [key: string]: number };

  /**
   * @generated from field: int64 success_count = 11;
   */
  successCount: bigint;

  /**
   * @generated from field: int64 failure_count = 12;
   */
  failureCount: bigint;

  /**
   * @generated from field: int64 total_count = 13;
   */
  totalCount: bigint;

  /**
   * DD-MM-YYYY format of highest traffic day
   *
   * @generated from field: string highest_traffic_date = 15;
   */
  highestTrafficDate: string;

  /**
   * DD-MM-YYYY format of lowest traffic day
   *
   * @generated from field: string lowest_traffic_date = 16;
   */
  lowestTrafficDate: string;

  /**
   * views, verification, invoice, and payment attempts, etc
   *
   * @generated from field: map<string, int64> count_metrics = 24;
   */
  countMetrics: { [key: string]: bigint };

  /**
   * the names of the fields uploaded to portal link, and sent for enriching portal link campaign info
   * to get these values, you must make a separate api call
   *
   * @generated from field: repeated string fields = 25;
   */
  fields: string[];

  constructor(data?: PartialMessage<IntegrationTransactionReportRow>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.IntegrationTransactionReportRow";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntegrationTransactionReportRow;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntegrationTransactionReportRow;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntegrationTransactionReportRow;

  static equals(a: IntegrationTransactionReportRow | PlainMessage<IntegrationTransactionReportRow> | undefined, b: IntegrationTransactionReportRow | PlainMessage<IntegrationTransactionReportRow> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.GetIntegrationTransactionReportRes
 */
export declare class GetIntegrationTransactionReportRes extends Message<GetIntegrationTransactionReportRes> {
  /**
   * @generated from field: repeated api.v1alpha1.integrations.IntegrationTransactionReportRow values = 1;
   */
  values: IntegrationTransactionReportRow[];

  constructor(data?: PartialMessage<GetIntegrationTransactionReportRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.GetIntegrationTransactionReportRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIntegrationTransactionReportRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIntegrationTransactionReportRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIntegrationTransactionReportRes;

  static equals(a: GetIntegrationTransactionReportRes | PlainMessage<GetIntegrationTransactionReportRes> | undefined, b: GetIntegrationTransactionReportRes | PlainMessage<GetIntegrationTransactionReportRes> | undefined): boolean;
}

/**
 * Lists the integration transactions that match a flow and campaign
 *
 * @generated from message api.v1alpha1.integrations.GetIntegrationTransactionReportDataReq
 */
export declare class GetIntegrationTransactionReportDataReq extends Message<GetIntegrationTransactionReportDataReq> {
  /**
   * @generated from field: google.protobuf.Timestamp start = 3;
   */
  start?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end = 4;
   */
  end?: Timestamp;

  /**
   * which field_names:value we want to see that was in the last request's group_by
   *
   * @generated from field: map<string, string> group_by = 5;
   */
  groupBy: { [key: string]: string };

  /**
   * @generated from field: int32 page_size = 7;
   */
  pageSize: number;

  /**
   * @generated from field: int32 page_num = 8;
   */
  pageNum: number;

  /**
   * @generated from field: api.commons.integrations.IntegrationType integration_id = 9;
   */
  integrationId: IntegrationType$1;

  /**
   * @generated from field: int64 search_after_sid = 10;
   */
  searchAfterSid: bigint;

  constructor(data?: PartialMessage<GetIntegrationTransactionReportDataReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.GetIntegrationTransactionReportDataReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIntegrationTransactionReportDataReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIntegrationTransactionReportDataReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIntegrationTransactionReportDataReq;

  static equals(a: GetIntegrationTransactionReportDataReq | PlainMessage<GetIntegrationTransactionReportDataReq> | undefined, b: GetIntegrationTransactionReportDataReq | PlainMessage<GetIntegrationTransactionReportDataReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.GetIntegrationTransactionReportDataRow
 */
export declare class GetIntegrationTransactionReportDataRow extends Message<GetIntegrationTransactionReportDataRow> {
  /**
   * @generated from field: map<string, int64> count_metrics = 1;
   */
  countMetrics: { [key: string]: bigint };

  /**
   * @generated from field: map<string, string> link_data = 2;
   */
  linkData: { [key: string]: string };

  /**
   * @generated from field: google.protobuf.Timestamp date = 3;
   */
  date?: Timestamp;

  /**
   * @generated from field: double payment_amount = 4;
   */
  paymentAmount: number;

  constructor(data?: PartialMessage<GetIntegrationTransactionReportDataRow>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.GetIntegrationTransactionReportDataRow";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIntegrationTransactionReportDataRow;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIntegrationTransactionReportDataRow;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIntegrationTransactionReportDataRow;

  static equals(a: GetIntegrationTransactionReportDataRow | PlainMessage<GetIntegrationTransactionReportDataRow> | undefined, b: GetIntegrationTransactionReportDataRow | PlainMessage<GetIntegrationTransactionReportDataRow> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.GetIntegrationTransactionReportDataRes
 */
export declare class GetIntegrationTransactionReportDataRes extends Message<GetIntegrationTransactionReportDataRes> {
  /**
   * @generated from field: repeated api.v1alpha1.integrations.GetIntegrationTransactionReportDataRow entities = 1;
   */
  entities: GetIntegrationTransactionReportDataRow[];

  /**
   * @generated from field: int64 last_transaction_sid = 2;
   */
  lastTransactionSid: bigint;

  constructor(data?: PartialMessage<GetIntegrationTransactionReportDataRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.GetIntegrationTransactionReportDataRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIntegrationTransactionReportDataRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIntegrationTransactionReportDataRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIntegrationTransactionReportDataRes;

  static equals(a: GetIntegrationTransactionReportDataRes | PlainMessage<GetIntegrationTransactionReportDataRes> | undefined, b: GetIntegrationTransactionReportDataRes | PlainMessage<GetIntegrationTransactionReportDataRes> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.SearchIntegrationTransactionsReq
 */
export declare class SearchIntegrationTransactionsReq extends Message<SearchIntegrationTransactionsReq> {
  /**
   * optional search parameters
   *
   * @generated from field: google.protobuf.Timestamp start_date = 8;
   */
  startDate?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end_date = 9;
   */
  endDate?: Timestamp;

  /**
   * @generated from field: api.v1alpha1.integrations.IntegrationType integration_type = 10;
   */
  integrationType?: IntegrationType;

  /**
   * @generated from field: api.v1alpha1.integrations.RequestMethod request_method = 11;
   */
  requestMethod?: RequestMethod;

  /**
   * @generated from field: api.v1alpha1.integrations.TransactionType transaction_type = 12;
   */
  transactionType?: TransactionType;

  /**
   * @generated from field: api.v1alpha1.integrations.RequestSource request_source = 13;
   */
  requestSource?: RequestSource;

  /**
   * @generated from field: api.v1alpha1.integrations.TransactionResult result = 14;
   */
  result?: TransactionResult;

  /**
   * @generated from field: string task_id = 15;
   */
  taskId: string;

  constructor(data?: PartialMessage<SearchIntegrationTransactionsReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.SearchIntegrationTransactionsReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchIntegrationTransactionsReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchIntegrationTransactionsReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchIntegrationTransactionsReq;

  static equals(a: SearchIntegrationTransactionsReq | PlainMessage<SearchIntegrationTransactionsReq> | undefined, b: SearchIntegrationTransactionsReq | PlainMessage<SearchIntegrationTransactionsReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.SearchIntegrationTransactionsRes
 */
export declare class SearchIntegrationTransactionsRes extends Message<SearchIntegrationTransactionsRes> {
  /**
   * @generated from field: repeated api.v1alpha1.integrations.IntegrationTransaction transactions = 1;
   */
  transactions: IntegrationTransaction[];

  constructor(data?: PartialMessage<SearchIntegrationTransactionsRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.SearchIntegrationTransactionsRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchIntegrationTransactionsRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchIntegrationTransactionsRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchIntegrationTransactionsRes;

  static equals(a: SearchIntegrationTransactionsRes | PlainMessage<SearchIntegrationTransactionsRes> | undefined, b: SearchIntegrationTransactionsRes | PlainMessage<SearchIntegrationTransactionsRes> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.IntegrationType
 */
export declare class IntegrationType extends Message<IntegrationType> {
  /**
   * @generated from field: api.commons.integrations.IntegrationType integration_id = 1;
   */
  integrationId: IntegrationType$1;

  constructor(data?: PartialMessage<IntegrationType>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.IntegrationType";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntegrationType;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntegrationType;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntegrationType;

  static equals(a: IntegrationType | PlainMessage<IntegrationType> | undefined, b: IntegrationType | PlainMessage<IntegrationType> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.RequestMethod
 */
export declare class RequestMethod extends Message<RequestMethod> {
  /**
   * @generated from field: api.commons.integrations.RequestMethod method_id = 1;
   */
  methodId: RequestMethod$1;

  constructor(data?: PartialMessage<RequestMethod>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.RequestMethod";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestMethod;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestMethod;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestMethod;

  static equals(a: RequestMethod | PlainMessage<RequestMethod> | undefined, b: RequestMethod | PlainMessage<RequestMethod> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.TransactionType
 */
export declare class TransactionType extends Message<TransactionType> {
  /**
   * @generated from field: api.commons.integrations.TransactionType transaction_type = 1;
   */
  transactionType: TransactionType$1;

  constructor(data?: PartialMessage<TransactionType>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.TransactionType";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionType;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionType;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionType;

  static equals(a: TransactionType | PlainMessage<TransactionType> | undefined, b: TransactionType | PlainMessage<TransactionType> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.RequestSource
 */
export declare class RequestSource extends Message<RequestSource> {
  /**
   * @generated from field: api.commons.integrations.RequestSource request_source = 1;
   */
  requestSource: RequestSource$1;

  constructor(data?: PartialMessage<RequestSource>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.RequestSource";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestSource;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestSource;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestSource;

  static equals(a: RequestSource | PlainMessage<RequestSource> | undefined, b: RequestSource | PlainMessage<RequestSource> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.TransactionResult
 */
export declare class TransactionResult extends Message<TransactionResult> {
  /**
   * @generated from field: api.commons.integrations.TransactionResult result = 1;
   */
  result: TransactionResult$1;

  constructor(data?: PartialMessage<TransactionResult>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.TransactionResult";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionResult;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionResult;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionResult;

  static equals(a: TransactionResult | PlainMessage<TransactionResult> | undefined, b: TransactionResult | PlainMessage<TransactionResult> | undefined): boolean;
}

/**
 * used to list all the config names that we have for an integration handler
 *
 * @generated from message api.v1alpha1.integrations.ListIntegrationConfigNamesReq
 */
export declare class ListIntegrationConfigNamesReq extends Message<ListIntegrationConfigNamesReq> {
  /**
   * @generated from field: api.commons.integrations.IntegrationType integration_id = 4;
   */
  integrationId: IntegrationType$1;

  constructor(data?: PartialMessage<ListIntegrationConfigNamesReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.ListIntegrationConfigNamesReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListIntegrationConfigNamesReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListIntegrationConfigNamesReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListIntegrationConfigNamesReq;

  static equals(a: ListIntegrationConfigNamesReq | PlainMessage<ListIntegrationConfigNamesReq> | undefined, b: ListIntegrationConfigNamesReq | PlainMessage<ListIntegrationConfigNamesReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.ListIntegrationConfigNamesRes
 */
export declare class ListIntegrationConfigNamesRes extends Message<ListIntegrationConfigNamesRes> {
  /**
   * @generated from field: api.commons.integrations.IntegrationType integration_id = 3;
   */
  integrationId: IntegrationType$1;

  /**
   * @generated from field: repeated string names = 4;
   */
  names: string[];

  constructor(data?: PartialMessage<ListIntegrationConfigNamesRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.ListIntegrationConfigNamesRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListIntegrationConfigNamesRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListIntegrationConfigNamesRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListIntegrationConfigNamesRes;

  static equals(a: ListIntegrationConfigNamesRes | PlainMessage<ListIntegrationConfigNamesRes> | undefined, b: ListIntegrationConfigNamesRes | PlainMessage<ListIntegrationConfigNamesRes> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.GetPaymentLinkConfigReq
 */
export declare class GetPaymentLinkConfigReq extends Message<GetPaymentLinkConfigReq> {
  /**
   * the pk of payment_link_config table that contains method we will be creating links for
   *
   * @generated from field: string id = 3;
   */
  id: string;

  constructor(data?: PartialMessage<GetPaymentLinkConfigReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.GetPaymentLinkConfigReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPaymentLinkConfigReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPaymentLinkConfigReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPaymentLinkConfigReq;

  static equals(a: GetPaymentLinkConfigReq | PlainMessage<GetPaymentLinkConfigReq> | undefined, b: GetPaymentLinkConfigReq | PlainMessage<GetPaymentLinkConfigReq> | undefined): boolean;
}

/**
 * is just the primary key of the config
 *
 * @generated from message api.v1alpha1.integrations.DeletePaymentLinkConfigReq
 */
export declare class DeletePaymentLinkConfigReq extends Message<DeletePaymentLinkConfigReq> {
  /**
   * @generated from field: string id = 3;
   */
  id: string;

  constructor(data?: PartialMessage<DeletePaymentLinkConfigReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.DeletePaymentLinkConfigReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeletePaymentLinkConfigReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeletePaymentLinkConfigReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeletePaymentLinkConfigReq;

  static equals(a: DeletePaymentLinkConfigReq | PlainMessage<DeletePaymentLinkConfigReq> | undefined, b: DeletePaymentLinkConfigReq | PlainMessage<DeletePaymentLinkConfigReq> | undefined): boolean;
}

/**
 * wrapper message so it can be stored in database correctly
 *
 * @generated from message api.v1alpha1.integrations.Logo
 */
export declare class Logo extends Message<Logo> {
  /**
   * @generated from field: bytes value = 1;
   */
  value: Uint8Array;

  constructor(data?: PartialMessage<Logo>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.Logo";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Logo;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Logo;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Logo;

  static equals(a: Logo | PlainMessage<Logo> | undefined, b: Logo | PlainMessage<Logo> | undefined): boolean;
}

/**
 * LETS MOVE THIS TO portals.proto WHERE IT BELONGS
 *
 * @generated from message api.v1alpha1.integrations.ListPortalConfigsReq
 */
export declare class ListPortalConfigsReq extends Message<ListPortalConfigsReq> {
  /**
   * @generated from field: api.v1alpha1.integrations.PortalConfigId entity = 1;
   */
  entity?: PortalConfigId;

  /**
   * @generated from field: google.protobuf.FieldMask mask = 2;
   */
  mask?: FieldMask;

  /**
   * @generated from field: int32 page_size = 3;
   */
  pageSize: number;

  /**
   * @generated from field: int32 page = 4;
   */
  page: number;

  constructor(data?: PartialMessage<ListPortalConfigsReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.ListPortalConfigsReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListPortalConfigsReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListPortalConfigsReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListPortalConfigsReq;

  static equals(a: ListPortalConfigsReq | PlainMessage<ListPortalConfigsReq> | undefined, b: ListPortalConfigsReq | PlainMessage<ListPortalConfigsReq> | undefined): boolean;
}

/**
 * LETS MOVE THIS TO portals.proto WHERE IT BELONGS
 *
 * @generated from message api.v1alpha1.integrations.GetPortalConfigReq
 */
export declare class GetPortalConfigReq extends Message<GetPortalConfigReq> {
  /**
   * @generated from field: api.v1alpha1.integrations.PortalConfigId entity = 1;
   */
  entity?: PortalConfigId;

  /**
   * @generated from field: google.protobuf.FieldMask mask = 2;
   */
  mask?: FieldMask;

  /**
   * DEPRECATED only here because integrations service needs it
   *
   * @generated from field: string id = 3;
   */
  id: string;

  constructor(data?: PartialMessage<GetPortalConfigReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.GetPortalConfigReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPortalConfigReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPortalConfigReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPortalConfigReq;

  static equals(a: GetPortalConfigReq | PlainMessage<GetPortalConfigReq> | undefined, b: GetPortalConfigReq | PlainMessage<GetPortalConfigReq> | undefined): boolean;
}

/**
 * LETS MOVE THIS TO portals.proto WHERE IT BELONGS
 *
 * @generated from message api.v1alpha1.integrations.DeletePortalConfigReq
 */
export declare class DeletePortalConfigReq extends Message<DeletePortalConfigReq> {
  /**
   * @generated from field: api.v1alpha1.integrations.PortalConfigId entity = 1;
   */
  entity?: PortalConfigId;

  /**
   * @generated from field: google.protobuf.FieldMask mask = 2;
   */
  mask?: FieldMask;

  /**
   * DEPRECATED only here because integrations service needs it
   *
   * @generated from field: string id = 3;
   */
  id: string;

  constructor(data?: PartialMessage<DeletePortalConfigReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.DeletePortalConfigReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeletePortalConfigReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeletePortalConfigReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeletePortalConfigReq;

  static equals(a: DeletePortalConfigReq | PlainMessage<DeletePortalConfigReq> | undefined, b: DeletePortalConfigReq | PlainMessage<DeletePortalConfigReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.UpdatePortalLogoReq
 */
export declare class UpdatePortalLogoReq extends Message<UpdatePortalLogoReq> {
  /**
   * id of portal_config
   *
   * @generated from field: string id = 3;
   */
  id: string;

  /**
   * is the logo used in the corner of the payment portal screen
   *
   * @generated from field: bytes logo = 4;
   */
  logo: Uint8Array;

  constructor(data?: PartialMessage<UpdatePortalLogoReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.UpdatePortalLogoReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdatePortalLogoReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdatePortalLogoReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdatePortalLogoReq;

  static equals(a: UpdatePortalLogoReq | PlainMessage<UpdatePortalLogoReq> | undefined, b: UpdatePortalLogoReq | PlainMessage<UpdatePortalLogoReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.GetPortalLogoReq
 */
export declare class GetPortalLogoReq extends Message<GetPortalLogoReq> {
  /**
   * id of portal_config
   *
   * @generated from field: string id = 3;
   */
  id: string;

  constructor(data?: PartialMessage<GetPortalLogoReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.GetPortalLogoReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPortalLogoReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPortalLogoReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPortalLogoReq;

  static equals(a: GetPortalLogoReq | PlainMessage<GetPortalLogoReq> | undefined, b: GetPortalLogoReq | PlainMessage<GetPortalLogoReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.RefreshLinkReq
 */
export declare class RefreshLinkReq extends Message<RefreshLinkReq> {
  /**
   * the integration_config.name for this link that we generated and encoded in the url
   *
   * @generated from field: string link_id = 3;
   */
  linkId: string;

  constructor(data?: PartialMessage<RefreshLinkReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.RefreshLinkReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RefreshLinkReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RefreshLinkReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RefreshLinkReq;

  static equals(a: RefreshLinkReq | PlainMessage<RefreshLinkReq> | undefined, b: RefreshLinkReq | PlainMessage<RefreshLinkReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.RefreshLinkRes
 */
export declare class RefreshLinkRes extends Message<RefreshLinkRes> {
  /**
   * when the new link will expire
   *
   * @generated from field: google.protobuf.Timestamp new_expiry = 1;
   */
  newExpiry?: Timestamp;

  constructor(data?: PartialMessage<RefreshLinkRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.RefreshLinkRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RefreshLinkRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RefreshLinkRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RefreshLinkRes;

  static equals(a: RefreshLinkRes | PlainMessage<RefreshLinkRes> | undefined, b: RefreshLinkRes | PlainMessage<RefreshLinkRes> | undefined): boolean;
}

/**
 * same as PaymentPortalLinkConfigDB, but with nicer field types
 *
 * @generated from message api.v1alpha1.integrations.PaymentLinkConfig
 */
export declare class PaymentLinkConfig extends Message<PaymentLinkConfig> {
  /**
   * the pk of payment_link_config table that contains method we will be creating links for
   *
   * @generated from field: string id = 19;
   */
  id: string;

  /**
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * @generated from field: string description = 4;
   */
  description: string;

  /**
   * the journey collection that will enrich the link data
   *
   * @generated from field: string collection_id = 5 [deprecated = true];
   * @deprecated
   */
  collectionId: string;

  /**
   * which integration will be used in the links
   *
   * @generated from field: api.commons.integrations.IntegrationType integration_id = 6 [deprecated = true];
   * @deprecated
   */
  integrationId: IntegrationType$1;

  /**
   * the verification method. This is used if there is no collection_id to enrich link data
   *
   * @generated from field: api.commons.integrations.RequestMethod verification_method_id = 7 [deprecated = true];
   * @deprecated
   */
  verificationMethodId: RequestMethod$1;

  /**
   * @generated from field: api.commons.integrations.RequestMethod invoice_method_id = 8 [deprecated = true];
   * @deprecated
   */
  invoiceMethodId: RequestMethod$1;

  /**
   * which method will be called when a payment portal link is process
   *
   * @generated from field: api.commons.integrations.RequestMethod payment_method_id = 9 [deprecated = true];
   * @deprecated
   */
  paymentMethodId: RequestMethod$1;

  /**
   * journey names and method parameter names might not match one to one
   * the keys of this mapping are journey keys
   * the values are method parameter name the key maps to
   * if we encounter a key that is unknown for the method, integrations checks the name mapping
   * for an alternative key name
   *
   * @generated from field: map<string, string> name_mapping = 10;
   */
  nameMapping: { [key: string]: string };

  /**
   * these fields will be used to verify customer identity
   *
   * @generated from field: repeated string verification_fields = 11 [deprecated = true];
   * @deprecated
   */
  verificationFields: string[];

  /**
   * name of the payment portal config that contains all the details for a payment portal screen shown to the user.
   * (visible to link receiver)
   * these don't affect usability of the service, meaning the backend doesn't require any of this info
   *
   * @generated from field: string payment_portal_id = 12;
   */
  paymentPortalId: string;

  /**
   * @generated from field: google.protobuf.Timestamp created_on = 14;
   */
  createdOn?: Timestamp;

  /**
   * how many days till link expires
   *
   * @generated from field: int32 expiry_days = 15;
   */
  expiryDays: number;

  /**
   * whether we are allowed to refresh links
   *
   * @generated from field: bool links_refreshable = 16;
   */
  linksRefreshable: boolean;

  /**
   * how many hours a refreshed link is good for
   * 24 == 1 day
   * 2.5 == 2 hours 30 minutes
   * defaults to 1.0
   *
   * @generated from field: double refresh_link_valid_hours = 17;
   */
  refreshLinkValidHours: number;

  /**
   * how many times we will allow a link to refresh
   *
   * @generated from field: int32 max_refresh_times = 18;
   */
  maxRefreshTimes: number;

  /**
   * how we identify the link holder's identity.
   *
   * @generated from field: api.v1alpha1.integrations.VerificationRequest verification_request = 20;
   */
  verificationRequest?: VerificationRequest;

  /**
   * happens directly after the verification request to provide the user a description of the items
   * that need payment, and their amounts
   *
   * @generated from field: api.v1alpha1.integrations.InvoiceRequest invoice_request = 21;
   */
  invoiceRequest?: InvoiceRequest;

  /**
   * the set of payments the user can choose from. A valid config needs at least one,
   * but can list as many as they want for the user to pick from.
   * only one PaymentRequest will be processed
   *
   * @generated from field: repeated api.v1alpha1.integrations.PaymentRequest payment_requests = 22;
   */
  paymentRequests: PaymentRequest[];

  /**
   * @generated from field: map<string, api.v1alpha1.integrations.Value> base_data = 23;
   */
  baseData: { [key: string]: Value };

  /**
   * a marshalled PaymentTemplates proto message
   *
   * @generated from field: api.v1alpha1.integrations.PaymentLinkConfigTemplates templates = 24;
   */
  templates?: PaymentLinkConfigTemplates;

  /**
   * the name of the profile used to generate this profile
   *
   * @generated from field: string payment_profile_name = 25;
   */
  paymentProfileName: string;

  constructor(data?: PartialMessage<PaymentLinkConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.PaymentLinkConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaymentLinkConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaymentLinkConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaymentLinkConfig;

  static equals(a: PaymentLinkConfig | PlainMessage<PaymentLinkConfig> | undefined, b: PaymentLinkConfig | PlainMessage<PaymentLinkConfig> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.PaymentLinkConfigTemplates
 */
export declare class PaymentLinkConfigTemplates extends Message<PaymentLinkConfigTemplates> {
  /**
   * template string like: "{{name}} thanks for paying {{amount}}"
   * it shows up on the receipt text sent after payment is taken
   * values are populated from what values we know from verification, or in the integration_config
   * so the link designer should not use data that will not be given to tcn at some point to validate a user.
   *
   * @generated from field: string receipt_sms_template = 1;
   */
  receiptSmsTemplate: string;

  /**
   * text shows up as from this phone number
   *
   * @generated from field: string receipt_sms_source_phone = 2;
   */
  receiptSmsSourcePhone: string;

  /**
   * shows up in the email body, is a template string like above
   *
   * @generated from field: string receipt_email_template = 3;
   */
  receiptEmailTemplate: string;

  /**
   * email shows up as from this address
   *
   * @generated from field: string receipt_email_from_addr = 4;
   */
  receiptEmailFromAddr: string;

  /**
   * template string for the receipt shown in the ui
   *
   * @generated from field: string receipt_template = 5;
   */
  receiptTemplate: string;

  /**
   * template string for the invoice shown in the ui
   *
   * @generated from field: string invoice_template = 6;
   */
  invoiceTemplate: string;

  constructor(data?: PartialMessage<PaymentLinkConfigTemplates>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.PaymentLinkConfigTemplates";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaymentLinkConfigTemplates;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaymentLinkConfigTemplates;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaymentLinkConfigTemplates;

  static equals(a: PaymentLinkConfigTemplates | PlainMessage<PaymentLinkConfigTemplates> | undefined, b: PaymentLinkConfigTemplates | PlainMessage<PaymentLinkConfigTemplates> | undefined): boolean;
}

/**
 * VerificationRequest processes verifies
 * the 'verification_fields' match in both an input payload, and the response
 *
 * @generated from message api.v1alpha1.integrations.VerificationRequest
 */
export declare class VerificationRequest extends Message<VerificationRequest> {
  /**
   * the set of actions that need to happen to get a payload that can be used to verify against the verification_fields
   * the verification handler in the service will always populate this with a request containing
   * the integration_config_id data and static data from the user
   * each result will be given as a request the result of all previous responses, so order matters.
   *
   * @generated from field: repeated api.v1alpha1.integrations.Request verification_requests = 1;
   */
  verificationRequests: Request[];

  /**
   * the fields to verify against
   *
   * @generated from field: repeated api.v1alpha1.integrations.Parameter verification_fields = 2;
   */
  verificationFields: Parameter[];

  constructor(data?: PartialMessage<VerificationRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.VerificationRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VerificationRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VerificationRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VerificationRequest;

  static equals(a: VerificationRequest | PlainMessage<VerificationRequest> | undefined, b: VerificationRequest | PlainMessage<VerificationRequest> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.PaymentRequest
 */
export declare class PaymentRequest extends Message<PaymentRequest> {
  /**
   * the field names the user is expected to fill out for this payment
   * the ui should display the parameter's display_name but send to the server the parameter name
   *
   * @generated from field: repeated api.v1alpha1.integrations.Parameter payment_fields = 5;
   */
  paymentFields: Parameter[];

  /**
   * set of actions that need to happen to get a payload that can be used for the payment_request
   * the payment handler in the service will always populate this with a request containing
   * the integration_config_id data, but if that is not enough data for the payment the user is allowed to list out more requests here.
   * the results of all these method calls will be merged into one payload that is given to the payment_request.
   * each result will be given as a request the result of all previous responses, so order matters.
   *
   * @generated from field: repeated api.v1alpha1.integrations.Request payment_request_payload = 1;
   */
  paymentRequestPayload: Request[];

  /**
   * the request to perform
   *
   * @generated from field: api.v1alpha1.integrations.Request payment_request = 2;
   */
  paymentRequest?: Request;

  /**
   * a name for this request to show to the user.  "cc_payment", "ACH Payment" or something else
   *
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * a description of this request to show to the user
   *
   * @generated from field: string description = 4;
   */
  description: string;

  constructor(data?: PartialMessage<PaymentRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.PaymentRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaymentRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaymentRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaymentRequest;

  static equals(a: PaymentRequest | PlainMessage<PaymentRequest> | undefined, b: PaymentRequest | PlainMessage<PaymentRequest> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.InvoiceRequest
 */
export declare class InvoiceRequest extends Message<InvoiceRequest> {
  /**
   * set of actions that need to happen to get a payload that can be used for the invoice_request
   * the verification handler in the service will always populate this with a request with the data used in verifiation
   * but if that is not enough data for the payment the user is allowed to list out more requests here.
   * the results of all these method calls will be merged into one payload that is given to the invoice_request.
   * each result will be given as a request the result of all previous responses, so order matters.
   *
   * @generated from field: repeated api.v1alpha1.integrations.Request invoice_request_payload = 2;
   */
  invoiceRequestPayload: Request[];

  /**
   * @generated from field: api.v1alpha1.integrations.Request invoice_request = 3;
   */
  invoiceRequest?: Request;

  /**
   * removes these keys from the response so they are not shown to the user
   *
   * @generated from field: repeated string filter_response_keys = 4;
   */
  filterResponseKeys: string[];

  constructor(data?: PartialMessage<InvoiceRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.InvoiceRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InvoiceRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InvoiceRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InvoiceRequest;

  static equals(a: InvoiceRequest | PlainMessage<InvoiceRequest> | undefined, b: InvoiceRequest | PlainMessage<InvoiceRequest> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.Request
 */
export declare class Request extends Message<Request> {
  /**
   * @generated from oneof api.v1alpha1.integrations.Request.val
   */
  val: {
    /**
     * look up the values from this journey collection
     *
     * @generated from field: string journey_collection_id = 3;
     */
    value: string;
    case: "journeyCollectionId";
  } | {
    /**
     * call this method to get the data
     *
     * @generated from field: api.v1alpha1.integrations.MethodCall method_call = 4;
     */
    value: MethodCall;
    case: "methodCall";
  } | {
    /**
     * look up data from this config
     *
     * @generated from field: string config_id = 5;
     */
    value: string;
    case: "configId";
  } | { case: undefined; value?: undefined };

  /**
   * add in this static data
   *
   * @generated from field: map<string, api.v1alpha1.integrations.Value> static_data = 6;
   */
  staticData: { [key: string]: Value };

  /**
   * rename the keys to the values in the response from 'val'
   *
   * @generated from field: map<string, string> rename_response_keys = 7;
   */
  renameResponseKeys: { [key: string]: string };

  /**
   * reassigns the names in key to be the value's validation
   *
   * @generated from field: map<string, api.v1alpha1.integrations.Validation> reassign_validations = 8;
   */
  reassignValidations: { [key: string]: Validation };

  constructor(data?: PartialMessage<Request>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.Request";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Request;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Request;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Request;

  static equals(a: Request | PlainMessage<Request> | undefined, b: Request | PlainMessage<Request> | undefined): boolean;
}

/**
 * This type only exists because typescript can't handle
 * a map with an enum as a value from another packages
 * map<string, api.commons.integrations.Validation>
 *
 * @generated from message api.v1alpha1.integrations.Validation
 */
export declare class Validation extends Message<Validation> {
  /**
   * @generated from field: api.commons.integrations.Validation enum = 1;
   */
  enum: Validation$1;

  constructor(data?: PartialMessage<Validation>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.Validation";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Validation;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Validation;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Validation;

  static equals(a: Validation | PlainMessage<Validation> | undefined, b: Validation | PlainMessage<Validation> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.MethodCall
 */
export declare class MethodCall extends Message<MethodCall> {
  /**
   * @generated from field: api.commons.integrations.IntegrationType integration_id = 1;
   */
  integrationId: IntegrationType$1;

  /**
   * @generated from field: api.commons.integrations.RequestMethod method_id = 2;
   */
  methodId: RequestMethod$1;

  constructor(data?: PartialMessage<MethodCall>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.MethodCall";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MethodCall;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MethodCall;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MethodCall;

  static equals(a: MethodCall | PlainMessage<MethodCall> | undefined, b: MethodCall | PlainMessage<MethodCall> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.PortalConfigs
 */
export declare class PortalConfigs extends Message<PortalConfigs> {
  /**
   * @generated from field: repeated api.v1alpha1.integrations.PortalConfig values = 1;
   */
  values: PortalConfig[];

  constructor(data?: PartialMessage<PortalConfigs>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.PortalConfigs";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PortalConfigs;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PortalConfigs;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PortalConfigs;

  static equals(a: PortalConfigs | PlainMessage<PortalConfigs> | undefined, b: PortalConfigs | PlainMessage<PortalConfigs> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.ListPaymentLinkConfigsReq
 */
export declare class ListPaymentLinkConfigsReq extends Message<ListPaymentLinkConfigsReq> {
  constructor(data?: PartialMessage<ListPaymentLinkConfigsReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.ListPaymentLinkConfigsReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListPaymentLinkConfigsReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListPaymentLinkConfigsReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListPaymentLinkConfigsReq;

  static equals(a: ListPaymentLinkConfigsReq | PlainMessage<ListPaymentLinkConfigsReq> | undefined, b: ListPaymentLinkConfigsReq | PlainMessage<ListPaymentLinkConfigsReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.PaymentLinkConfigs
 */
export declare class PaymentLinkConfigs extends Message<PaymentLinkConfigs> {
  /**
   * @generated from field: repeated api.v1alpha1.integrations.PaymentLinkConfig values = 1;
   */
  values: PaymentLinkConfig[];

  constructor(data?: PartialMessage<PaymentLinkConfigs>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.PaymentLinkConfigs";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaymentLinkConfigs;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaymentLinkConfigs;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaymentLinkConfigs;

  static equals(a: PaymentLinkConfigs | PlainMessage<PaymentLinkConfigs> | undefined, b: PaymentLinkConfigs | PlainMessage<PaymentLinkConfigs> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.ListLinksReq
 */
export declare class ListLinksReq extends Message<ListLinksReq> {
  constructor(data?: PartialMessage<ListLinksReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.ListLinksReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListLinksReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListLinksReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListLinksReq;

  static equals(a: ListLinksReq | PlainMessage<ListLinksReq> | undefined, b: ListLinksReq | PlainMessage<ListLinksReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.CreatePaymentPortalLinksReq
 */
export declare class CreatePaymentPortalLinksReq extends Message<CreatePaymentPortalLinksReq> {
  /**
   * the pk of link_config table that contains method we will be creating links for
   *
   * @generated from field: string link_config_id = 3;
   */
  linkConfigId: string;

  /**
   * when the link expires. blank means it never expires
   *
   * @generated from field: google.protobuf.Timestamp expiry = 4;
   */
  expiry?: Timestamp;

  /**
   * each index represents one map of user data we need a link for
   * should contain the sms/email id that is going to use this link at "_task_id"
   *
   * @generated from field: repeated api.v1alpha1.integrations.Task user_data = 5;
   */
  userData: Task[];

  constructor(data?: PartialMessage<CreatePaymentPortalLinksReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.CreatePaymentPortalLinksReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreatePaymentPortalLinksReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreatePaymentPortalLinksReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreatePaymentPortalLinksReq;

  static equals(a: CreatePaymentPortalLinksReq | PlainMessage<CreatePaymentPortalLinksReq> | undefined, b: CreatePaymentPortalLinksReq | PlainMessage<CreatePaymentPortalLinksReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.CreatePaymentPortalLinksRes
 */
export declare class CreatePaymentPortalLinksRes extends Message<CreatePaymentPortalLinksRes> {
  /**
   * each url maps to the same index on the request.user_data
   *
   * @generated from field: repeated string urls = 1;
   */
  urls: string[];

  constructor(data?: PartialMessage<CreatePaymentPortalLinksRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.CreatePaymentPortalLinksRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreatePaymentPortalLinksRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreatePaymentPortalLinksRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreatePaymentPortalLinksRes;

  static equals(a: CreatePaymentPortalLinksRes | PlainMessage<CreatePaymentPortalLinksRes> | undefined, b: CreatePaymentPortalLinksRes | PlainMessage<CreatePaymentPortalLinksRes> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.SummaryReq
 */
export declare class SummaryReq extends Message<SummaryReq> {
  /**
   * a num in YYYY format
   *
   * @generated from field: int32 year = 3;
   */
  year: number;

  constructor(data?: PartialMessage<SummaryReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.SummaryReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SummaryReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SummaryReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SummaryReq;

  static equals(a: SummaryReq | PlainMessage<SummaryReq> | undefined, b: SummaryReq | PlainMessage<SummaryReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.SummaryRes
 */
export declare class SummaryRes extends Message<SummaryRes> {
  /**
   * @generated from field: api.v1alpha1.integrations.CalendarSummary year_summary = 1;
   */
  yearSummary?: CalendarSummary;

  /**
   * @generated from field: repeated api.v1alpha1.integrations.CalendarSummary month_summaries = 2;
   */
  monthSummaries: CalendarSummary[];

  /**
   * @generated from field: repeated api.v1alpha1.integrations.CalendarSummary week_summaries = 3;
   */
  weekSummaries: CalendarSummary[];

  constructor(data?: PartialMessage<SummaryRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.SummaryRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SummaryRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SummaryRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SummaryRes;

  static equals(a: SummaryRes | PlainMessage<SummaryRes> | undefined, b: SummaryRes | PlainMessage<SummaryRes> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.CalendarSummary
 */
export declare class CalendarSummary extends Message<CalendarSummary> {
  /**
   * calendar_num is in either YYYY, MM, or WW format
   *
   * @generated from field: int32 calendar_num = 1;
   */
  calendarNum: number;

  /**
   * @generated from field: api.v1alpha1.integrations.TransactionSummary summary = 2;
   */
  summary?: TransactionSummary;

  /**
   * an array of "pairs" with the integration type and it's transaction summary
   *
   * @generated from field: repeated api.v1alpha1.integrations.IntegrationTypeSummary type_summaries = 3;
   */
  typeSummaries: IntegrationTypeSummary[];

  constructor(data?: PartialMessage<CalendarSummary>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.CalendarSummary";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CalendarSummary;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CalendarSummary;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CalendarSummary;

  static equals(a: CalendarSummary | PlainMessage<CalendarSummary> | undefined, b: CalendarSummary | PlainMessage<CalendarSummary> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.IntegrationTypeSummary
 */
export declare class IntegrationTypeSummary extends Message<IntegrationTypeSummary> {
  /**
   * @generated from field: api.commons.integrations.IntegrationType integration_type = 1;
   */
  integrationType: IntegrationType$1;

  /**
   * @generated from field: api.v1alpha1.integrations.TransactionSummary integration_summary = 2;
   */
  integrationSummary?: TransactionSummary;

  constructor(data?: PartialMessage<IntegrationTypeSummary>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.IntegrationTypeSummary";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntegrationTypeSummary;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntegrationTypeSummary;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntegrationTypeSummary;

  static equals(a: IntegrationTypeSummary | PlainMessage<IntegrationTypeSummary> | undefined, b: IntegrationTypeSummary | PlainMessage<IntegrationTypeSummary> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.TransactionSummary
 */
export declare class TransactionSummary extends Message<TransactionSummary> {
  /**
   * @generated from field: int64 total_transactions_attempted = 1;
   */
  totalTransactionsAttempted: bigint;

  /**
   * @generated from field: int64 total_transactions_completed = 2;
   */
  totalTransactionsCompleted: bigint;

  /**
   * @generated from field: int64 total_transactions_failed = 3;
   */
  totalTransactionsFailed: bigint;

  /**
   * @generated from field: double total_amount_collected = 4;
   */
  totalAmountCollected: number;

  /**
   * @generated from field: double avg_amount_collected = 5;
   */
  avgAmountCollected: number;

  constructor(data?: PartialMessage<TransactionSummary>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.TransactionSummary";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionSummary;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionSummary;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionSummary;

  static equals(a: TransactionSummary | PlainMessage<TransactionSummary> | undefined, b: TransactionSummary | PlainMessage<TransactionSummary> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.ListIntegrationTemplatesByConfigReq
 */
export declare class ListIntegrationTemplatesByConfigReq extends Message<ListIntegrationTemplatesByConfigReq> {
  /**
   * @generated from field: string integration_config_name = 2;
   */
  integrationConfigName: string;

  constructor(data?: PartialMessage<ListIntegrationTemplatesByConfigReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.ListIntegrationTemplatesByConfigReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListIntegrationTemplatesByConfigReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListIntegrationTemplatesByConfigReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListIntegrationTemplatesByConfigReq;

  static equals(a: ListIntegrationTemplatesByConfigReq | PlainMessage<ListIntegrationTemplatesByConfigReq> | undefined, b: ListIntegrationTemplatesByConfigReq | PlainMessage<ListIntegrationTemplatesByConfigReq> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.ListIntegrationTemplatesByConfigRes
 */
export declare class ListIntegrationTemplatesByConfigRes extends Message<ListIntegrationTemplatesByConfigRes> {
  /**
   * @generated from field: repeated api.v1alpha1.integrations.IntegrationTemplateInfo integration_templates = 1;
   */
  integrationTemplates: IntegrationTemplateInfo[];

  constructor(data?: PartialMessage<ListIntegrationTemplatesByConfigRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.ListIntegrationTemplatesByConfigRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListIntegrationTemplatesByConfigRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListIntegrationTemplatesByConfigRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListIntegrationTemplatesByConfigRes;

  static equals(a: ListIntegrationTemplatesByConfigRes | PlainMessage<ListIntegrationTemplatesByConfigRes> | undefined, b: ListIntegrationTemplatesByConfigRes | PlainMessage<ListIntegrationTemplatesByConfigRes> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.IntegrationTemplateInfo
 */
export declare class IntegrationTemplateInfo extends Message<IntegrationTemplateInfo> {
  /**
   * @generated from field: int64 broadcast_template_sid = 1;
   */
  broadcastTemplateSid: bigint;

  /**
   * @generated from field: string template_name = 2;
   */
  templateName: string;

  constructor(data?: PartialMessage<IntegrationTemplateInfo>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.IntegrationTemplateInfo";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntegrationTemplateInfo;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntegrationTemplateInfo;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntegrationTemplateInfo;

  static equals(a: IntegrationTemplateInfo | PlainMessage<IntegrationTemplateInfo> | undefined, b: IntegrationTemplateInfo | PlainMessage<IntegrationTemplateInfo> | undefined): boolean;
}

/**
 * DEPRECATED
 *
 * @generated from message api.v1alpha1.integrations.CopyPaymentLinkConfigReq
 */
export declare class CopyPaymentLinkConfigReq extends Message<CopyPaymentLinkConfigReq> {
  /**
   * @generated from field: string id = 3;
   */
  id: string;

  constructor(data?: PartialMessage<CopyPaymentLinkConfigReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.CopyPaymentLinkConfigReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CopyPaymentLinkConfigReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CopyPaymentLinkConfigReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CopyPaymentLinkConfigReq;

  static equals(a: CopyPaymentLinkConfigReq | PlainMessage<CopyPaymentLinkConfigReq> | undefined, b: CopyPaymentLinkConfigReq | PlainMessage<CopyPaymentLinkConfigReq> | undefined): boolean;
}

/**
 * DEPRECATED
 *
 * @generated from message api.v1alpha1.integrations.CopyPaymentLinkConfigRes
 */
export declare class CopyPaymentLinkConfigRes extends Message<CopyPaymentLinkConfigRes> {
  /**
   * @generated from field: string new_name = 1;
   */
  newName: string;

  constructor(data?: PartialMessage<CopyPaymentLinkConfigRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.CopyPaymentLinkConfigRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CopyPaymentLinkConfigRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CopyPaymentLinkConfigRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CopyPaymentLinkConfigRes;

  static equals(a: CopyPaymentLinkConfigRes | PlainMessage<CopyPaymentLinkConfigRes> | undefined, b: CopyPaymentLinkConfigRes | PlainMessage<CopyPaymentLinkConfigRes> | undefined): boolean;
}

/**
 * DEPRECATED
 *
 * @generated from message api.v1alpha1.integrations.ProfileName
 */
export declare class ProfileName extends Message<ProfileName> {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  constructor(data?: PartialMessage<ProfileName>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.ProfileName";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProfileName;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProfileName;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProfileName;

  static equals(a: ProfileName | PlainMessage<ProfileName> | undefined, b: ProfileName | PlainMessage<ProfileName> | undefined): boolean;
}

/**
 * DEPRECATED
 *
 * @generated from message api.v1alpha1.integrations.PaymentProfiles
 */
export declare class PaymentProfiles extends Message<PaymentProfiles> {
  /**
   * @generated from field: repeated api.v1alpha1.integrations.PaymentProfile values = 1;
   */
  values: PaymentProfile[];

  constructor(data?: PartialMessage<PaymentProfiles>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.PaymentProfiles";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaymentProfiles;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaymentProfiles;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaymentProfiles;

  static equals(a: PaymentProfiles | PlainMessage<PaymentProfiles> | undefined, b: PaymentProfiles | PlainMessage<PaymentProfiles> | undefined): boolean;
}

/**
 * DEPRECATED
 *
 * @generated from message api.v1alpha1.integrations.PaymentProfile
 */
export declare class PaymentProfile extends Message<PaymentProfile> {
  /**
   * @generated from field: string verification = 8;
   */
  verification: string;

  /**
   * @generated from field: string invoice = 9;
   */
  invoice: string;

  /**
   * @generated from field: repeated string payments = 10;
   */
  payments: string[];

  constructor(data?: PartialMessage<PaymentProfile>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.PaymentProfile";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaymentProfile;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaymentProfile;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaymentProfile;

  static equals(a: PaymentProfile | PlainMessage<PaymentProfile> | undefined, b: PaymentProfile | PlainMessage<PaymentProfile> | undefined): boolean;
}

/**
 * DEPRECATED
 *
 * @generated from message api.v1alpha1.integrations.UnknownField
 */
export declare class UnknownField extends Message<UnknownField> {
  /**
   * the name of the field we are missing to make a complete payment link config
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * by default matches name
   * this is the name the user wants the field displayed as
   *
   * @generated from field: string display_name = 5;
   */
  displayName: string;

  /**
   * the reason we need this field.
   * will point to an api call, or form that is listing the field as required
   *
   * @generated from field: string reason_needed = 2;
   */
  reasonNeeded: string;

  /**
   * all the sources that are possible this field could come from
   * it is not allowed to give a provided field with a FieldSource
   * not in this list
   *
   * @generated from field: repeated api.commons.integrations.FieldSource potential_sources = 3;
   */
  potentialSources: FieldSource[];

  /**
   * all the fields in here will be potential fields we could use from api calls, or config look ups
   * THIS COULD BE LEFT BLANK IF THE SERVER HAS NO SUGGESTIONS
   * none of these suggestions have to be used, the user can just "write in" a ProvidedField
   *
   * @generated from field: repeated api.v1alpha1.integrations.ProvidedField suggested_fields = 4;
   */
  suggestedFields: ProvidedField[];

  constructor(data?: PartialMessage<UnknownField>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.UnknownField";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnknownField;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnknownField;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnknownField;

  static equals(a: UnknownField | PlainMessage<UnknownField> | undefined, b: UnknownField | PlainMessage<UnknownField> | undefined): boolean;
}

/**
 * DEPRECATED
 *
 * @generated from message api.v1alpha1.integrations.ProvidedField
 */
export declare class ProvidedField extends Message<ProvidedField> {
  /**
   * the name of the field as it was asked for in UnknownField.
   * This is the field the *server* is looking for, so it *must* be a field
   * that was in the UnknownField list on the Profile
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * by default matches name
   * this is the name the user wants the field displayed as
   *
   * @generated from field: string display_name = 6;
   */
  displayName: string;

  /**
   * what name the field will be called in the original location
   * 'alt_name' can be left blank if it is the same as 'name'
   *
   * @generated from field: string alt_name = 2;
   */
  altName: string;

  /**
   * what source provides this field?
   *  - provided info uploaded when creating the link
   *  - provided by the verification/invoice/payment config/journey data source
   *  - provided by the verification/invoice/payment api call
   *
   * @generated from field: api.commons.integrations.FieldSource provided_by = 3;
   */
  providedBy: FieldSource;

  /**
   * here for future use.
   *
   * @generated from field: int32 provided_by_details_num = 4;
   */
  providedByDetailsNum: number;

  /**
   * here for future use
   *
   * @generated from field: string provided_by_details_str = 5;
   */
  providedByDetailsStr: string;

  constructor(data?: PartialMessage<ProvidedField>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.ProvidedField";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProvidedField;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProvidedField;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProvidedField;

  static equals(a: ProvidedField | PlainMessage<ProvidedField> | undefined, b: ProvidedField | PlainMessage<ProvidedField> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.Values
 */
export declare class Values extends Message<Values> {
  /**
   * @generated from field: map<string, api.v1alpha1.integrations.Value> values = 1;
   */
  values: { [key: string]: Value };

  constructor(data?: PartialMessage<Values>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.Values";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Values;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Values;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Values;

  static equals(a: Values | PlainMessage<Values> | undefined, b: Values | PlainMessage<Values> | undefined): boolean;
}

/**
 * kind of like a json value, but we don't support circular references
 *
 * @generated from message api.v1alpha1.integrations.Value
 */
export declare class Value extends Message<Value> {
  /**
   * @generated from oneof api.v1alpha1.integrations.Value.val
   */
  val: {
    /**
     * @generated from field: string str_val = 1;
     */
    value: string;
    case: "strVal";
  } | {
    /**
     * @generated from field: double num_val = 2;
     */
    value: number;
    case: "numVal";
  } | {
    /**
     * @generated from field: bool bool_val = 3;
     */
    value: boolean;
    case: "boolVal";
  } | {
    /**
     * @generated from field: google.protobuf.Timestamp time_val = 4;
     */
    value: Timestamp;
    case: "timeVal";
  } | {
    /**
     * @generated from field: api.v1alpha1.integrations.CompositeVal comp_val = 6;
     */
    value: CompositeVal;
    case: "compVal";
  } | {
    /**
     * @generated from field: int64 int_val = 7;
     */
    value: bigint;
    case: "intVal";
  } | { case: undefined; value?: undefined };

  /**
   * whether this value should be allowed to be stored
   *
   * @generated from field: bool sensitive = 5;
   */
  sensitive: boolean;

  /**
   * what type of data value we *want* to validate as.
   * a value does *not* have to match the validation enum.
   * a value that does not match its validation enum is just invalid.
   *
   * @generated from field: api.commons.integrations.Validation validation = 8;
   */
  validation: Validation$1;

  constructor(data?: PartialMessage<Value>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.Value";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Value;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Value;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Value;

  static equals(a: Value | PlainMessage<Value> | undefined, b: Value | PlainMessage<Value> | undefined): boolean;
}

/**
 * represents either a field name whose value needs to be looked up in the payload
 * or a static string value
 *
 * @generated from message api.v1alpha1.integrations.FieldOrStr
 */
export declare class FieldOrStr extends Message<FieldOrStr> {
  /**
   * @generated from oneof api.v1alpha1.integrations.FieldOrStr.val
   */
  val: {
    /**
     * @generated from field: string field = 1;
     */
    value: string;
    case: "field";
  } | {
    /**
     * @generated from field: string str_val = 2;
     */
    value: string;
    case: "strVal";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<FieldOrStr>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.FieldOrStr";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldOrStr;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldOrStr;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldOrStr;

  static equals(a: FieldOrStr | PlainMessage<FieldOrStr> | undefined, b: FieldOrStr | PlainMessage<FieldOrStr> | undefined): boolean;
}

/**
 * represents the individual parts of a string, where some of the parts are
 * fields in the payload, and other parts are static strings
 * CompositeVal cannot handle circular references. Meaning you cannot have two
 * values that contain fields of each other in the same payload.
 * Fields that are not found when built into a string will throw an error
 *
 * @generated from message api.v1alpha1.integrations.CompositeVal
 */
export declare class CompositeVal extends Message<CompositeVal> {
  /**
   * @generated from field: repeated api.v1alpha1.integrations.FieldOrStr parts = 1;
   */
  parts: FieldOrStr[];

  constructor(data?: PartialMessage<CompositeVal>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.CompositeVal";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CompositeVal;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CompositeVal;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CompositeVal;

  static equals(a: CompositeVal | PlainMessage<CompositeVal> | undefined, b: CompositeVal | PlainMessage<CompositeVal> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.Condition
 */
export declare class Condition extends Message<Condition> {
  /**
   * json path to the result ex: path.to.the.0.result
   *
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * what operation we are confirming
   *
   * @generated from field: api.commons.integrations.CompareOperation op = 2;
   */
  op: CompareOperation;

  /**
   * we support comparing strings, numbers and bools
   *
   * @generated from field: api.v1alpha1.integrations.Value value = 3;
   */
  value?: Value;

  constructor(data?: PartialMessage<Condition>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.Condition";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Condition;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Condition;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Condition;

  static equals(a: Condition | PlainMessage<Condition> | undefined, b: Condition | PlainMessage<Condition> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.IntegrationConfig
 */
export declare class IntegrationConfig extends Message<IntegrationConfig> {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * @generated from field: api.commons.integrations.IntegrationType integration_id = 4;
   */
  integrationId: IntegrationType$1;

  /**
   * @generated from field: string name = 6;
   */
  name: string;

  /**
   * @generated from field: string description = 7;
   */
  description: string;

  /**
   * @generated from field: api.v1alpha1.integrations.Values params = 9;
   */
  params?: Values;

  /**
   * @generated from field: bool deleted = 10;
   */
  deleted: boolean;

  /**
   * @generated from field: google.protobuf.Timestamp created_on = 11;
   */
  createdOn?: Timestamp;

  /**
   * alternative names that map to parameter names.
   *
   * @generated from field: api.v1alpha1.integrations.MapString alias = 13;
   */
  alias?: MapString;

  /**
   * these conditions will be checked on the integration's response. If any evaluate to false, the integration method will fail
   *
   * @generated from field: api.v1alpha1.integrations.Conditions conds = 14;
   */
  conds?: Conditions;

  /**
   * @generated from field: api.commons.integrations.RequestMethod method_id = 15;
   */
  methodId: RequestMethod$1;

  constructor(data?: PartialMessage<IntegrationConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.IntegrationConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntegrationConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntegrationConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntegrationConfig;

  static equals(a: IntegrationConfig | PlainMessage<IntegrationConfig> | undefined, b: IntegrationConfig | PlainMessage<IntegrationConfig> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.IntegrationTransaction
 */
export declare class IntegrationTransaction extends Message<IntegrationTransaction> {
  /**
   * @generated from field: string integration_transaction_id = 1;
   */
  integrationTransactionId: string;

  /**
   * @generated from field: string task_id = 4;
   */
  taskId: string;

  /**
   * integration used
   *
   * @generated from field: api.commons.integrations.IntegrationType integration_id = 5;
   */
  integrationId: IntegrationType$1;

  /**
   * external service method
   *
   * @generated from field: api.commons.integrations.RequestMethod method_id = 6;
   */
  methodId: RequestMethod$1;

  /**
   * payment, data inquiry, etc.
   *
   * @generated from field: api.commons.integrations.TransactionType transaction_type = 7;
   */
  transactionType: TransactionType$1;

  /**
   * email/web/sms/ivr/chat
   *
   * @generated from field: api.commons.integrations.RequestSource request_source = 8;
   */
  requestSource: RequestSource$1;

  /**
   * success/failure
   *
   * @generated from field: api.commons.integrations.TransactionResult result = 9;
   */
  result: TransactionResult$1;

  /**
   * @generated from field: double amount_collected = 10;
   */
  amountCollected: number;

  /**
   * @generated from field: api.v1alpha1.integrations.Values request_data = 11;
   */
  requestData?: Values;

  /**
   * response from external service
   *
   * @generated from field: api.v1alpha1.integrations.Values response_data = 12;
   */
  responseData?: Values;

  /**
   * @generated from field: google.protobuf.Timestamp created_on = 13;
   */
  createdOn?: Timestamp;

  /**
   * @generated from field: string config_name = 14;
   */
  configName: string;

  /**
   * @generated from field: api.v1alpha1.integrations.Conditions conds = 15;
   */
  conds?: Conditions;

  constructor(data?: PartialMessage<IntegrationTransaction>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.IntegrationTransaction";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntegrationTransaction;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntegrationTransaction;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntegrationTransaction;

  static equals(a: IntegrationTransaction | PlainMessage<IntegrationTransaction> | undefined, b: IntegrationTransaction | PlainMessage<IntegrationTransaction> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.MapString
 */
export declare class MapString extends Message<MapString> {
  /**
   * @generated from field: map<string, string> values = 1;
   */
  values: { [key: string]: string };

  constructor(data?: PartialMessage<MapString>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.MapString";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapString;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapString;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapString;

  static equals(a: MapString | PlainMessage<MapString> | undefined, b: MapString | PlainMessage<MapString> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.Conditions
 */
export declare class Conditions extends Message<Conditions> {
  /**
   * @generated from field: repeated api.v1alpha1.integrations.Condition values = 1;
   */
  values: Condition[];

  constructor(data?: PartialMessage<Conditions>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.Conditions";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Conditions;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Conditions;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Conditions;

  static equals(a: Conditions | PlainMessage<Conditions> | undefined, b: Conditions | PlainMessage<Conditions> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.Task
 */
export declare class Task extends Message<Task> {
  /**
   * the data used to fetch info about this task when the user clicks on a link
   *
   * @generated from field: map<string, api.v1alpha1.integrations.Value> values = 1;
   */
  values: { [key: string]: Value };

  /**
   * the sms_id, email_id, etc that can be used to identify what generated this link
   *
   * @generated from field: string task_id = 2;
   */
  taskId: string;

  /**
   * the type of the source for this link. ex: Email, Sms, Chat
   *
   * @generated from field: api.commons.integrations.RequestSource src = 3;
   */
  src: RequestSource$1;

  constructor(data?: PartialMessage<Task>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.Task";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Task;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Task;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Task;

  static equals(a: Task | PlainMessage<Task> | undefined, b: Task | PlainMessage<Task> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.PortalConfigId
 */
export declare class PortalConfigId extends Message<PortalConfigId> {
  /**
   * @generated from field: string id = 3;
   */
  id: string;

  constructor(data?: PartialMessage<PortalConfigId>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.PortalConfigId";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PortalConfigId;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PortalConfigId;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PortalConfigId;

  static equals(a: PortalConfigId | PlainMessage<PortalConfigId> | undefined, b: PortalConfigId | PlainMessage<PortalConfigId> | undefined): boolean;
}

/**
 * all these things will show up on the portal screen to the receiver of
 * the link contact info should look like the company who is using the portal
 * (not tcn)
 *
 * @generated from message api.v1alpha1.integrations.PortalConfig
 */
export declare class PortalConfig extends Message<PortalConfig> {
  /**
   * @generated from field: string id = 21;
   */
  id: string;

  /**
   * @generated from field: string name = 22;
   */
  name: string;

  /**
   * @generated from field: string description = 23;
   */
  description: string;

  /**
   * link to pull up a chat with customer service
   *
   * @generated from field: string chat_client_link = 2;
   */
  chatClientLink: string;

  /**
   * @generated from field: string contact_email = 3;
   */
  contactEmail: string;

  /**
   * @generated from field: string contact_phone = 4;
   */
  contactPhone: string;

  /**
   * @generated from field: string postal_code = 5;
   */
  postalCode: string;

  /**
   * @generated from field: string city = 6;
   */
  city: string;

  /**
   * @generated from field: string state = 7;
   */
  state: string;

  /**
   * @generated from field: string company_name = 8;
   */
  companyName: string;

  /**
   * is the logo used in the corner of the portal screen
   *
   * @generated from field: bytes logo = 13;
   */
  logo: Uint8Array;

  /**
   * is the primary color used for the portal screen
   *
   * @generated from field: string primary_color = 14;
   */
  primaryColor: string;

  /**
   * accent color used on the portal screen
   *
   * @generated from field: string secondary_color = 15;
   */
  secondaryColor: string;

  /**
   * @generated from field: string street_address = 19;
   */
  streetAddress: string;

  constructor(data?: PartialMessage<PortalConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.PortalConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PortalConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PortalConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PortalConfig;

  static equals(a: PortalConfig | PlainMessage<PortalConfig> | undefined, b: PortalConfig | PlainMessage<PortalConfig> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.PortalLinkId
 */
export declare class PortalLinkId extends Message<PortalLinkId> {
  /**
   * @generated from field: string id = 3;
   */
  id: string;

  constructor(data?: PartialMessage<PortalLinkId>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.PortalLinkId";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PortalLinkId;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PortalLinkId;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PortalLinkId;

  static equals(a: PortalLinkId | PlainMessage<PortalLinkId> | undefined, b: PortalLinkId | PlainMessage<PortalLinkId> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.PortalLink
 */
export declare class PortalLink extends Message<PortalLink> {
  /**
   * @generated from field: string id = 3;
   */
  id: string;

  /**
   * @generated from field: string portal_id = 4;
   */
  portalId: string;

  /**
   * DONT USE
   *
   * @generated from field: string plugin_instance_id = 5 [deprecated = true];
   * @deprecated
   */
  pluginInstanceId: string;

  /**
   * @generated from field: string portal_config_id = 6;
   */
  portalConfigId: string;

  /**
   * @generated from field: string task_id = 7;
   */
  taskId: string;

  /**
   * @generated from field: map<string, api.v1alpha1.integrations.Value> data = 8;
   */
  data: { [key: string]: Value };

  /**
   * @generated from field: map<string, api.v1alpha1.integrations.Value> metadata = 9;
   */
  metadata: { [key: string]: Value };

  /**
   * @generated from field: google.protobuf.Timestamp last_edited = 10;
   */
  lastEdited?: Timestamp;

  constructor(data?: PartialMessage<PortalLink>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.PortalLink";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PortalLink;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PortalLink;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PortalLink;

  static equals(a: PortalLink | PlainMessage<PortalLink> | undefined, b: PortalLink | PlainMessage<PortalLink> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.PortalId
 */
export declare class PortalId extends Message<PortalId> {
  /**
   * @generated from field: string id = 3;
   */
  id: string;

  constructor(data?: PartialMessage<PortalId>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.PortalId";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PortalId;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PortalId;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PortalId;

  static equals(a: PortalId | PlainMessage<PortalId> | undefined, b: PortalId | PlainMessage<PortalId> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.Portal
 */
export declare class Portal extends Message<Portal> {
  /**
   * @generated from field: string id = 3;
   */
  id: string;

  /**
   * @generated from field: string name = 4;
   */
  name: string;

  /**
   * @generated from field: string description = 5;
   */
  description: string;

  /**
   * @generated from field: string portal_config_id = 6;
   */
  portalConfigId: string;

  /**
   * @generated from field: repeated string plugin_inst_ids = 7;
   */
  pluginInstIds: string[];

  /**
   * @generated from field: api.v1alpha1.integrations.PortalType ptype = 8;
   */
  ptype?: PortalType;

  /**
   * @generated from field: google.protobuf.Timestamp last_edited = 9;
   */
  lastEdited?: Timestamp;

  constructor(data?: PartialMessage<Portal>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.Portal";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Portal;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Portal;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Portal;

  static equals(a: Portal | PlainMessage<Portal> | undefined, b: Portal | PlainMessage<Portal> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.PortalText
 */
export declare class PortalText extends Message<PortalText> {
  /**
   * @generated from field: string verification_header = 1;
   */
  verificationHeader: string;

  /**
   * @generated from field: string verification_footer = 2;
   */
  verificationFooter: string;

  /**
   * @generated from field: string payment_header = 3;
   */
  paymentHeader: string;

  /**
   * @generated from field: string payment_footer = 4;
   */
  paymentFooter: string;

  /**
   * @generated from field: string receipt_header = 5;
   */
  receiptHeader: string;

  /**
   * @generated from field: string receipt_footer = 6;
   */
  receiptFooter: string;

  /**
   * @generated from field: string invoice_header = 7;
   */
  invoiceHeader: string;

  /**
   * @generated from field: string invoice_footer = 8;
   */
  invoiceFooter: string;

  constructor(data?: PartialMessage<PortalText>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.PortalText";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PortalText;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PortalText;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PortalText;

  static equals(a: PortalText | PlainMessage<PortalText> | undefined, b: PortalText | PlainMessage<PortalText> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.PortalType
 */
export declare class PortalType extends Message<PortalType> {
  /**
   * @generated from oneof api.v1alpha1.integrations.PortalType.data
   */
  data: {
    /**
     * @generated from field: api.v1alpha1.integrations.PaymentPortal payment_portal = 1;
     */
    value: PaymentPortal;
    case: "paymentPortal";
  } | {
    /**
     * contains info needed for ivr payment
     *
     * @generated from field: api.v1alpha1.integrations.IVRPortal ivr_portal = 2;
     */
    value: IVRPortal;
    case: "ivrPortal";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<PortalType>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.PortalType";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PortalType;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PortalType;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PortalType;

  static equals(a: PortalType | PlainMessage<PortalType> | undefined, b: PortalType | PlainMessage<PortalType> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.PaymentPortal
 */
export declare class PaymentPortal extends Message<PaymentPortal> {
  /**
   * @generated from field: api.commons.integrations.VerificationFlow verification = 8;
   */
  verification?: VerificationFlow;

  /**
   * @generated from field: api.commons.integrations.InvoiceFlow invoice = 9;
   */
  invoice?: InvoiceFlow;

  /**
   * @generated from field: repeated api.commons.integrations.PaymentFlow payments = 10;
   */
  payments: PaymentFlow[];

  /**
   * @generated from field: api.v1alpha1.integrations.PortalText portal_text = 20;
   */
  portalText?: PortalText;

  constructor(data?: PartialMessage<PaymentPortal>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.PaymentPortal";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaymentPortal;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaymentPortal;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaymentPortal;

  static equals(a: PaymentPortal | PlainMessage<PaymentPortal> | undefined, b: PaymentPortal | PlainMessage<PaymentPortal> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.IVRPortal
 */
export declare class IVRPortal extends Message<IVRPortal> {
  constructor(data?: PartialMessage<IVRPortal>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.IVRPortal";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IVRPortal;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IVRPortal;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IVRPortal;

  static equals(a: IVRPortal | PlainMessage<IVRPortal> | undefined, b: IVRPortal | PlainMessage<IVRPortal> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.PluginInstanceId
 */
export declare class PluginInstanceId extends Message<PluginInstanceId> {
  /**
   * @generated from field: string id = 3;
   */
  id: string;

  constructor(data?: PartialMessage<PluginInstanceId>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.PluginInstanceId";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginInstanceId;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginInstanceId;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginInstanceId;

  static equals(a: PluginInstanceId | PlainMessage<PluginInstanceId> | undefined, b: PluginInstanceId | PlainMessage<PluginInstanceId> | undefined): boolean;
}

/**
 * @generated from message api.v1alpha1.integrations.PluginInstance
 */
export declare class PluginInstance extends Message<PluginInstance> {
  /**
   * @generated from field: string id = 3;
   */
  id: string;

  /**
   * @generated from field: string name = 4;
   */
  name: string;

  /**
   * @generated from field: string description = 5;
   */
  description: string;

  /**
   * the plugin type name/label. Ex: 'Experian Payments'
   *
   * @generated from field: string plugin_definition = 6;
   */
  pluginDefinition: string;

  /**
   * @generated from field: api.v1alpha1.integrations.Values data = 7;
   */
  data?: Values;

  /**
   * @generated from field: api.v1alpha1.integrations.Values metadata = 10;
   */
  metadata?: Values;

  /**
   * @generated from field: google.protobuf.Timestamp last_edited = 9;
   */
  lastEdited?: Timestamp;

  /**
   * @generated from field: api.commons.integrations.RequestMethod method_id = 12 [deprecated = true];
   * @deprecated
   */
  methodId: RequestMethod$1;

  /**
   * @generated from field: repeated api.commons.integrations.RequestMethod display_methods = 13;
   */
  displayMethods: RequestMethod$1[];

  constructor(data?: PartialMessage<PluginInstance>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.PluginInstance";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginInstance;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginInstance;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginInstance;

  static equals(a: PluginInstance | PlainMessage<PluginInstance> | undefined, b: PluginInstance | PlainMessage<PluginInstance> | undefined): boolean;
}

/**
 * PortalLinkTransactionRow is all the metrics about a portal link,
 * and how it was used in any integration transactions.
 *
 * @generated from message api.v1alpha1.integrations.PortalLinkTransactionRow
 */
export declare class PortalLinkTransactionRow extends Message<PortalLinkTransactionRow> {
  /**
   * all this from the PortalLink.Metadata map
   *
   * @generated from field: int32 views = 1;
   */
  views: number;

  /**
   * @generated from field: int32 verify_attempts = 2;
   */
  verifyAttempts: number;

  /**
   * @generated from field: int32 verify_successes = 3;
   */
  verifySuccesses: number;

  /**
   * @generated from field: int32 payment_attempts = 4;
   */
  paymentAttempts: number;

  /**
   * @generated from field: int32 payment_successes = 5;
   */
  paymentSuccesses: number;

  /**
   * @generated from field: double payment_amount = 6;
   */
  paymentAmount: number;

  /**
   * @generated from field: google.protobuf.Timestamp date = 7;
   */
  date?: Timestamp;

  /**
   * from PortalLink.Data map
   *
   * @generated from field: map<string, api.v1alpha1.integrations.Value> link_data = 8;
   */
  linkData: { [key: string]: Value };

  constructor(data?: PartialMessage<PortalLinkTransactionRow>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.PortalLinkTransactionRow";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PortalLinkTransactionRow;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PortalLinkTransactionRow;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PortalLinkTransactionRow;

  static equals(a: PortalLinkTransactionRow | PlainMessage<PortalLinkTransactionRow> | undefined, b: PortalLinkTransactionRow | PlainMessage<PortalLinkTransactionRow> | undefined): boolean;
}

/**
 * GetPortalLinksByDateRangeReq gives a paginated view of portal links
 *
 * @generated from message api.v1alpha1.integrations.GetPortalLinksByDateRangeReq
 */
export declare class GetPortalLinksByDateRangeReq extends Message<GetPortalLinksByDateRangeReq> {
  /**
   * @generated from field: string org_id = 1;
   */
  orgId: string;

  /**
   * @generated from field: string region_id = 2;
   */
  regionId: string;

  /**
   * @generated from field: google.protobuf.Timestamp start = 3;
   */
  start?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp end = 4;
   */
  end?: Timestamp;

  /**
   * @generated from field: int32 page_size = 5;
   */
  pageSize: number;

  /**
   * @generated from field: int32 page_num = 6;
   */
  pageNum: number;

  /**
   * @generated from field: api.commons.integrations.RequestMethod method_id = 7;
   */
  methodId: RequestMethod$1;

  constructor(data?: PartialMessage<GetPortalLinksByDateRangeReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.GetPortalLinksByDateRangeReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPortalLinksByDateRangeReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPortalLinksByDateRangeReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPortalLinksByDateRangeReq;

  static equals(a: GetPortalLinksByDateRangeReq | PlainMessage<GetPortalLinksByDateRangeReq> | undefined, b: GetPortalLinksByDateRangeReq | PlainMessage<GetPortalLinksByDateRangeReq> | undefined): boolean;
}

/**
 * GetPortalLinksByDateRangeRes returns a page of data
 *
 * @generated from message api.v1alpha1.integrations.GetPortalLinksByDateRangeRes
 */
export declare class GetPortalLinksByDateRangeRes extends Message<GetPortalLinksByDateRangeRes> {
  /**
   * @generated from field: repeated api.v1alpha1.integrations.PortalLinkTransactionRow rows = 2;
   */
  rows: PortalLinkTransactionRow[];

  constructor(data?: PartialMessage<GetPortalLinksByDateRangeRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "api.v1alpha1.integrations.GetPortalLinksByDateRangeRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPortalLinksByDateRangeRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPortalLinksByDateRangeRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPortalLinksByDateRangeRes;

  static equals(a: GetPortalLinksByDateRangeRes | PlainMessage<GetPortalLinksByDateRangeRes> | undefined, b: GetPortalLinksByDateRangeRes | PlainMessage<GetPortalLinksByDateRangeRes> | undefined): boolean;
}

